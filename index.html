<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  <title>Main</title>
  <style>body { padding: 0; margin: 0; }</style>
</head>

<body>

<pre id="elm"></pre>

<script>
try {
(function(scope){
'use strict';

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}

function F2(fun) {
  return F(2, fun, function(a) { return function(b) { return fun(a,b); }; })
}
function F3(fun) {
  return F(3, fun, function(a) {
    return function(b) { return function(c) { return fun(a, b, c); }; };
  });
}
function F4(fun) {
  return F(4, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return fun(a, b, c, d); }; }; };
  });
}
function F5(fun) {
  return F(5, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
  });
}
function F6(fun) {
  return F(6, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return fun(a, b, c, d, e, f); }; }; }; }; };
  });
}
function F7(fun) {
  return F(7, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
  });
}
function F8(fun) {
  return F(8, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) {
    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
  });
}
function F9(fun) {
  return F(9, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) { return function(i) {
    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
  });
}

function A2(fun, a, b) {
  return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
}
function A3(fun, a, b, c) {
  return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
}
function A4(fun, a, b, c, d) {
  return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
}
function A5(fun, a, b, c, d, e) {
  return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
}
function A6(fun, a, b, c, d, e, f) {
  return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
}
function A7(fun, a, b, c, d, e, f, g) {
  return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
}
function A8(fun, a, b, c, d, e, f, g, h) {
  return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
}
function A9(fun, a, b, c, d, e, f, g, h, i) {
  return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
}

console.warn('Compiled in DEV mode. Follow the advice at https://elm-lang.org/0.19.1/optimize for better performance and smaller assets.');


var _List_Nil_UNUSED = { $: 0 };
var _List_Nil = { $: '[]' };

function _List_Cons_UNUSED(hd, tl) { return { $: 1, a: hd, b: tl }; }
function _List_Cons(hd, tl) { return { $: '::', a: hd, b: tl }; }


var _List_cons = F2(_List_Cons);

function _List_fromArray(arr)
{
	var out = _List_Nil;
	for (var i = arr.length; i--; )
	{
		out = _List_Cons(arr[i], out);
	}
	return out;
}

function _List_toArray(xs)
{
	for (var out = []; xs.b; xs = xs.b) // WHILE_CONS
	{
		out.push(xs.a);
	}
	return out;
}

var _List_map2 = F3(function(f, xs, ys)
{
	for (var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b) // WHILE_CONSES
	{
		arr.push(A2(f, xs.a, ys.a));
	}
	return _List_fromArray(arr);
});

var _List_map3 = F4(function(f, xs, ys, zs)
{
	for (var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A3(f, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_map4 = F5(function(f, ws, xs, ys, zs)
{
	for (var arr = []; ws.b && xs.b && ys.b && zs.b; ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A4(f, ws.a, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_map5 = F6(function(f, vs, ws, xs, ys, zs)
{
	for (var arr = []; vs.b && ws.b && xs.b && ys.b && zs.b; vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A5(f, vs.a, ws.a, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_sortBy = F2(function(f, xs)
{
	return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
		return _Utils_cmp(f(a), f(b));
	}));
});

var _List_sortWith = F2(function(f, xs)
{
	return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
		var ord = A2(f, a, b);
		return ord === $elm$core$Basics$EQ ? 0 : ord === $elm$core$Basics$LT ? -1 : 1;
	}));
});



var _JsArray_empty = [];

function _JsArray_singleton(value)
{
    return [value];
}

function _JsArray_length(array)
{
    return array.length;
}

var _JsArray_initialize = F3(function(size, offset, func)
{
    var result = new Array(size);

    for (var i = 0; i < size; i++)
    {
        result[i] = func(offset + i);
    }

    return result;
});

var _JsArray_initializeFromList = F2(function (max, ls)
{
    var result = new Array(max);

    for (var i = 0; i < max && ls.b; i++)
    {
        result[i] = ls.a;
        ls = ls.b;
    }

    result.length = i;
    return _Utils_Tuple2(result, ls);
});

var _JsArray_unsafeGet = F2(function(index, array)
{
    return array[index];
});

var _JsArray_unsafeSet = F3(function(index, value, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = array[i];
    }

    result[index] = value;
    return result;
});

var _JsArray_push = F2(function(value, array)
{
    var length = array.length;
    var result = new Array(length + 1);

    for (var i = 0; i < length; i++)
    {
        result[i] = array[i];
    }

    result[length] = value;
    return result;
});

var _JsArray_foldl = F3(function(func, acc, array)
{
    var length = array.length;

    for (var i = 0; i < length; i++)
    {
        acc = A2(func, array[i], acc);
    }

    return acc;
});

var _JsArray_foldr = F3(function(func, acc, array)
{
    for (var i = array.length - 1; i >= 0; i--)
    {
        acc = A2(func, array[i], acc);
    }

    return acc;
});

var _JsArray_map = F2(function(func, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = func(array[i]);
    }

    return result;
});

var _JsArray_indexedMap = F3(function(func, offset, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = A2(func, offset + i, array[i]);
    }

    return result;
});

var _JsArray_slice = F3(function(from, to, array)
{
    return array.slice(from, to);
});

var _JsArray_appendN = F3(function(n, dest, source)
{
    var destLen = dest.length;
    var itemsToCopy = n - destLen;

    if (itemsToCopy > source.length)
    {
        itemsToCopy = source.length;
    }

    var size = destLen + itemsToCopy;
    var result = new Array(size);

    for (var i = 0; i < destLen; i++)
    {
        result[i] = dest[i];
    }

    for (var i = 0; i < itemsToCopy; i++)
    {
        result[i + destLen] = source[i];
    }

    return result;
});



// LOG

var _Debug_log_UNUSED = F2(function(tag, value)
{
	return value;
});

var _Debug_log = F2(function(tag, value)
{
	console.log(tag + ': ' + _Debug_toString(value));
	return value;
});


// TODOS

function _Debug_todo(moduleName, region)
{
	return function(message) {
		_Debug_crash(8, moduleName, region, message);
	};
}

function _Debug_todoCase(moduleName, region, value)
{
	return function(message) {
		_Debug_crash(9, moduleName, region, value, message);
	};
}


// TO STRING

function _Debug_toString_UNUSED(value)
{
	return '<internals>';
}

function _Debug_toString(value)
{
	return _Debug_toAnsiString(false, value);
}

function _Debug_toAnsiString(ansi, value)
{
	if (typeof value === 'function')
	{
		return _Debug_internalColor(ansi, '<function>');
	}

	if (typeof value === 'boolean')
	{
		return _Debug_ctorColor(ansi, value ? 'True' : 'False');
	}

	if (typeof value === 'number')
	{
		return _Debug_numberColor(ansi, value + '');
	}

	if (value instanceof String)
	{
		return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
	}

	if (typeof value === 'string')
	{
		return _Debug_stringColor(ansi, '"' + _Debug_addSlashes(value, false) + '"');
	}

	if (typeof value === 'object' && '$' in value)
	{
		var tag = value.$;

		if (typeof tag === 'number')
		{
			return _Debug_internalColor(ansi, '<internals>');
		}

		if (tag[0] === '#')
		{
			var output = [];
			for (var k in value)
			{
				if (k === '$') continue;
				output.push(_Debug_toAnsiString(ansi, value[k]));
			}
			return '(' + output.join(',') + ')';
		}

		if (tag === 'Set_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Set')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Set$toList(value));
		}

		if (tag === 'RBNode_elm_builtin' || tag === 'RBEmpty_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Dict')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Dict$toList(value));
		}

		if (tag === 'Array_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Array')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Array$toList(value));
		}

		if (tag === '::' || tag === '[]')
		{
			var output = '[';

			value.b && (output += _Debug_toAnsiString(ansi, value.a), value = value.b)

			for (; value.b; value = value.b) // WHILE_CONS
			{
				output += ',' + _Debug_toAnsiString(ansi, value.a);
			}
			return output + ']';
		}

		var output = '';
		for (var i in value)
		{
			if (i === '$') continue;
			var str = _Debug_toAnsiString(ansi, value[i]);
			var c0 = str[0];
			var parenless = c0 === '{' || c0 === '(' || c0 === '[' || c0 === '<' || c0 === '"' || str.indexOf(' ') < 0;
			output += ' ' + (parenless ? str : '(' + str + ')');
		}
		return _Debug_ctorColor(ansi, tag) + output;
	}

	if (typeof DataView === 'function' && value instanceof DataView)
	{
		return _Debug_stringColor(ansi, '<' + value.byteLength + ' bytes>');
	}

	if (typeof File !== 'undefined' && value instanceof File)
	{
		return _Debug_internalColor(ansi, '<' + value.name + '>');
	}

	if (typeof value === 'object')
	{
		var output = [];
		for (var key in value)
		{
			var field = key[0] === '_' ? key.slice(1) : key;
			output.push(_Debug_fadeColor(ansi, field) + ' = ' + _Debug_toAnsiString(ansi, value[key]));
		}
		if (output.length === 0)
		{
			return '{}';
		}
		return '{ ' + output.join(', ') + ' }';
	}

	return _Debug_internalColor(ansi, '<internals>');
}

function _Debug_addSlashes(str, isChar)
{
	var s = str
		.replace(/\\/g, '\\\\')
		.replace(/\n/g, '\\n')
		.replace(/\t/g, '\\t')
		.replace(/\r/g, '\\r')
		.replace(/\v/g, '\\v')
		.replace(/\0/g, '\\0');

	if (isChar)
	{
		return s.replace(/\'/g, '\\\'');
	}
	else
	{
		return s.replace(/\"/g, '\\"');
	}
}

function _Debug_ctorColor(ansi, string)
{
	return ansi ? '\x1b[96m' + string + '\x1b[0m' : string;
}

function _Debug_numberColor(ansi, string)
{
	return ansi ? '\x1b[95m' + string + '\x1b[0m' : string;
}

function _Debug_stringColor(ansi, string)
{
	return ansi ? '\x1b[93m' + string + '\x1b[0m' : string;
}

function _Debug_charColor(ansi, string)
{
	return ansi ? '\x1b[92m' + string + '\x1b[0m' : string;
}

function _Debug_fadeColor(ansi, string)
{
	return ansi ? '\x1b[37m' + string + '\x1b[0m' : string;
}

function _Debug_internalColor(ansi, string)
{
	return ansi ? '\x1b[36m' + string + '\x1b[0m' : string;
}

function _Debug_toHexDigit(n)
{
	return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
}


// CRASH


function _Debug_crash_UNUSED(identifier)
{
	throw new Error('https://github.com/elm/core/blob/1.0.0/hints/' + identifier + '.md');
}


function _Debug_crash(identifier, fact1, fact2, fact3, fact4)
{
	switch(identifier)
	{
		case 0:
			throw new Error('What node should I take over? In JavaScript I need something like:\n\n    Elm.Main.init({\n        node: document.getElementById("elm-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.');

		case 1:
			throw new Error('Browser.application programs cannot handle URLs like this:\n\n    ' + document.location.href + '\n\nWhat is the root? The root of your file system? Try looking at this program with `elm reactor` or some other server.');

		case 2:
			var jsonErrorString = fact1;
			throw new Error('Problem with the flags given to your Elm program on initialization.\n\n' + jsonErrorString);

		case 3:
			var portName = fact1;
			throw new Error('There can only be one port named `' + portName + '`, but your program has multiple.');

		case 4:
			var portName = fact1;
			var problem = fact2;
			throw new Error('Trying to send an unexpected type of value through port `' + portName + '`:\n' + problem);

		case 5:
			throw new Error('Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Elm sense.\nRead more about this at https://package.elm-lang.org/packages/elm/core/latest/Basics#== which describes why it is this way and what the better version will look like.');

		case 6:
			var moduleName = fact1;
			throw new Error('Your page is loading multiple Elm scripts with a module named ' + moduleName + '. Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!');

		case 8:
			var moduleName = fact1;
			var region = fact2;
			var message = fact3;
			throw new Error('TODO in module `' + moduleName + '` ' + _Debug_regionToString(region) + '\n\n' + message);

		case 9:
			var moduleName = fact1;
			var region = fact2;
			var value = fact3;
			var message = fact4;
			throw new Error(
				'TODO in module `' + moduleName + '` from the `case` expression '
				+ _Debug_regionToString(region) + '\n\nIt received the following value:\n\n    '
				+ _Debug_toString(value).replace('\n', '\n    ')
				+ '\n\nBut the branch that handles it says:\n\n    ' + message.replace('\n', '\n    ')
			);

		case 10:
			throw new Error('Bug in https://github.com/elm/virtual-dom/issues');

		case 11:
			throw new Error('Cannot perform mod 0. Division by zero error.');
	}
}

function _Debug_regionToString(region)
{
	if (region.start.line === region.end.line)
	{
		return 'on line ' + region.start.line;
	}
	return 'on lines ' + region.start.line + ' through ' + region.end.line;
}



// EQUALITY

function _Utils_eq(x, y)
{
	for (
		var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack);
		isEqual && (pair = stack.pop());
		isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)
		)
	{}

	return isEqual;
}

function _Utils_eqHelp(x, y, depth, stack)
{
	if (x === y)
	{
		return true;
	}

	if (typeof x !== 'object' || x === null || y === null)
	{
		typeof x === 'function' && _Debug_crash(5);
		return false;
	}

	if (depth > 100)
	{
		stack.push(_Utils_Tuple2(x,y));
		return true;
	}

	/**/
	if (x.$ === 'Set_elm_builtin')
	{
		x = $elm$core$Set$toList(x);
		y = $elm$core$Set$toList(y);
	}
	if (x.$ === 'RBNode_elm_builtin' || x.$ === 'RBEmpty_elm_builtin')
	{
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}
	//*/

	/**_UNUSED/
	if (x.$ < 0)
	{
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}
	//*/

	for (var key in x)
	{
		if (!_Utils_eqHelp(x[key], y[key], depth + 1, stack))
		{
			return false;
		}
	}
	return true;
}

var _Utils_equal = F2(_Utils_eq);
var _Utils_notEqual = F2(function(a, b) { return !_Utils_eq(a,b); });



// COMPARISONS

// Code in Generate/JavaScript.hs, Basics.js, and List.js depends on
// the particular integer values assigned to LT, EQ, and GT.

function _Utils_cmp(x, y, ord)
{
	if (typeof x !== 'object')
	{
		return x === y ? /*EQ*/ 0 : x < y ? /*LT*/ -1 : /*GT*/ 1;
	}

	/**/
	if (x instanceof String)
	{
		var a = x.valueOf();
		var b = y.valueOf();
		return a === b ? 0 : a < b ? -1 : 1;
	}
	//*/

	/**_UNUSED/
	if (typeof x.$ === 'undefined')
	//*/
	/**/
	if (x.$[0] === '#')
	//*/
	{
		return (ord = _Utils_cmp(x.a, y.a))
			? ord
			: (ord = _Utils_cmp(x.b, y.b))
				? ord
				: _Utils_cmp(x.c, y.c);
	}

	// traverse conses until end of a list or a mismatch
	for (; x.b && y.b && !(ord = _Utils_cmp(x.a, y.a)); x = x.b, y = y.b) {} // WHILE_CONSES
	return ord || (x.b ? /*GT*/ 1 : y.b ? /*LT*/ -1 : /*EQ*/ 0);
}

var _Utils_lt = F2(function(a, b) { return _Utils_cmp(a, b) < 0; });
var _Utils_le = F2(function(a, b) { return _Utils_cmp(a, b) < 1; });
var _Utils_gt = F2(function(a, b) { return _Utils_cmp(a, b) > 0; });
var _Utils_ge = F2(function(a, b) { return _Utils_cmp(a, b) >= 0; });

var _Utils_compare = F2(function(x, y)
{
	var n = _Utils_cmp(x, y);
	return n < 0 ? $elm$core$Basics$LT : n ? $elm$core$Basics$GT : $elm$core$Basics$EQ;
});


// COMMON VALUES

var _Utils_Tuple0_UNUSED = 0;
var _Utils_Tuple0 = { $: '#0' };

function _Utils_Tuple2_UNUSED(a, b) { return { a: a, b: b }; }
function _Utils_Tuple2(a, b) { return { $: '#2', a: a, b: b }; }

function _Utils_Tuple3_UNUSED(a, b, c) { return { a: a, b: b, c: c }; }
function _Utils_Tuple3(a, b, c) { return { $: '#3', a: a, b: b, c: c }; }

function _Utils_chr_UNUSED(c) { return c; }
function _Utils_chr(c) { return new String(c); }


// RECORDS

function _Utils_update(oldRecord, updatedFields)
{
	var newRecord = {};

	for (var key in oldRecord)
	{
		newRecord[key] = oldRecord[key];
	}

	for (var key in updatedFields)
	{
		newRecord[key] = updatedFields[key];
	}

	return newRecord;
}


// APPEND

var _Utils_append = F2(_Utils_ap);

function _Utils_ap(xs, ys)
{
	// append Strings
	if (typeof xs === 'string')
	{
		return xs + ys;
	}

	// append Lists
	if (!xs.b)
	{
		return ys;
	}
	var root = _List_Cons(xs.a, ys);
	xs = xs.b
	for (var curr = root; xs.b; xs = xs.b) // WHILE_CONS
	{
		curr = curr.b = _List_Cons(xs.a, ys);
	}
	return root;
}



var _String_cons = F2(function(chr, str)
{
	return chr + str;
});

function _String_uncons(string)
{
	var word = string.charCodeAt(0);
	return !isNaN(word)
		? $elm$core$Maybe$Just(
			0xD800 <= word && word <= 0xDBFF
				? _Utils_Tuple2(_Utils_chr(string[0] + string[1]), string.slice(2))
				: _Utils_Tuple2(_Utils_chr(string[0]), string.slice(1))
		)
		: $elm$core$Maybe$Nothing;
}

var _String_append = F2(function(a, b)
{
	return a + b;
});

function _String_length(str)
{
	return str.length;
}

var _String_map = F2(function(func, string)
{
	var len = string.length;
	var array = new Array(len);
	var i = 0;
	while (i < len)
	{
		var word = string.charCodeAt(i);
		if (0xD800 <= word && word <= 0xDBFF)
		{
			array[i] = func(_Utils_chr(string[i] + string[i+1]));
			i += 2;
			continue;
		}
		array[i] = func(_Utils_chr(string[i]));
		i++;
	}
	return array.join('');
});

var _String_filter = F2(function(isGood, str)
{
	var arr = [];
	var len = str.length;
	var i = 0;
	while (i < len)
	{
		var char = str[i];
		var word = str.charCodeAt(i);
		i++;
		if (0xD800 <= word && word <= 0xDBFF)
		{
			char += str[i];
			i++;
		}

		if (isGood(_Utils_chr(char)))
		{
			arr.push(char);
		}
	}
	return arr.join('');
});

function _String_reverse(str)
{
	var len = str.length;
	var arr = new Array(len);
	var i = 0;
	while (i < len)
	{
		var word = str.charCodeAt(i);
		if (0xD800 <= word && word <= 0xDBFF)
		{
			arr[len - i] = str[i + 1];
			i++;
			arr[len - i] = str[i - 1];
			i++;
		}
		else
		{
			arr[len - i] = str[i];
			i++;
		}
	}
	return arr.join('');
}

var _String_foldl = F3(function(func, state, string)
{
	var len = string.length;
	var i = 0;
	while (i < len)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		i++;
		if (0xD800 <= word && word <= 0xDBFF)
		{
			char += string[i];
			i++;
		}
		state = A2(func, _Utils_chr(char), state);
	}
	return state;
});

var _String_foldr = F3(function(func, state, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		state = A2(func, _Utils_chr(char), state);
	}
	return state;
});

var _String_split = F2(function(sep, str)
{
	return str.split(sep);
});

var _String_join = F2(function(sep, strs)
{
	return strs.join(sep);
});

var _String_slice = F3(function(start, end, str) {
	return str.slice(start, end);
});

function _String_trim(str)
{
	return str.trim();
}

function _String_trimLeft(str)
{
	return str.replace(/^\s+/, '');
}

function _String_trimRight(str)
{
	return str.replace(/\s+$/, '');
}

function _String_words(str)
{
	return _List_fromArray(str.trim().split(/\s+/g));
}

function _String_lines(str)
{
	return _List_fromArray(str.split(/\r\n|\r|\n/g));
}

function _String_toUpper(str)
{
	return str.toUpperCase();
}

function _String_toLower(str)
{
	return str.toLowerCase();
}

var _String_any = F2(function(isGood, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		if (isGood(_Utils_chr(char)))
		{
			return true;
		}
	}
	return false;
});

var _String_all = F2(function(isGood, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		if (!isGood(_Utils_chr(char)))
		{
			return false;
		}
	}
	return true;
});

var _String_contains = F2(function(sub, str)
{
	return str.indexOf(sub) > -1;
});

var _String_startsWith = F2(function(sub, str)
{
	return str.indexOf(sub) === 0;
});

var _String_endsWith = F2(function(sub, str)
{
	return str.length >= sub.length &&
		str.lastIndexOf(sub) === str.length - sub.length;
});

var _String_indexes = F2(function(sub, str)
{
	var subLen = sub.length;

	if (subLen < 1)
	{
		return _List_Nil;
	}

	var i = 0;
	var is = [];

	while ((i = str.indexOf(sub, i)) > -1)
	{
		is.push(i);
		i = i + subLen;
	}

	return _List_fromArray(is);
});


// TO STRING

function _String_fromNumber(number)
{
	return number + '';
}


// INT CONVERSIONS

function _String_toInt(str)
{
	var total = 0;
	var code0 = str.charCodeAt(0);
	var start = code0 == 0x2B /* + */ || code0 == 0x2D /* - */ ? 1 : 0;

	for (var i = start; i < str.length; ++i)
	{
		var code = str.charCodeAt(i);
		if (code < 0x30 || 0x39 < code)
		{
			return $elm$core$Maybe$Nothing;
		}
		total = 10 * total + code - 0x30;
	}

	return i == start
		? $elm$core$Maybe$Nothing
		: $elm$core$Maybe$Just(code0 == 0x2D ? -total : total);
}


// FLOAT CONVERSIONS

function _String_toFloat(s)
{
	// check if it is a hex, octal, or binary number
	if (s.length === 0 || /[\sxbo]/.test(s))
	{
		return $elm$core$Maybe$Nothing;
	}
	var n = +s;
	// faster isNaN check
	return n === n ? $elm$core$Maybe$Just(n) : $elm$core$Maybe$Nothing;
}

function _String_fromList(chars)
{
	return _List_toArray(chars).join('');
}




// MATH

var _Basics_add = F2(function(a, b) { return a + b; });
var _Basics_sub = F2(function(a, b) { return a - b; });
var _Basics_mul = F2(function(a, b) { return a * b; });
var _Basics_fdiv = F2(function(a, b) { return a / b; });
var _Basics_idiv = F2(function(a, b) { return (a / b) | 0; });
var _Basics_pow = F2(Math.pow);

var _Basics_remainderBy = F2(function(b, a) { return a % b; });

// https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
var _Basics_modBy = F2(function(modulus, x)
{
	var answer = x % modulus;
	return modulus === 0
		? _Debug_crash(11)
		:
	((answer > 0 && modulus < 0) || (answer < 0 && modulus > 0))
		? answer + modulus
		: answer;
});


// TRIGONOMETRY

var _Basics_pi = Math.PI;
var _Basics_e = Math.E;
var _Basics_cos = Math.cos;
var _Basics_sin = Math.sin;
var _Basics_tan = Math.tan;
var _Basics_acos = Math.acos;
var _Basics_asin = Math.asin;
var _Basics_atan = Math.atan;
var _Basics_atan2 = F2(Math.atan2);


// MORE MATH

function _Basics_toFloat(x) { return x; }
function _Basics_truncate(n) { return n | 0; }
function _Basics_isInfinite(n) { return n === Infinity || n === -Infinity; }

var _Basics_ceiling = Math.ceil;
var _Basics_floor = Math.floor;
var _Basics_round = Math.round;
var _Basics_sqrt = Math.sqrt;
var _Basics_log = Math.log;
var _Basics_isNaN = isNaN;


// BOOLEANS

function _Basics_not(bool) { return !bool; }
var _Basics_and = F2(function(a, b) { return a && b; });
var _Basics_or  = F2(function(a, b) { return a || b; });
var _Basics_xor = F2(function(a, b) { return a !== b; });



function _Char_toCode(char)
{
	var code = char.charCodeAt(0);
	if (0xD800 <= code && code <= 0xDBFF)
	{
		return (code - 0xD800) * 0x400 + char.charCodeAt(1) - 0xDC00 + 0x10000
	}
	return code;
}

function _Char_fromCode(code)
{
	return _Utils_chr(
		(code < 0 || 0x10FFFF < code)
			? '\uFFFD'
			:
		(code <= 0xFFFF)
			? String.fromCharCode(code)
			:
		(code -= 0x10000,
			String.fromCharCode(Math.floor(code / 0x400) + 0xD800, code % 0x400 + 0xDC00)
		)
	);
}

function _Char_toUpper(char)
{
	return _Utils_chr(char.toUpperCase());
}

function _Char_toLower(char)
{
	return _Utils_chr(char.toLowerCase());
}

function _Char_toLocaleUpper(char)
{
	return _Utils_chr(char.toLocaleUpperCase());
}

function _Char_toLocaleLower(char)
{
	return _Utils_chr(char.toLocaleLowerCase());
}



/**/
function _Json_errorToString(error)
{
	return $elm$json$Json$Decode$errorToString(error);
}
//*/


// CORE DECODERS

function _Json_succeed(msg)
{
	return {
		$: 0,
		a: msg
	};
}

function _Json_fail(msg)
{
	return {
		$: 1,
		a: msg
	};
}

function _Json_decodePrim(decoder)
{
	return { $: 2, b: decoder };
}

var _Json_decodeInt = _Json_decodePrim(function(value) {
	return (typeof value !== 'number')
		? _Json_expecting('an INT', value)
		:
	(-2147483647 < value && value < 2147483647 && (value | 0) === value)
		? $elm$core$Result$Ok(value)
		:
	(isFinite(value) && !(value % 1))
		? $elm$core$Result$Ok(value)
		: _Json_expecting('an INT', value);
});

var _Json_decodeBool = _Json_decodePrim(function(value) {
	return (typeof value === 'boolean')
		? $elm$core$Result$Ok(value)
		: _Json_expecting('a BOOL', value);
});

var _Json_decodeFloat = _Json_decodePrim(function(value) {
	return (typeof value === 'number')
		? $elm$core$Result$Ok(value)
		: _Json_expecting('a FLOAT', value);
});

var _Json_decodeValue = _Json_decodePrim(function(value) {
	return $elm$core$Result$Ok(_Json_wrap(value));
});

var _Json_decodeString = _Json_decodePrim(function(value) {
	return (typeof value === 'string')
		? $elm$core$Result$Ok(value)
		: (value instanceof String)
			? $elm$core$Result$Ok(value + '')
			: _Json_expecting('a STRING', value);
});

function _Json_decodeList(decoder) { return { $: 3, b: decoder }; }
function _Json_decodeArray(decoder) { return { $: 4, b: decoder }; }

function _Json_decodeNull(value) { return { $: 5, c: value }; }

var _Json_decodeField = F2(function(field, decoder)
{
	return {
		$: 6,
		d: field,
		b: decoder
	};
});

var _Json_decodeIndex = F2(function(index, decoder)
{
	return {
		$: 7,
		e: index,
		b: decoder
	};
});

function _Json_decodeKeyValuePairs(decoder)
{
	return {
		$: 8,
		b: decoder
	};
}

function _Json_mapMany(f, decoders)
{
	return {
		$: 9,
		f: f,
		g: decoders
	};
}

var _Json_andThen = F2(function(callback, decoder)
{
	return {
		$: 10,
		b: decoder,
		h: callback
	};
});

function _Json_oneOf(decoders)
{
	return {
		$: 11,
		g: decoders
	};
}


// DECODING OBJECTS

var _Json_map1 = F2(function(f, d1)
{
	return _Json_mapMany(f, [d1]);
});

var _Json_map2 = F3(function(f, d1, d2)
{
	return _Json_mapMany(f, [d1, d2]);
});

var _Json_map3 = F4(function(f, d1, d2, d3)
{
	return _Json_mapMany(f, [d1, d2, d3]);
});

var _Json_map4 = F5(function(f, d1, d2, d3, d4)
{
	return _Json_mapMany(f, [d1, d2, d3, d4]);
});

var _Json_map5 = F6(function(f, d1, d2, d3, d4, d5)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5]);
});

var _Json_map6 = F7(function(f, d1, d2, d3, d4, d5, d6)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6]);
});

var _Json_map7 = F8(function(f, d1, d2, d3, d4, d5, d6, d7)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
});

var _Json_map8 = F9(function(f, d1, d2, d3, d4, d5, d6, d7, d8)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
});


// DECODE

var _Json_runOnString = F2(function(decoder, string)
{
	try
	{
		var value = JSON.parse(string);
		return _Json_runHelp(decoder, value);
	}
	catch (e)
	{
		return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, 'This is not valid JSON! ' + e.message, _Json_wrap(string)));
	}
});

var _Json_run = F2(function(decoder, value)
{
	return _Json_runHelp(decoder, _Json_unwrap(value));
});

function _Json_runHelp(decoder, value)
{
	switch (decoder.$)
	{
		case 2:
			return decoder.b(value);

		case 5:
			return (value === null)
				? $elm$core$Result$Ok(decoder.c)
				: _Json_expecting('null', value);

		case 3:
			if (!_Json_isArray(value))
			{
				return _Json_expecting('a LIST', value);
			}
			return _Json_runArrayDecoder(decoder.b, value, _List_fromArray);

		case 4:
			if (!_Json_isArray(value))
			{
				return _Json_expecting('an ARRAY', value);
			}
			return _Json_runArrayDecoder(decoder.b, value, _Json_toElmArray);

		case 6:
			var field = decoder.d;
			if (typeof value !== 'object' || value === null || !(field in value))
			{
				return _Json_expecting('an OBJECT with a field named `' + field + '`', value);
			}
			var result = _Json_runHelp(decoder.b, value[field]);
			return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, field, result.a));

		case 7:
			var index = decoder.e;
			if (!_Json_isArray(value))
			{
				return _Json_expecting('an ARRAY', value);
			}
			if (index >= value.length)
			{
				return _Json_expecting('a LONGER array. Need index ' + index + ' but only see ' + value.length + ' entries', value);
			}
			var result = _Json_runHelp(decoder.b, value[index]);
			return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, index, result.a));

		case 8:
			if (typeof value !== 'object' || value === null || _Json_isArray(value))
			{
				return _Json_expecting('an OBJECT', value);
			}

			var keyValuePairs = _List_Nil;
			// TODO test perf of Object.keys and switch when support is good enough
			for (var key in value)
			{
				if (value.hasOwnProperty(key))
				{
					var result = _Json_runHelp(decoder.b, value[key]);
					if (!$elm$core$Result$isOk(result))
					{
						return $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, key, result.a));
					}
					keyValuePairs = _List_Cons(_Utils_Tuple2(key, result.a), keyValuePairs);
				}
			}
			return $elm$core$Result$Ok($elm$core$List$reverse(keyValuePairs));

		case 9:
			var answer = decoder.f;
			var decoders = decoder.g;
			for (var i = 0; i < decoders.length; i++)
			{
				var result = _Json_runHelp(decoders[i], value);
				if (!$elm$core$Result$isOk(result))
				{
					return result;
				}
				answer = answer(result.a);
			}
			return $elm$core$Result$Ok(answer);

		case 10:
			var result = _Json_runHelp(decoder.b, value);
			return (!$elm$core$Result$isOk(result))
				? result
				: _Json_runHelp(decoder.h(result.a), value);

		case 11:
			var errors = _List_Nil;
			for (var temp = decoder.g; temp.b; temp = temp.b) // WHILE_CONS
			{
				var result = _Json_runHelp(temp.a, value);
				if ($elm$core$Result$isOk(result))
				{
					return result;
				}
				errors = _List_Cons(result.a, errors);
			}
			return $elm$core$Result$Err($elm$json$Json$Decode$OneOf($elm$core$List$reverse(errors)));

		case 1:
			return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, decoder.a, _Json_wrap(value)));

		case 0:
			return $elm$core$Result$Ok(decoder.a);
	}
}

function _Json_runArrayDecoder(decoder, value, toElmValue)
{
	var len = value.length;
	var array = new Array(len);
	for (var i = 0; i < len; i++)
	{
		var result = _Json_runHelp(decoder, value[i]);
		if (!$elm$core$Result$isOk(result))
		{
			return $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, i, result.a));
		}
		array[i] = result.a;
	}
	return $elm$core$Result$Ok(toElmValue(array));
}

function _Json_isArray(value)
{
	return Array.isArray(value) || (typeof FileList !== 'undefined' && value instanceof FileList);
}

function _Json_toElmArray(array)
{
	return A2($elm$core$Array$initialize, array.length, function(i) { return array[i]; });
}

function _Json_expecting(type, value)
{
	return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, 'Expecting ' + type, _Json_wrap(value)));
}


// EQUALITY

function _Json_equality(x, y)
{
	if (x === y)
	{
		return true;
	}

	if (x.$ !== y.$)
	{
		return false;
	}

	switch (x.$)
	{
		case 0:
		case 1:
			return x.a === y.a;

		case 2:
			return x.b === y.b;

		case 5:
			return x.c === y.c;

		case 3:
		case 4:
		case 8:
			return _Json_equality(x.b, y.b);

		case 6:
			return x.d === y.d && _Json_equality(x.b, y.b);

		case 7:
			return x.e === y.e && _Json_equality(x.b, y.b);

		case 9:
			return x.f === y.f && _Json_listEquality(x.g, y.g);

		case 10:
			return x.h === y.h && _Json_equality(x.b, y.b);

		case 11:
			return _Json_listEquality(x.g, y.g);
	}
}

function _Json_listEquality(aDecoders, bDecoders)
{
	var len = aDecoders.length;
	if (len !== bDecoders.length)
	{
		return false;
	}
	for (var i = 0; i < len; i++)
	{
		if (!_Json_equality(aDecoders[i], bDecoders[i]))
		{
			return false;
		}
	}
	return true;
}


// ENCODE

var _Json_encode = F2(function(indentLevel, value)
{
	return JSON.stringify(_Json_unwrap(value), null, indentLevel) + '';
});

function _Json_wrap(value) { return { $: 0, a: value }; }
function _Json_unwrap(value) { return value.a; }

function _Json_wrap_UNUSED(value) { return value; }
function _Json_unwrap_UNUSED(value) { return value; }

function _Json_emptyArray() { return []; }
function _Json_emptyObject() { return {}; }

var _Json_addField = F3(function(key, value, object)
{
	object[key] = _Json_unwrap(value);
	return object;
});

function _Json_addEntry(func)
{
	return F2(function(entry, array)
	{
		array.push(_Json_unwrap(func(entry)));
		return array;
	});
}

var _Json_encodeNull = _Json_wrap(null);



// TASKS

function _Scheduler_succeed(value)
{
	return {
		$: 0,
		a: value
	};
}

function _Scheduler_fail(error)
{
	return {
		$: 1,
		a: error
	};
}

function _Scheduler_binding(callback)
{
	return {
		$: 2,
		b: callback,
		c: null
	};
}

var _Scheduler_andThen = F2(function(callback, task)
{
	return {
		$: 3,
		b: callback,
		d: task
	};
});

var _Scheduler_onError = F2(function(callback, task)
{
	return {
		$: 4,
		b: callback,
		d: task
	};
});

function _Scheduler_receive(callback)
{
	return {
		$: 5,
		b: callback
	};
}


// PROCESSES

var _Scheduler_guid = 0;

function _Scheduler_rawSpawn(task)
{
	var proc = {
		$: 0,
		e: _Scheduler_guid++,
		f: task,
		g: null,
		h: []
	};

	_Scheduler_enqueue(proc);

	return proc;
}

function _Scheduler_spawn(task)
{
	return _Scheduler_binding(function(callback) {
		callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
	});
}

function _Scheduler_rawSend(proc, msg)
{
	proc.h.push(msg);
	_Scheduler_enqueue(proc);
}

var _Scheduler_send = F2(function(proc, msg)
{
	return _Scheduler_binding(function(callback) {
		_Scheduler_rawSend(proc, msg);
		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
});

function _Scheduler_kill(proc)
{
	return _Scheduler_binding(function(callback) {
		var task = proc.f;
		if (task.$ === 2 && task.c)
		{
			task.c();
		}

		proc.f = null;

		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
}


/* STEP PROCESSES

type alias Process =
  { $ : tag
  , id : unique_id
  , root : Task
  , stack : null | { $: SUCCEED | FAIL, a: callback, b: stack }
  , mailbox : [msg]
  }

*/


var _Scheduler_working = false;
var _Scheduler_queue = [];


function _Scheduler_enqueue(proc)
{
	_Scheduler_queue.push(proc);
	if (_Scheduler_working)
	{
		return;
	}
	_Scheduler_working = true;
	while (proc = _Scheduler_queue.shift())
	{
		_Scheduler_step(proc);
	}
	_Scheduler_working = false;
}


function _Scheduler_step(proc)
{
	while (proc.f)
	{
		var rootTag = proc.f.$;
		if (rootTag === 0 || rootTag === 1)
		{
			while (proc.g && proc.g.$ !== rootTag)
			{
				proc.g = proc.g.i;
			}
			if (!proc.g)
			{
				return;
			}
			proc.f = proc.g.b(proc.f.a);
			proc.g = proc.g.i;
		}
		else if (rootTag === 2)
		{
			proc.f.c = proc.f.b(function(newRoot) {
				proc.f = newRoot;
				_Scheduler_enqueue(proc);
			});
			return;
		}
		else if (rootTag === 5)
		{
			if (proc.h.length === 0)
			{
				return;
			}
			proc.f = proc.f.b(proc.h.shift());
		}
		else // if (rootTag === 3 || rootTag === 4)
		{
			proc.g = {
				$: rootTag === 3 ? 0 : 1,
				b: proc.f.b,
				i: proc.g
			};
			proc.f = proc.f.d;
		}
	}
}



function _Process_sleep(time)
{
	return _Scheduler_binding(function(callback) {
		var id = setTimeout(function() {
			callback(_Scheduler_succeed(_Utils_Tuple0));
		}, time);

		return function() { clearTimeout(id); };
	});
}




// PROGRAMS


var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		flagDecoder,
		args,
		impl.init,
		impl.update,
		impl.subscriptions,
		function() { return function() {} }
	);
});



// INITIALIZE A PROGRAM


function _Platform_initialize(flagDecoder, args, init, update, subscriptions, stepperBuilder)
{
	var result = A2(_Json_run, flagDecoder, _Json_wrap(args ? args['flags'] : undefined));
	$elm$core$Result$isOk(result) || _Debug_crash(2 /**/, _Json_errorToString(result.a) /**/);
	var managers = {};
	var initPair = init(result.a);
	var model = initPair.a;
	var stepper = stepperBuilder(sendToApp, model);
	var ports = _Platform_setupEffects(managers, sendToApp);

	function sendToApp(msg, viewMetadata)
	{
		var pair = A2(update, msg, model);
		stepper(model = pair.a, viewMetadata);
		_Platform_enqueueEffects(managers, pair.b, subscriptions(model));
	}

	_Platform_enqueueEffects(managers, initPair.b, subscriptions(model));

	return ports ? { ports: ports } : {};
}



// TRACK PRELOADS
//
// This is used by code in elm/browser and elm/http
// to register any HTTP requests that are triggered by init.
//


var _Platform_preload;


function _Platform_registerPreload(url)
{
	_Platform_preload.add(url);
}



// EFFECT MANAGERS


var _Platform_effectManagers = {};


function _Platform_setupEffects(managers, sendToApp)
{
	var ports;

	// setup all necessary effect managers
	for (var key in _Platform_effectManagers)
	{
		var manager = _Platform_effectManagers[key];

		if (manager.a)
		{
			ports = ports || {};
			ports[key] = manager.a(key, sendToApp);
		}

		managers[key] = _Platform_instantiateManager(manager, sendToApp);
	}

	return ports;
}


function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap)
{
	return {
		b: init,
		c: onEffects,
		d: onSelfMsg,
		e: cmdMap,
		f: subMap
	};
}


function _Platform_instantiateManager(info, sendToApp)
{
	var router = {
		g: sendToApp,
		h: undefined
	};

	var onEffects = info.c;
	var onSelfMsg = info.d;
	var cmdMap = info.e;
	var subMap = info.f;

	function loop(state)
	{
		return A2(_Scheduler_andThen, loop, _Scheduler_receive(function(msg)
		{
			var value = msg.a;

			if (msg.$ === 0)
			{
				return A3(onSelfMsg, router, value, state);
			}

			return cmdMap && subMap
				? A4(onEffects, router, value.i, value.j, state)
				: A3(onEffects, router, cmdMap ? value.i : value.j, state);
		}));
	}

	return router.h = _Scheduler_rawSpawn(A2(_Scheduler_andThen, loop, info.b));
}



// ROUTING


var _Platform_sendToApp = F2(function(router, msg)
{
	return _Scheduler_binding(function(callback)
	{
		router.g(msg);
		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
});


var _Platform_sendToSelf = F2(function(router, msg)
{
	return A2(_Scheduler_send, router.h, {
		$: 0,
		a: msg
	});
});



// BAGS


function _Platform_leaf(home)
{
	return function(value)
	{
		return {
			$: 1,
			k: home,
			l: value
		};
	};
}


function _Platform_batch(list)
{
	return {
		$: 2,
		m: list
	};
}


var _Platform_map = F2(function(tagger, bag)
{
	return {
		$: 3,
		n: tagger,
		o: bag
	}
});



// PIPE BAGS INTO EFFECT MANAGERS
//
// Effects must be queued!
//
// Say your init contains a synchronous command, like Time.now or Time.here
//
//   - This will produce a batch of effects (FX_1)
//   - The synchronous task triggers the subsequent `update` call
//   - This will produce a batch of effects (FX_2)
//
// If we just start dispatching FX_2, subscriptions from FX_2 can be processed
// before subscriptions from FX_1. No good! Earlier versions of this code had
// this problem, leading to these reports:
//
//   https://github.com/elm/core/issues/980
//   https://github.com/elm/core/pull/981
//   https://github.com/elm/compiler/issues/1776
//
// The queue is necessary to avoid ordering issues for synchronous commands.


// Why use true/false here? Why not just check the length of the queue?
// The goal is to detect "are we currently dispatching effects?" If we
// are, we need to bail and let the ongoing while loop handle things.
//
// Now say the queue has 1 element. When we dequeue the final element,
// the queue will be empty, but we are still actively dispatching effects.
// So you could get queue jumping in a really tricky category of cases.
//
var _Platform_effectsQueue = [];
var _Platform_effectsActive = false;


function _Platform_enqueueEffects(managers, cmdBag, subBag)
{
	_Platform_effectsQueue.push({ p: managers, q: cmdBag, r: subBag });

	if (_Platform_effectsActive) return;

	_Platform_effectsActive = true;
	for (var fx; fx = _Platform_effectsQueue.shift(); )
	{
		_Platform_dispatchEffects(fx.p, fx.q, fx.r);
	}
	_Platform_effectsActive = false;
}


function _Platform_dispatchEffects(managers, cmdBag, subBag)
{
	var effectsDict = {};
	_Platform_gatherEffects(true, cmdBag, effectsDict, null);
	_Platform_gatherEffects(false, subBag, effectsDict, null);

	for (var home in managers)
	{
		_Scheduler_rawSend(managers[home], {
			$: 'fx',
			a: effectsDict[home] || { i: _List_Nil, j: _List_Nil }
		});
	}
}


function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers)
{
	switch (bag.$)
	{
		case 1:
			var home = bag.k;
			var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
			effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
			return;

		case 2:
			for (var list = bag.m; list.b; list = list.b) // WHILE_CONS
			{
				_Platform_gatherEffects(isCmd, list.a, effectsDict, taggers);
			}
			return;

		case 3:
			_Platform_gatherEffects(isCmd, bag.o, effectsDict, {
				s: bag.n,
				t: taggers
			});
			return;
	}
}


function _Platform_toEffect(isCmd, home, taggers, value)
{
	function applyTaggers(x)
	{
		for (var temp = taggers; temp; temp = temp.t)
		{
			x = temp.s(x);
		}
		return x;
	}

	var map = isCmd
		? _Platform_effectManagers[home].e
		: _Platform_effectManagers[home].f;

	return A2(map, applyTaggers, value)
}


function _Platform_insert(isCmd, newEffect, effects)
{
	effects = effects || { i: _List_Nil, j: _List_Nil };

	isCmd
		? (effects.i = _List_Cons(newEffect, effects.i))
		: (effects.j = _List_Cons(newEffect, effects.j));

	return effects;
}



// PORTS


function _Platform_checkPortName(name)
{
	if (_Platform_effectManagers[name])
	{
		_Debug_crash(3, name)
	}
}



// OUTGOING PORTS


function _Platform_outgoingPort(name, converter)
{
	_Platform_checkPortName(name);
	_Platform_effectManagers[name] = {
		e: _Platform_outgoingPortMap,
		u: converter,
		a: _Platform_setupOutgoingPort
	};
	return _Platform_leaf(name);
}


var _Platform_outgoingPortMap = F2(function(tagger, value) { return value; });


function _Platform_setupOutgoingPort(name)
{
	var subs = [];
	var converter = _Platform_effectManagers[name].u;

	// CREATE MANAGER

	var init = _Process_sleep(0);

	_Platform_effectManagers[name].b = init;
	_Platform_effectManagers[name].c = F3(function(router, cmdList, state)
	{
		for ( ; cmdList.b; cmdList = cmdList.b) // WHILE_CONS
		{
			// grab a separate reference to subs in case unsubscribe is called
			var currentSubs = subs;
			var value = _Json_unwrap(converter(cmdList.a));
			for (var i = 0; i < currentSubs.length; i++)
			{
				currentSubs[i](value);
			}
		}
		return init;
	});

	// PUBLIC API

	function subscribe(callback)
	{
		subs.push(callback);
	}

	function unsubscribe(callback)
	{
		// copy subs into a new array in case unsubscribe is called within a
		// subscribed callback
		subs = subs.slice();
		var index = subs.indexOf(callback);
		if (index >= 0)
		{
			subs.splice(index, 1);
		}
	}

	return {
		subscribe: subscribe,
		unsubscribe: unsubscribe
	};
}



// INCOMING PORTS


function _Platform_incomingPort(name, converter)
{
	_Platform_checkPortName(name);
	_Platform_effectManagers[name] = {
		f: _Platform_incomingPortMap,
		u: converter,
		a: _Platform_setupIncomingPort
	};
	return _Platform_leaf(name);
}


var _Platform_incomingPortMap = F2(function(tagger, finalTagger)
{
	return function(value)
	{
		return tagger(finalTagger(value));
	};
});


function _Platform_setupIncomingPort(name, sendToApp)
{
	var subs = _List_Nil;
	var converter = _Platform_effectManagers[name].u;

	// CREATE MANAGER

	var init = _Scheduler_succeed(null);

	_Platform_effectManagers[name].b = init;
	_Platform_effectManagers[name].c = F3(function(router, subList, state)
	{
		subs = subList;
		return init;
	});

	// PUBLIC API

	function send(incomingValue)
	{
		var result = A2(_Json_run, converter, _Json_wrap(incomingValue));

		$elm$core$Result$isOk(result) || _Debug_crash(4, name, result.a);

		var value = result.a;
		for (var temp = subs; temp.b; temp = temp.b) // WHILE_CONS
		{
			sendToApp(temp.a(value));
		}
	}

	return { send: send };
}



// EXPORT ELM MODULES
//
// Have DEBUG and PROD versions so that we can (1) give nicer errors in
// debug mode and (2) not pay for the bits needed for that in prod mode.
//


function _Platform_export_UNUSED(exports)
{
	scope['Elm']
		? _Platform_mergeExportsProd(scope['Elm'], exports)
		: scope['Elm'] = exports;
}


function _Platform_mergeExportsProd(obj, exports)
{
	for (var name in exports)
	{
		(name in obj)
			? (name == 'init')
				? _Debug_crash(6)
				: _Platform_mergeExportsProd(obj[name], exports[name])
			: (obj[name] = exports[name]);
	}
}


function _Platform_export(exports)
{
	scope['Elm']
		? _Platform_mergeExportsDebug('Elm', scope['Elm'], exports)
		: scope['Elm'] = exports;
}


function _Platform_mergeExportsDebug(moduleName, obj, exports)
{
	for (var name in exports)
	{
		(name in obj)
			? (name == 'init')
				? _Debug_crash(6, moduleName)
				: _Platform_mergeExportsDebug(moduleName + '.' + name, obj[name], exports[name])
			: (obj[name] = exports[name]);
	}
}




// HELPERS


var _VirtualDom_divertHrefToApp;

var _VirtualDom_doc = typeof document !== 'undefined' ? document : {};


function _VirtualDom_appendChild(parent, child)
{
	parent.appendChild(child);
}

var _VirtualDom_init = F4(function(virtualNode, flagDecoder, debugMetadata, args)
{
	// NOTE: this function needs _Platform_export available to work

	/**_UNUSED/
	var node = args['node'];
	//*/
	/**/
	var node = args && args['node'] ? args['node'] : _Debug_crash(0);
	//*/

	node.parentNode.replaceChild(
		_VirtualDom_render(virtualNode, function() {}),
		node
	);

	return {};
});



// TEXT


function _VirtualDom_text(string)
{
	return {
		$: 0,
		a: string
	};
}



// NODE


var _VirtualDom_nodeNS = F2(function(namespace, tag)
{
	return F2(function(factList, kidList)
	{
		for (var kids = [], descendantsCount = 0; kidList.b; kidList = kidList.b) // WHILE_CONS
		{
			var kid = kidList.a;
			descendantsCount += (kid.b || 0);
			kids.push(kid);
		}
		descendantsCount += kids.length;

		return {
			$: 1,
			c: tag,
			d: _VirtualDom_organizeFacts(factList),
			e: kids,
			f: namespace,
			b: descendantsCount
		};
	});
});


var _VirtualDom_node = _VirtualDom_nodeNS(undefined);



// KEYED NODE


var _VirtualDom_keyedNodeNS = F2(function(namespace, tag)
{
	return F2(function(factList, kidList)
	{
		for (var kids = [], descendantsCount = 0; kidList.b; kidList = kidList.b) // WHILE_CONS
		{
			var kid = kidList.a;
			descendantsCount += (kid.b.b || 0);
			kids.push(kid);
		}
		descendantsCount += kids.length;

		return {
			$: 2,
			c: tag,
			d: _VirtualDom_organizeFacts(factList),
			e: kids,
			f: namespace,
			b: descendantsCount
		};
	});
});


var _VirtualDom_keyedNode = _VirtualDom_keyedNodeNS(undefined);



// CUSTOM


function _VirtualDom_custom(factList, model, render, diff)
{
	return {
		$: 3,
		d: _VirtualDom_organizeFacts(factList),
		g: model,
		h: render,
		i: diff
	};
}



// MAP


var _VirtualDom_map = F2(function(tagger, node)
{
	return {
		$: 4,
		j: tagger,
		k: node,
		b: 1 + (node.b || 0)
	};
});



// LAZY


function _VirtualDom_thunk(refs, thunk)
{
	return {
		$: 5,
		l: refs,
		m: thunk,
		k: undefined
	};
}

var _VirtualDom_lazy = F2(function(func, a)
{
	return _VirtualDom_thunk([func, a], function() {
		return func(a);
	});
});

var _VirtualDom_lazy2 = F3(function(func, a, b)
{
	return _VirtualDom_thunk([func, a, b], function() {
		return A2(func, a, b);
	});
});

var _VirtualDom_lazy3 = F4(function(func, a, b, c)
{
	return _VirtualDom_thunk([func, a, b, c], function() {
		return A3(func, a, b, c);
	});
});

var _VirtualDom_lazy4 = F5(function(func, a, b, c, d)
{
	return _VirtualDom_thunk([func, a, b, c, d], function() {
		return A4(func, a, b, c, d);
	});
});

var _VirtualDom_lazy5 = F6(function(func, a, b, c, d, e)
{
	return _VirtualDom_thunk([func, a, b, c, d, e], function() {
		return A5(func, a, b, c, d, e);
	});
});

var _VirtualDom_lazy6 = F7(function(func, a, b, c, d, e, f)
{
	return _VirtualDom_thunk([func, a, b, c, d, e, f], function() {
		return A6(func, a, b, c, d, e, f);
	});
});

var _VirtualDom_lazy7 = F8(function(func, a, b, c, d, e, f, g)
{
	return _VirtualDom_thunk([func, a, b, c, d, e, f, g], function() {
		return A7(func, a, b, c, d, e, f, g);
	});
});

var _VirtualDom_lazy8 = F9(function(func, a, b, c, d, e, f, g, h)
{
	return _VirtualDom_thunk([func, a, b, c, d, e, f, g, h], function() {
		return A8(func, a, b, c, d, e, f, g, h);
	});
});



// FACTS


var _VirtualDom_on = F2(function(key, handler)
{
	return {
		$: 'a0',
		n: key,
		o: handler
	};
});
var _VirtualDom_style = F2(function(key, value)
{
	return {
		$: 'a1',
		n: key,
		o: value
	};
});
var _VirtualDom_property = F2(function(key, value)
{
	return {
		$: 'a2',
		n: key,
		o: value
	};
});
var _VirtualDom_attribute = F2(function(key, value)
{
	return {
		$: 'a3',
		n: key,
		o: value
	};
});
var _VirtualDom_attributeNS = F3(function(namespace, key, value)
{
	return {
		$: 'a4',
		n: key,
		o: { f: namespace, o: value }
	};
});



// XSS ATTACK VECTOR CHECKS


function _VirtualDom_noScript(tag)
{
	return tag == 'script' ? 'p' : tag;
}

function _VirtualDom_noOnOrFormAction(key)
{
	return /^(on|formAction$)/i.test(key) ? 'data-' + key : key;
}

function _VirtualDom_noInnerHtmlOrFormAction(key)
{
	return key == 'innerHTML' || key == 'formAction' ? 'data-' + key : key;
}

function _VirtualDom_noJavaScriptUri_UNUSED(value)
{
	return /^javascript:/i.test(value.replace(/\s/g,'')) ? '' : value;
}

function _VirtualDom_noJavaScriptUri(value)
{
	return /^javascript:/i.test(value.replace(/\s/g,''))
		? 'javascript:alert("This is an XSS vector. Please use ports or web components instead.")'
		: value;
}

function _VirtualDom_noJavaScriptOrHtmlUri_UNUSED(value)
{
	return /^\s*(javascript:|data:text\/html)/i.test(value) ? '' : value;
}

function _VirtualDom_noJavaScriptOrHtmlUri(value)
{
	return /^\s*(javascript:|data:text\/html)/i.test(value)
		? 'javascript:alert("This is an XSS vector. Please use ports or web components instead.")'
		: value;
}



// MAP FACTS


var _VirtualDom_mapAttribute = F2(function(func, attr)
{
	return (attr.$ === 'a0')
		? A2(_VirtualDom_on, attr.n, _VirtualDom_mapHandler(func, attr.o))
		: attr;
});

function _VirtualDom_mapHandler(func, handler)
{
	var tag = $elm$virtual_dom$VirtualDom$toHandlerInt(handler);

	// 0 = Normal
	// 1 = MayStopPropagation
	// 2 = MayPreventDefault
	// 3 = Custom

	return {
		$: handler.$,
		a:
			!tag
				? A2($elm$json$Json$Decode$map, func, handler.a)
				:
			A3($elm$json$Json$Decode$map2,
				tag < 3
					? _VirtualDom_mapEventTuple
					: _VirtualDom_mapEventRecord,
				$elm$json$Json$Decode$succeed(func),
				handler.a
			)
	};
}

var _VirtualDom_mapEventTuple = F2(function(func, tuple)
{
	return _Utils_Tuple2(func(tuple.a), tuple.b);
});

var _VirtualDom_mapEventRecord = F2(function(func, record)
{
	return {
		message: func(record.message),
		stopPropagation: record.stopPropagation,
		preventDefault: record.preventDefault
	}
});



// ORGANIZE FACTS


function _VirtualDom_organizeFacts(factList)
{
	for (var facts = {}; factList.b; factList = factList.b) // WHILE_CONS
	{
		var entry = factList.a;

		var tag = entry.$;
		var key = entry.n;
		var value = entry.o;

		if (tag === 'a2')
		{
			(key === 'className')
				? _VirtualDom_addClass(facts, key, _Json_unwrap(value))
				: facts[key] = _Json_unwrap(value);

			continue;
		}

		var subFacts = facts[tag] || (facts[tag] = {});
		(tag === 'a3' && key === 'class')
			? _VirtualDom_addClass(subFacts, key, value)
			: subFacts[key] = value;
	}

	return facts;
}

function _VirtualDom_addClass(object, key, newClass)
{
	var classes = object[key];
	object[key] = classes ? classes + ' ' + newClass : newClass;
}



// RENDER


function _VirtualDom_render(vNode, eventNode)
{
	var tag = vNode.$;

	if (tag === 5)
	{
		return _VirtualDom_render(vNode.k || (vNode.k = vNode.m()), eventNode);
	}

	if (tag === 0)
	{
		return _VirtualDom_doc.createTextNode(vNode.a);
	}

	if (tag === 4)
	{
		var subNode = vNode.k;
		var tagger = vNode.j;

		while (subNode.$ === 4)
		{
			typeof tagger !== 'object'
				? tagger = [tagger, subNode.j]
				: tagger.push(subNode.j);

			subNode = subNode.k;
		}

		var subEventRoot = { j: tagger, p: eventNode };
		var domNode = _VirtualDom_render(subNode, subEventRoot);
		domNode.elm_event_node_ref = subEventRoot;
		return domNode;
	}

	if (tag === 3)
	{
		var domNode = vNode.h(vNode.g);
		_VirtualDom_applyFacts(domNode, eventNode, vNode.d);
		return domNode;
	}

	// at this point `tag` must be 1 or 2

	var domNode = vNode.f
		? _VirtualDom_doc.createElementNS(vNode.f, vNode.c)
		: _VirtualDom_doc.createElement(vNode.c);

	if (_VirtualDom_divertHrefToApp && vNode.c == 'a')
	{
		domNode.addEventListener('click', _VirtualDom_divertHrefToApp(domNode));
	}

	_VirtualDom_applyFacts(domNode, eventNode, vNode.d);

	for (var kids = vNode.e, i = 0; i < kids.length; i++)
	{
		_VirtualDom_appendChild(domNode, _VirtualDom_render(tag === 1 ? kids[i] : kids[i].b, eventNode));
	}

	return domNode;
}



// APPLY FACTS


function _VirtualDom_applyFacts(domNode, eventNode, facts)
{
	for (var key in facts)
	{
		var value = facts[key];

		key === 'a1'
			? _VirtualDom_applyStyles(domNode, value)
			:
		key === 'a0'
			? _VirtualDom_applyEvents(domNode, eventNode, value)
			:
		key === 'a3'
			? _VirtualDom_applyAttrs(domNode, value)
			:
		key === 'a4'
			? _VirtualDom_applyAttrsNS(domNode, value)
			:
		((key !== 'value' && key !== 'checked') || domNode[key] !== value) && (domNode[key] = value);
	}
}



// APPLY STYLES


function _VirtualDom_applyStyles(domNode, styles)
{
	var domNodeStyle = domNode.style;

	for (var key in styles)
	{
		domNodeStyle[key] = styles[key];
	}
}



// APPLY ATTRS


function _VirtualDom_applyAttrs(domNode, attrs)
{
	for (var key in attrs)
	{
		var value = attrs[key];
		typeof value !== 'undefined'
			? domNode.setAttribute(key, value)
			: domNode.removeAttribute(key);
	}
}



// APPLY NAMESPACED ATTRS


function _VirtualDom_applyAttrsNS(domNode, nsAttrs)
{
	for (var key in nsAttrs)
	{
		var pair = nsAttrs[key];
		var namespace = pair.f;
		var value = pair.o;

		typeof value !== 'undefined'
			? domNode.setAttributeNS(namespace, key, value)
			: domNode.removeAttributeNS(namespace, key);
	}
}



// APPLY EVENTS


function _VirtualDom_applyEvents(domNode, eventNode, events)
{
	var allCallbacks = domNode.elmFs || (domNode.elmFs = {});

	for (var key in events)
	{
		var newHandler = events[key];
		var oldCallback = allCallbacks[key];

		if (!newHandler)
		{
			domNode.removeEventListener(key, oldCallback);
			allCallbacks[key] = undefined;
			continue;
		}

		if (oldCallback)
		{
			var oldHandler = oldCallback.q;
			if (oldHandler.$ === newHandler.$)
			{
				oldCallback.q = newHandler;
				continue;
			}
			domNode.removeEventListener(key, oldCallback);
		}

		oldCallback = _VirtualDom_makeCallback(eventNode, newHandler);
		domNode.addEventListener(key, oldCallback,
			_VirtualDom_passiveSupported
			&& { passive: $elm$virtual_dom$VirtualDom$toHandlerInt(newHandler) < 2 }
		);
		allCallbacks[key] = oldCallback;
	}
}



// PASSIVE EVENTS


var _VirtualDom_passiveSupported;

try
{
	window.addEventListener('t', null, Object.defineProperty({}, 'passive', {
		get: function() { _VirtualDom_passiveSupported = true; }
	}));
}
catch(e) {}



// EVENT HANDLERS


function _VirtualDom_makeCallback(eventNode, initialHandler)
{
	function callback(event)
	{
		var handler = callback.q;
		var result = _Json_runHelp(handler.a, event);

		if (!$elm$core$Result$isOk(result))
		{
			return;
		}

		var tag = $elm$virtual_dom$VirtualDom$toHandlerInt(handler);

		// 0 = Normal
		// 1 = MayStopPropagation
		// 2 = MayPreventDefault
		// 3 = Custom

		var value = result.a;
		var message = !tag ? value : tag < 3 ? value.a : value.message;
		var stopPropagation = tag == 1 ? value.b : tag == 3 && value.stopPropagation;
		var currentEventNode = (
			stopPropagation && event.stopPropagation(),
			(tag == 2 ? value.b : tag == 3 && value.preventDefault) && event.preventDefault(),
			eventNode
		);
		var tagger;
		var i;
		while (tagger = currentEventNode.j)
		{
			if (typeof tagger == 'function')
			{
				message = tagger(message);
			}
			else
			{
				for (var i = tagger.length; i--; )
				{
					message = tagger[i](message);
				}
			}
			currentEventNode = currentEventNode.p;
		}
		currentEventNode(message, stopPropagation); // stopPropagation implies isSync
	}

	callback.q = initialHandler;

	return callback;
}

function _VirtualDom_equalEvents(x, y)
{
	return x.$ == y.$ && _Json_equality(x.a, y.a);
}



// DIFF


// TODO: Should we do patches like in iOS?
//
// type Patch
//   = At Int Patch
//   | Batch (List Patch)
//   | Change ...
//
// How could it not be better?
//
function _VirtualDom_diff(x, y)
{
	var patches = [];
	_VirtualDom_diffHelp(x, y, patches, 0);
	return patches;
}


function _VirtualDom_pushPatch(patches, type, index, data)
{
	var patch = {
		$: type,
		r: index,
		s: data,
		t: undefined,
		u: undefined
	};
	patches.push(patch);
	return patch;
}


function _VirtualDom_diffHelp(x, y, patches, index)
{
	if (x === y)
	{
		return;
	}

	var xType = x.$;
	var yType = y.$;

	// Bail if you run into different types of nodes. Implies that the
	// structure has changed significantly and it's not worth a diff.
	if (xType !== yType)
	{
		if (xType === 1 && yType === 2)
		{
			y = _VirtualDom_dekey(y);
			yType = 1;
		}
		else
		{
			_VirtualDom_pushPatch(patches, 0, index, y);
			return;
		}
	}

	// Now we know that both nodes are the same $.
	switch (yType)
	{
		case 5:
			var xRefs = x.l;
			var yRefs = y.l;
			var i = xRefs.length;
			var same = i === yRefs.length;
			while (same && i--)
			{
				same = xRefs[i] === yRefs[i];
			}
			if (same)
			{
				y.k = x.k;
				return;
			}
			y.k = y.m();
			var subPatches = [];
			_VirtualDom_diffHelp(x.k, y.k, subPatches, 0);
			subPatches.length > 0 && _VirtualDom_pushPatch(patches, 1, index, subPatches);
			return;

		case 4:
			// gather nested taggers
			var xTaggers = x.j;
			var yTaggers = y.j;
			var nesting = false;

			var xSubNode = x.k;
			while (xSubNode.$ === 4)
			{
				nesting = true;

				typeof xTaggers !== 'object'
					? xTaggers = [xTaggers, xSubNode.j]
					: xTaggers.push(xSubNode.j);

				xSubNode = xSubNode.k;
			}

			var ySubNode = y.k;
			while (ySubNode.$ === 4)
			{
				nesting = true;

				typeof yTaggers !== 'object'
					? yTaggers = [yTaggers, ySubNode.j]
					: yTaggers.push(ySubNode.j);

				ySubNode = ySubNode.k;
			}

			// Just bail if different numbers of taggers. This implies the
			// structure of the virtual DOM has changed.
			if (nesting && xTaggers.length !== yTaggers.length)
			{
				_VirtualDom_pushPatch(patches, 0, index, y);
				return;
			}

			// check if taggers are "the same"
			if (nesting ? !_VirtualDom_pairwiseRefEqual(xTaggers, yTaggers) : xTaggers !== yTaggers)
			{
				_VirtualDom_pushPatch(patches, 2, index, yTaggers);
			}

			// diff everything below the taggers
			_VirtualDom_diffHelp(xSubNode, ySubNode, patches, index + 1);
			return;

		case 0:
			if (x.a !== y.a)
			{
				_VirtualDom_pushPatch(patches, 3, index, y.a);
			}
			return;

		case 1:
			_VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKids);
			return;

		case 2:
			_VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKeyedKids);
			return;

		case 3:
			if (x.h !== y.h)
			{
				_VirtualDom_pushPatch(patches, 0, index, y);
				return;
			}

			var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
			factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);

			var patch = y.i(x.g, y.g);
			patch && _VirtualDom_pushPatch(patches, 5, index, patch);

			return;
	}
}

// assumes the incoming arrays are the same length
function _VirtualDom_pairwiseRefEqual(as, bs)
{
	for (var i = 0; i < as.length; i++)
	{
		if (as[i] !== bs[i])
		{
			return false;
		}
	}

	return true;
}

function _VirtualDom_diffNodes(x, y, patches, index, diffKids)
{
	// Bail if obvious indicators have changed. Implies more serious
	// structural changes such that it's not worth it to diff.
	if (x.c !== y.c || x.f !== y.f)
	{
		_VirtualDom_pushPatch(patches, 0, index, y);
		return;
	}

	var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
	factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);

	diffKids(x, y, patches, index);
}



// DIFF FACTS


// TODO Instead of creating a new diff object, it's possible to just test if
// there *is* a diff. During the actual patch, do the diff again and make the
// modifications directly. This way, there's no new allocations. Worth it?
function _VirtualDom_diffFacts(x, y, category)
{
	var diff;

	// look for changes and removals
	for (var xKey in x)
	{
		if (xKey === 'a1' || xKey === 'a0' || xKey === 'a3' || xKey === 'a4')
		{
			var subDiff = _VirtualDom_diffFacts(x[xKey], y[xKey] || {}, xKey);
			if (subDiff)
			{
				diff = diff || {};
				diff[xKey] = subDiff;
			}
			continue;
		}

		// remove if not in the new facts
		if (!(xKey in y))
		{
			diff = diff || {};
			diff[xKey] =
				!category
					? (typeof x[xKey] === 'string' ? '' : null)
					:
				(category === 'a1')
					? ''
					:
				(category === 'a0' || category === 'a3')
					? undefined
					:
				{ f: x[xKey].f, o: undefined };

			continue;
		}

		var xValue = x[xKey];
		var yValue = y[xKey];

		// reference equal, so don't worry about it
		if (xValue === yValue && xKey !== 'value' && xKey !== 'checked'
			|| category === 'a0' && _VirtualDom_equalEvents(xValue, yValue))
		{
			continue;
		}

		diff = diff || {};
		diff[xKey] = yValue;
	}

	// add new stuff
	for (var yKey in y)
	{
		if (!(yKey in x))
		{
			diff = diff || {};
			diff[yKey] = y[yKey];
		}
	}

	return diff;
}



// DIFF KIDS


function _VirtualDom_diffKids(xParent, yParent, patches, index)
{
	var xKids = xParent.e;
	var yKids = yParent.e;

	var xLen = xKids.length;
	var yLen = yKids.length;

	// FIGURE OUT IF THERE ARE INSERTS OR REMOVALS

	if (xLen > yLen)
	{
		_VirtualDom_pushPatch(patches, 6, index, {
			v: yLen,
			i: xLen - yLen
		});
	}
	else if (xLen < yLen)
	{
		_VirtualDom_pushPatch(patches, 7, index, {
			v: xLen,
			e: yKids
		});
	}

	// PAIRWISE DIFF EVERYTHING ELSE

	for (var minLen = xLen < yLen ? xLen : yLen, i = 0; i < minLen; i++)
	{
		var xKid = xKids[i];
		_VirtualDom_diffHelp(xKid, yKids[i], patches, ++index);
		index += xKid.b || 0;
	}
}



// KEYED DIFF


function _VirtualDom_diffKeyedKids(xParent, yParent, patches, rootIndex)
{
	var localPatches = [];

	var changes = {}; // Dict String Entry
	var inserts = []; // Array { index : Int, entry : Entry }
	// type Entry = { tag : String, vnode : VNode, index : Int, data : _ }

	var xKids = xParent.e;
	var yKids = yParent.e;
	var xLen = xKids.length;
	var yLen = yKids.length;
	var xIndex = 0;
	var yIndex = 0;

	var index = rootIndex;

	while (xIndex < xLen && yIndex < yLen)
	{
		var x = xKids[xIndex];
		var y = yKids[yIndex];

		var xKey = x.a;
		var yKey = y.a;
		var xNode = x.b;
		var yNode = y.b;

		var newMatch = undefined;
		var oldMatch = undefined;

		// check if keys match

		if (xKey === yKey)
		{
			index++;
			_VirtualDom_diffHelp(xNode, yNode, localPatches, index);
			index += xNode.b || 0;

			xIndex++;
			yIndex++;
			continue;
		}

		// look ahead 1 to detect insertions and removals.

		var xNext = xKids[xIndex + 1];
		var yNext = yKids[yIndex + 1];

		if (xNext)
		{
			var xNextKey = xNext.a;
			var xNextNode = xNext.b;
			oldMatch = yKey === xNextKey;
		}

		if (yNext)
		{
			var yNextKey = yNext.a;
			var yNextNode = yNext.b;
			newMatch = xKey === yNextKey;
		}


		// swap x and y
		if (newMatch && oldMatch)
		{
			index++;
			_VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
			_VirtualDom_insertNode(changes, localPatches, xKey, yNode, yIndex, inserts);
			index += xNode.b || 0;

			index++;
			_VirtualDom_removeNode(changes, localPatches, xKey, xNextNode, index);
			index += xNextNode.b || 0;

			xIndex += 2;
			yIndex += 2;
			continue;
		}

		// insert y
		if (newMatch)
		{
			index++;
			_VirtualDom_insertNode(changes, localPatches, yKey, yNode, yIndex, inserts);
			_VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
			index += xNode.b || 0;

			xIndex += 1;
			yIndex += 2;
			continue;
		}

		// remove x
		if (oldMatch)
		{
			index++;
			_VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
			index += xNode.b || 0;

			index++;
			_VirtualDom_diffHelp(xNextNode, yNode, localPatches, index);
			index += xNextNode.b || 0;

			xIndex += 2;
			yIndex += 1;
			continue;
		}

		// remove x, insert y
		if (xNext && xNextKey === yNextKey)
		{
			index++;
			_VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
			_VirtualDom_insertNode(changes, localPatches, yKey, yNode, yIndex, inserts);
			index += xNode.b || 0;

			index++;
			_VirtualDom_diffHelp(xNextNode, yNextNode, localPatches, index);
			index += xNextNode.b || 0;

			xIndex += 2;
			yIndex += 2;
			continue;
		}

		break;
	}

	// eat up any remaining nodes with removeNode and insertNode

	while (xIndex < xLen)
	{
		index++;
		var x = xKids[xIndex];
		var xNode = x.b;
		_VirtualDom_removeNode(changes, localPatches, x.a, xNode, index);
		index += xNode.b || 0;
		xIndex++;
	}

	while (yIndex < yLen)
	{
		var endInserts = endInserts || [];
		var y = yKids[yIndex];
		_VirtualDom_insertNode(changes, localPatches, y.a, y.b, undefined, endInserts);
		yIndex++;
	}

	if (localPatches.length > 0 || inserts.length > 0 || endInserts)
	{
		_VirtualDom_pushPatch(patches, 8, rootIndex, {
			w: localPatches,
			x: inserts,
			y: endInserts
		});
	}
}



// CHANGES FROM KEYED DIFF


var _VirtualDom_POSTFIX = '_elmW6BL';


function _VirtualDom_insertNode(changes, localPatches, key, vnode, yIndex, inserts)
{
	var entry = changes[key];

	// never seen this key before
	if (!entry)
	{
		entry = {
			c: 0,
			z: vnode,
			r: yIndex,
			s: undefined
		};

		inserts.push({ r: yIndex, A: entry });
		changes[key] = entry;

		return;
	}

	// this key was removed earlier, a match!
	if (entry.c === 1)
	{
		inserts.push({ r: yIndex, A: entry });

		entry.c = 2;
		var subPatches = [];
		_VirtualDom_diffHelp(entry.z, vnode, subPatches, entry.r);
		entry.r = yIndex;
		entry.s.s = {
			w: subPatches,
			A: entry
		};

		return;
	}

	// this key has already been inserted or moved, a duplicate!
	_VirtualDom_insertNode(changes, localPatches, key + _VirtualDom_POSTFIX, vnode, yIndex, inserts);
}


function _VirtualDom_removeNode(changes, localPatches, key, vnode, index)
{
	var entry = changes[key];

	// never seen this key before
	if (!entry)
	{
		var patch = _VirtualDom_pushPatch(localPatches, 9, index, undefined);

		changes[key] = {
			c: 1,
			z: vnode,
			r: index,
			s: patch
		};

		return;
	}

	// this key was inserted earlier, a match!
	if (entry.c === 0)
	{
		entry.c = 2;
		var subPatches = [];
		_VirtualDom_diffHelp(vnode, entry.z, subPatches, index);

		_VirtualDom_pushPatch(localPatches, 9, index, {
			w: subPatches,
			A: entry
		});

		return;
	}

	// this key has already been removed or moved, a duplicate!
	_VirtualDom_removeNode(changes, localPatches, key + _VirtualDom_POSTFIX, vnode, index);
}



// ADD DOM NODES
//
// Each DOM node has an "index" assigned in order of traversal. It is important
// to minimize our crawl over the actual DOM, so these indexes (along with the
// descendantsCount of virtual nodes) let us skip touching entire subtrees of
// the DOM if we know there are no patches there.


function _VirtualDom_addDomNodes(domNode, vNode, patches, eventNode)
{
	_VirtualDom_addDomNodesHelp(domNode, vNode, patches, 0, 0, vNode.b, eventNode);
}


// assumes `patches` is non-empty and indexes increase monotonically.
function _VirtualDom_addDomNodesHelp(domNode, vNode, patches, i, low, high, eventNode)
{
	var patch = patches[i];
	var index = patch.r;

	while (index === low)
	{
		var patchType = patch.$;

		if (patchType === 1)
		{
			_VirtualDom_addDomNodes(domNode, vNode.k, patch.s, eventNode);
		}
		else if (patchType === 8)
		{
			patch.t = domNode;
			patch.u = eventNode;

			var subPatches = patch.s.w;
			if (subPatches.length > 0)
			{
				_VirtualDom_addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
			}
		}
		else if (patchType === 9)
		{
			patch.t = domNode;
			patch.u = eventNode;

			var data = patch.s;
			if (data)
			{
				data.A.s = domNode;
				var subPatches = data.w;
				if (subPatches.length > 0)
				{
					_VirtualDom_addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
				}
			}
		}
		else
		{
			patch.t = domNode;
			patch.u = eventNode;
		}

		i++;

		if (!(patch = patches[i]) || (index = patch.r) > high)
		{
			return i;
		}
	}

	var tag = vNode.$;

	if (tag === 4)
	{
		var subNode = vNode.k;

		while (subNode.$ === 4)
		{
			subNode = subNode.k;
		}

		return _VirtualDom_addDomNodesHelp(domNode, subNode, patches, i, low + 1, high, domNode.elm_event_node_ref);
	}

	// tag must be 1 or 2 at this point

	var vKids = vNode.e;
	var childNodes = domNode.childNodes;
	for (var j = 0; j < vKids.length; j++)
	{
		low++;
		var vKid = tag === 1 ? vKids[j] : vKids[j].b;
		var nextLow = low + (vKid.b || 0);
		if (low <= index && index <= nextLow)
		{
			i = _VirtualDom_addDomNodesHelp(childNodes[j], vKid, patches, i, low, nextLow, eventNode);
			if (!(patch = patches[i]) || (index = patch.r) > high)
			{
				return i;
			}
		}
		low = nextLow;
	}
	return i;
}



// APPLY PATCHES


function _VirtualDom_applyPatches(rootDomNode, oldVirtualNode, patches, eventNode)
{
	if (patches.length === 0)
	{
		return rootDomNode;
	}

	_VirtualDom_addDomNodes(rootDomNode, oldVirtualNode, patches, eventNode);
	return _VirtualDom_applyPatchesHelp(rootDomNode, patches);
}

function _VirtualDom_applyPatchesHelp(rootDomNode, patches)
{
	for (var i = 0; i < patches.length; i++)
	{
		var patch = patches[i];
		var localDomNode = patch.t
		var newNode = _VirtualDom_applyPatch(localDomNode, patch);
		if (localDomNode === rootDomNode)
		{
			rootDomNode = newNode;
		}
	}
	return rootDomNode;
}

function _VirtualDom_applyPatch(domNode, patch)
{
	switch (patch.$)
	{
		case 0:
			return _VirtualDom_applyPatchRedraw(domNode, patch.s, patch.u);

		case 4:
			_VirtualDom_applyFacts(domNode, patch.u, patch.s);
			return domNode;

		case 3:
			domNode.replaceData(0, domNode.length, patch.s);
			return domNode;

		case 1:
			return _VirtualDom_applyPatchesHelp(domNode, patch.s);

		case 2:
			if (domNode.elm_event_node_ref)
			{
				domNode.elm_event_node_ref.j = patch.s;
			}
			else
			{
				domNode.elm_event_node_ref = { j: patch.s, p: patch.u };
			}
			return domNode;

		case 6:
			var data = patch.s;
			for (var i = 0; i < data.i; i++)
			{
				domNode.removeChild(domNode.childNodes[data.v]);
			}
			return domNode;

		case 7:
			var data = patch.s;
			var kids = data.e;
			var i = data.v;
			var theEnd = domNode.childNodes[i];
			for (; i < kids.length; i++)
			{
				domNode.insertBefore(_VirtualDom_render(kids[i], patch.u), theEnd);
			}
			return domNode;

		case 9:
			var data = patch.s;
			if (!data)
			{
				domNode.parentNode.removeChild(domNode);
				return domNode;
			}
			var entry = data.A;
			if (typeof entry.r !== 'undefined')
			{
				domNode.parentNode.removeChild(domNode);
			}
			entry.s = _VirtualDom_applyPatchesHelp(domNode, data.w);
			return domNode;

		case 8:
			return _VirtualDom_applyPatchReorder(domNode, patch);

		case 5:
			return patch.s(domNode);

		default:
			_Debug_crash(10); // 'Ran into an unknown patch!'
	}
}


function _VirtualDom_applyPatchRedraw(domNode, vNode, eventNode)
{
	var parentNode = domNode.parentNode;
	var newNode = _VirtualDom_render(vNode, eventNode);

	if (!newNode.elm_event_node_ref)
	{
		newNode.elm_event_node_ref = domNode.elm_event_node_ref;
	}

	if (parentNode && newNode !== domNode)
	{
		parentNode.replaceChild(newNode, domNode);
	}
	return newNode;
}


function _VirtualDom_applyPatchReorder(domNode, patch)
{
	var data = patch.s;

	// remove end inserts
	var frag = _VirtualDom_applyPatchReorderEndInsertsHelp(data.y, patch);

	// removals
	domNode = _VirtualDom_applyPatchesHelp(domNode, data.w);

	// inserts
	var inserts = data.x;
	for (var i = 0; i < inserts.length; i++)
	{
		var insert = inserts[i];
		var entry = insert.A;
		var node = entry.c === 2
			? entry.s
			: _VirtualDom_render(entry.z, patch.u);
		domNode.insertBefore(node, domNode.childNodes[insert.r]);
	}

	// add end inserts
	if (frag)
	{
		_VirtualDom_appendChild(domNode, frag);
	}

	return domNode;
}


function _VirtualDom_applyPatchReorderEndInsertsHelp(endInserts, patch)
{
	if (!endInserts)
	{
		return;
	}

	var frag = _VirtualDom_doc.createDocumentFragment();
	for (var i = 0; i < endInserts.length; i++)
	{
		var insert = endInserts[i];
		var entry = insert.A;
		_VirtualDom_appendChild(frag, entry.c === 2
			? entry.s
			: _VirtualDom_render(entry.z, patch.u)
		);
	}
	return frag;
}


function _VirtualDom_virtualize(node)
{
	// TEXT NODES

	if (node.nodeType === 3)
	{
		return _VirtualDom_text(node.textContent);
	}


	// WEIRD NODES

	if (node.nodeType !== 1)
	{
		return _VirtualDom_text('');
	}


	// ELEMENT NODES

	var attrList = _List_Nil;
	var attrs = node.attributes;
	for (var i = attrs.length; i--; )
	{
		var attr = attrs[i];
		var name = attr.name;
		var value = attr.value;
		attrList = _List_Cons( A2(_VirtualDom_attribute, name, value), attrList );
	}

	var tag = node.tagName.toLowerCase();
	var kidList = _List_Nil;
	var kids = node.childNodes;

	for (var i = kids.length; i--; )
	{
		kidList = _List_Cons(_VirtualDom_virtualize(kids[i]), kidList);
	}
	return A3(_VirtualDom_node, tag, attrList, kidList);
}

function _VirtualDom_dekey(keyedNode)
{
	var keyedKids = keyedNode.e;
	var len = keyedKids.length;
	var kids = new Array(len);
	for (var i = 0; i < len; i++)
	{
		kids[i] = keyedKids[i].b;
	}

	return {
		$: 1,
		c: keyedNode.c,
		d: keyedNode.d,
		e: kids,
		f: keyedNode.f,
		b: keyedNode.b
	};
}




// ELEMENT


var _Debugger_element;

var _Browser_element = _Debugger_element || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		flagDecoder,
		args,
		impl.init,
		impl.update,
		impl.subscriptions,
		function(sendToApp, initialModel) {
			var view = impl.view;
			/**_UNUSED/
			var domNode = args['node'];
			//*/
			/**/
			var domNode = args && args['node'] ? args['node'] : _Debug_crash(0);
			//*/
			var currNode = _VirtualDom_virtualize(domNode);

			return _Browser_makeAnimator(initialModel, function(model)
			{
				var nextNode = view(model);
				var patches = _VirtualDom_diff(currNode, nextNode);
				domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
				currNode = nextNode;
			});
		}
	);
});



// DOCUMENT


var _Debugger_document;

var _Browser_document = _Debugger_document || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		flagDecoder,
		args,
		impl.init,
		impl.update,
		impl.subscriptions,
		function(sendToApp, initialModel) {
			var divertHrefToApp = impl.setup && impl.setup(sendToApp)
			var view = impl.view;
			var title = _VirtualDom_doc.title;
			var bodyNode = _VirtualDom_doc.body;
			var currNode = _VirtualDom_virtualize(bodyNode);
			return _Browser_makeAnimator(initialModel, function(model)
			{
				_VirtualDom_divertHrefToApp = divertHrefToApp;
				var doc = view(model);
				var nextNode = _VirtualDom_node('body')(_List_Nil)(doc.body);
				var patches = _VirtualDom_diff(currNode, nextNode);
				bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
				currNode = nextNode;
				_VirtualDom_divertHrefToApp = 0;
				(title !== doc.title) && (_VirtualDom_doc.title = title = doc.title);
			});
		}
	);
});



// ANIMATION


var _Browser_cancelAnimationFrame =
	typeof cancelAnimationFrame !== 'undefined'
		? cancelAnimationFrame
		: function(id) { clearTimeout(id); };

var _Browser_requestAnimationFrame =
	typeof requestAnimationFrame !== 'undefined'
		? requestAnimationFrame
		: function(callback) { return setTimeout(callback, 1000 / 60); };


function _Browser_makeAnimator(model, draw)
{
	draw(model);

	var state = 0;

	function updateIfNeeded()
	{
		state = state === 1
			? 0
			: ( _Browser_requestAnimationFrame(updateIfNeeded), draw(model), 1 );
	}

	return function(nextModel, isSync)
	{
		model = nextModel;

		isSync
			? ( draw(model),
				state === 2 && (state = 1)
				)
			: ( state === 0 && _Browser_requestAnimationFrame(updateIfNeeded),
				state = 2
				);
	};
}



// APPLICATION


function _Browser_application(impl)
{
	var onUrlChange = impl.onUrlChange;
	var onUrlRequest = impl.onUrlRequest;
	var key = function() { key.a(onUrlChange(_Browser_getUrl())); };

	return _Browser_document({
		setup: function(sendToApp)
		{
			key.a = sendToApp;
			_Browser_window.addEventListener('popstate', key);
			_Browser_window.navigator.userAgent.indexOf('Trident') < 0 || _Browser_window.addEventListener('hashchange', key);

			return F2(function(domNode, event)
			{
				if (!event.ctrlKey && !event.metaKey && !event.shiftKey && event.button < 1 && !domNode.target && !domNode.hasAttribute('download'))
				{
					event.preventDefault();
					var href = domNode.href;
					var curr = _Browser_getUrl();
					var next = $elm$url$Url$fromString(href).a;
					sendToApp(onUrlRequest(
						(next
							&& curr.protocol === next.protocol
							&& curr.host === next.host
							&& curr.port_.a === next.port_.a
						)
							? $elm$browser$Browser$Internal(next)
							: $elm$browser$Browser$External(href)
					));
				}
			});
		},
		init: function(flags)
		{
			return A3(impl.init, flags, _Browser_getUrl(), key);
		},
		view: impl.view,
		update: impl.update,
		subscriptions: impl.subscriptions
	});
}

function _Browser_getUrl()
{
	return $elm$url$Url$fromString(_VirtualDom_doc.location.href).a || _Debug_crash(1);
}

var _Browser_go = F2(function(key, n)
{
	return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function() {
		n && history.go(n);
		key();
	}));
});

var _Browser_pushUrl = F2(function(key, url)
{
	return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function() {
		history.pushState({}, '', url);
		key();
	}));
});

var _Browser_replaceUrl = F2(function(key, url)
{
	return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function() {
		history.replaceState({}, '', url);
		key();
	}));
});



// GLOBAL EVENTS


var _Browser_fakeNode = { addEventListener: function() {}, removeEventListener: function() {} };
var _Browser_doc = typeof document !== 'undefined' ? document : _Browser_fakeNode;
var _Browser_window = typeof window !== 'undefined' ? window : _Browser_fakeNode;

var _Browser_on = F3(function(node, eventName, sendToSelf)
{
	return _Scheduler_spawn(_Scheduler_binding(function(callback)
	{
		function handler(event)	{ _Scheduler_rawSpawn(sendToSelf(event)); }
		node.addEventListener(eventName, handler, _VirtualDom_passiveSupported && { passive: true });
		return function() { node.removeEventListener(eventName, handler); };
	}));
});

var _Browser_decodeEvent = F2(function(decoder, event)
{
	var result = _Json_runHelp(decoder, event);
	return $elm$core$Result$isOk(result) ? $elm$core$Maybe$Just(result.a) : $elm$core$Maybe$Nothing;
});



// PAGE VISIBILITY


function _Browser_visibilityInfo()
{
	return (typeof _VirtualDom_doc.hidden !== 'undefined')
		? { hidden: 'hidden', change: 'visibilitychange' }
		:
	(typeof _VirtualDom_doc.mozHidden !== 'undefined')
		? { hidden: 'mozHidden', change: 'mozvisibilitychange' }
		:
	(typeof _VirtualDom_doc.msHidden !== 'undefined')
		? { hidden: 'msHidden', change: 'msvisibilitychange' }
		:
	(typeof _VirtualDom_doc.webkitHidden !== 'undefined')
		? { hidden: 'webkitHidden', change: 'webkitvisibilitychange' }
		: { hidden: 'hidden', change: 'visibilitychange' };
}



// ANIMATION FRAMES


function _Browser_rAF()
{
	return _Scheduler_binding(function(callback)
	{
		var id = _Browser_requestAnimationFrame(function() {
			callback(_Scheduler_succeed(Date.now()));
		});

		return function() {
			_Browser_cancelAnimationFrame(id);
		};
	});
}


function _Browser_now()
{
	return _Scheduler_binding(function(callback)
	{
		callback(_Scheduler_succeed(Date.now()));
	});
}



// DOM STUFF


function _Browser_withNode(id, doStuff)
{
	return _Scheduler_binding(function(callback)
	{
		_Browser_requestAnimationFrame(function() {
			var node = document.getElementById(id);
			callback(node
				? _Scheduler_succeed(doStuff(node))
				: _Scheduler_fail($elm$browser$Browser$Dom$NotFound(id))
			);
		});
	});
}


function _Browser_withWindow(doStuff)
{
	return _Scheduler_binding(function(callback)
	{
		_Browser_requestAnimationFrame(function() {
			callback(_Scheduler_succeed(doStuff()));
		});
	});
}


// FOCUS and BLUR


var _Browser_call = F2(function(functionName, id)
{
	return _Browser_withNode(id, function(node) {
		node[functionName]();
		return _Utils_Tuple0;
	});
});



// WINDOW VIEWPORT


function _Browser_getViewport()
{
	return {
		scene: _Browser_getScene(),
		viewport: {
			x: _Browser_window.pageXOffset,
			y: _Browser_window.pageYOffset,
			width: _Browser_doc.documentElement.clientWidth,
			height: _Browser_doc.documentElement.clientHeight
		}
	};
}

function _Browser_getScene()
{
	var body = _Browser_doc.body;
	var elem = _Browser_doc.documentElement;
	return {
		width: Math.max(body.scrollWidth, body.offsetWidth, elem.scrollWidth, elem.offsetWidth, elem.clientWidth),
		height: Math.max(body.scrollHeight, body.offsetHeight, elem.scrollHeight, elem.offsetHeight, elem.clientHeight)
	};
}

var _Browser_setViewport = F2(function(x, y)
{
	return _Browser_withWindow(function()
	{
		_Browser_window.scroll(x, y);
		return _Utils_Tuple0;
	});
});



// ELEMENT VIEWPORT


function _Browser_getViewportOf(id)
{
	return _Browser_withNode(id, function(node)
	{
		return {
			scene: {
				width: node.scrollWidth,
				height: node.scrollHeight
			},
			viewport: {
				x: node.scrollLeft,
				y: node.scrollTop,
				width: node.clientWidth,
				height: node.clientHeight
			}
		};
	});
}


var _Browser_setViewportOf = F3(function(id, x, y)
{
	return _Browser_withNode(id, function(node)
	{
		node.scrollLeft = x;
		node.scrollTop = y;
		return _Utils_Tuple0;
	});
});



// ELEMENT


function _Browser_getElement(id)
{
	return _Browser_withNode(id, function(node)
	{
		var rect = node.getBoundingClientRect();
		var x = _Browser_window.pageXOffset;
		var y = _Browser_window.pageYOffset;
		return {
			scene: _Browser_getScene(),
			viewport: {
				x: x,
				y: y,
				width: _Browser_doc.documentElement.clientWidth,
				height: _Browser_doc.documentElement.clientHeight
			},
			element: {
				x: x + rect.left,
				y: y + rect.top,
				width: rect.width,
				height: rect.height
			}
		};
	});
}



// LOAD and RELOAD


function _Browser_reload(skipCache)
{
	return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function(callback)
	{
		_VirtualDom_doc.location.reload(skipCache);
	}));
}

function _Browser_load(url)
{
	return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function(callback)
	{
		try
		{
			_Browser_window.location = url;
		}
		catch(err)
		{
			// Only Firefox can throw a NS_ERROR_MALFORMED_URI exception here.
			// Other browsers reload the page, so let's be consistent about that.
			_VirtualDom_doc.location.reload(false);
		}
	}));
}



var _Bitwise_and = F2(function(a, b)
{
	return a & b;
});

var _Bitwise_or = F2(function(a, b)
{
	return a | b;
});

var _Bitwise_xor = F2(function(a, b)
{
	return a ^ b;
});

function _Bitwise_complement(a)
{
	return ~a;
};

var _Bitwise_shiftLeftBy = F2(function(offset, a)
{
	return a << offset;
});

var _Bitwise_shiftRightBy = F2(function(offset, a)
{
	return a >> offset;
});

var _Bitwise_shiftRightZfBy = F2(function(offset, a)
{
	return a >>> offset;
});



var _Markdown_eval = function(code) {
  try {
    return '' + JSON.stringify(eval(code));
  } catch (e) {
    return 'eval(): ' + e;
  }
}




// VIRTUAL-DOM WIDGETS


var _Markdown_toHtml = F3(function(options, factList, rawMarkdown)
{
	return _VirtualDom_custom(
		factList,
		{
			a: options,
			b: rawMarkdown
		},
		_Markdown_render,
		_Markdown_diff
	);
});



// WIDGET IMPLEMENTATION


function _Markdown_render(model)
{
	return A2(_Markdown_replace, model, _VirtualDom_doc.createElement('div'));
}


function _Markdown_diff(x, y)
{
	return x.b === y.b && x.a === y.a
		? false
		: _Markdown_replace(y);
}


var _Markdown_replace = F2(function(model, div)
{
	div.innerHTML = _Markdown_marked(model.b, _Markdown_formatOptions(model.a));
	return div;
});



// ACTUAL MARKDOWN PARSER


var _Markdown_marked = function() {
	// catch the `marked` object regardless of the outer environment.
	// (ex. a CommonJS module compatible environment.)
	// note that this depends on marked's implementation of environment detection.
	var module = {};
	var exports = module.exports = {};

	/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 * commit cd2f6f5b7091154c5526e79b5f3bfb4d15995a51
	 */
	(function(){var block={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:noop,hr:/^( *[-*_]){3,} *(?:\n+|$)/,heading:/^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,nptable:noop,lheading:/^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,blockquote:/^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,list:/^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,html:/^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,table:noop,paragraph:/^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,text:/^[^\n]+/};block.bullet=/(?:[*+-]|\d+\.)/;block.item=/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;block.item=replace(block.item,"gm")(/bull/g,block.bullet)();block.list=replace(block.list)(/bull/g,block.bullet)("hr","\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def","\\n+(?="+block.def.source+")")();block.blockquote=replace(block.blockquote)("def",block.def)();block._tag="(?!(?:"+"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code"+"|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo"+"|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b";block.html=replace(block.html)("comment",/<!--[\s\S]*?-->/)("closed",/<(tag)[\s\S]+?<\/\1>/)("closing",/<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g,block._tag)();block.paragraph=replace(block.paragraph)("hr",block.hr)("heading",block.heading)("lheading",block.lheading)("blockquote",block.blockquote)("tag","<"+block._tag)("def",block.def)();block.normal=merge({},block);block.gfm=merge({},block.normal,{fences:/^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,paragraph:/^/,heading:/^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/});block.gfm.paragraph=replace(block.paragraph)("(?!","(?!"+block.gfm.fences.source.replace("\\1","\\2")+"|"+block.list.source.replace("\\1","\\3")+"|")();block.tables=merge({},block.gfm,{nptable:/^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,table:/^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/});function Lexer(options){this.tokens=[];this.tokens.links={};this.options=options||marked.defaults;this.rules=block.normal;if(this.options.gfm){if(this.options.tables){this.rules=block.tables}else{this.rules=block.gfm}}}Lexer.rules=block;Lexer.lex=function(src,options){var lexer=new Lexer(options);return lexer.lex(src)};Lexer.prototype.lex=function(src){src=src.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g,"\n");return this.token(src,true)};Lexer.prototype.token=function(src,top,bq){var src=src.replace(/^ +$/gm,""),next,loose,cap,bull,b,item,space,i,l;while(src){if(cap=this.rules.newline.exec(src)){src=src.substring(cap[0].length);if(cap[0].length>1){this.tokens.push({type:"space"})}}if(cap=this.rules.code.exec(src)){src=src.substring(cap[0].length);cap=cap[0].replace(/^ {4}/gm,"");this.tokens.push({type:"code",text:!this.options.pedantic?cap.replace(/\n+$/,""):cap});continue}if(cap=this.rules.fences.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"code",lang:cap[2],text:cap[3]||""});continue}if(cap=this.rules.heading.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"heading",depth:cap[1].length,text:cap[2]});continue}if(top&&(cap=this.rules.nptable.exec(src))){src=src.substring(cap[0].length);item={type:"table",header:cap[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:cap[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:cap[3].replace(/\n$/,"").split("\n")};for(i=0;i<item.align.length;i++){if(/^ *-+: *$/.test(item.align[i])){item.align[i]="right"}else if(/^ *:-+: *$/.test(item.align[i])){item.align[i]="center"}else if(/^ *:-+ *$/.test(item.align[i])){item.align[i]="left"}else{item.align[i]=null}}for(i=0;i<item.cells.length;i++){item.cells[i]=item.cells[i].split(/ *\| */)}this.tokens.push(item);continue}if(cap=this.rules.lheading.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"heading",depth:cap[2]==="="?1:2,text:cap[1]});continue}if(cap=this.rules.hr.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"hr"});continue}if(cap=this.rules.blockquote.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"blockquote_start"});cap=cap[0].replace(/^ *> ?/gm,"");this.token(cap,top,true);this.tokens.push({type:"blockquote_end"});continue}if(cap=this.rules.list.exec(src)){src=src.substring(cap[0].length);bull=cap[2];this.tokens.push({type:"list_start",ordered:bull.length>1});cap=cap[0].match(this.rules.item);next=false;l=cap.length;i=0;for(;i<l;i++){item=cap[i];space=item.length;item=item.replace(/^ *([*+-]|\d+\.) +/,"");if(~item.indexOf("\n ")){space-=item.length;item=!this.options.pedantic?item.replace(new RegExp("^ {1,"+space+"}","gm"),""):item.replace(/^ {1,4}/gm,"")}if(this.options.smartLists&&i!==l-1){b=block.bullet.exec(cap[i+1])[0];if(bull!==b&&!(bull.length>1&&b.length>1)){src=cap.slice(i+1).join("\n")+src;i=l-1}}loose=next||/\n\n(?!\s*$)/.test(item);if(i!==l-1){next=item.charAt(item.length-1)==="\n";if(!loose)loose=next}this.tokens.push({type:loose?"loose_item_start":"list_item_start"});this.token(item,false,bq);this.tokens.push({type:"list_item_end"})}this.tokens.push({type:"list_end"});continue}if(cap=this.rules.html.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:this.options.sanitize?"paragraph":"html",pre:!this.options.sanitizer&&(cap[1]==="pre"||cap[1]==="script"||cap[1]==="style"),text:cap[0]});continue}if(!bq&&top&&(cap=this.rules.def.exec(src))){src=src.substring(cap[0].length);this.tokens.links[cap[1].toLowerCase()]={href:cap[2],title:cap[3]};continue}if(top&&(cap=this.rules.table.exec(src))){src=src.substring(cap[0].length);item={type:"table",header:cap[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:cap[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:cap[3].replace(/(?: *\| *)?\n$/,"").split("\n")};for(i=0;i<item.align.length;i++){if(/^ *-+: *$/.test(item.align[i])){item.align[i]="right"}else if(/^ *:-+: *$/.test(item.align[i])){item.align[i]="center"}else if(/^ *:-+ *$/.test(item.align[i])){item.align[i]="left"}else{item.align[i]=null}}for(i=0;i<item.cells.length;i++){item.cells[i]=item.cells[i].replace(/^ *\| *| *\| *$/g,"").split(/ *\| */)}this.tokens.push(item);continue}if(top&&(cap=this.rules.paragraph.exec(src))){src=src.substring(cap[0].length);this.tokens.push({type:"paragraph",text:cap[1].charAt(cap[1].length-1)==="\n"?cap[1].slice(0,-1):cap[1]});continue}if(cap=this.rules.text.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"text",text:cap[0]});continue}if(src){throw new Error("Infinite loop on byte: "+src.charCodeAt(0))}}return this.tokens};var inline={escape:/^\\([\\`*{}\[\]()#+\-.!_>])/,autolink:/^<([^ >]+(@|:\/)[^ >]+)>/,url:noop,tag:/^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,link:/^!?\[(inside)\]\(href\)/,reflink:/^!?\[(inside)\]\s*\[([^\]]*)\]/,nolink:/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,strong:/^_\_([\s\S]+?)_\_(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,em:/^\b_((?:[^_]|_\_)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,code:/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,br:/^ {2,}\n(?!\s*$)/,del:noop,text:/^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/};inline._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;inline._href=/\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;inline.link=replace(inline.link)("inside",inline._inside)("href",inline._href)();inline.reflink=replace(inline.reflink)("inside",inline._inside)();inline.normal=merge({},inline);inline.pedantic=merge({},inline.normal,{strong:/^_\_(?=\S)([\s\S]*?\S)_\_(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/});inline.gfm=merge({},inline.normal,{escape:replace(inline.escape)("])","~|])")(),url:/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,del:/^~~(?=\S)([\s\S]*?\S)~~/,text:replace(inline.text)("]|","~]|")("|","|https?://|")()});inline.breaks=merge({},inline.gfm,{br:replace(inline.br)("{2,}","*")(),text:replace(inline.gfm.text)("{2,}","*")()});function InlineLexer(links,options){this.options=options||marked.defaults;this.links=links;this.rules=inline.normal;this.renderer=this.options.renderer||new Renderer;this.renderer.options=this.options;if(!this.links){throw new Error("Tokens array requires a `links` property.")}if(this.options.gfm){if(this.options.breaks){this.rules=inline.breaks}else{this.rules=inline.gfm}}else if(this.options.pedantic){this.rules=inline.pedantic}}InlineLexer.rules=inline;InlineLexer.output=function(src,links,options){var inline=new InlineLexer(links,options);return inline.output(src)};InlineLexer.prototype.output=function(src){var out="",link,text,href,cap;while(src){if(cap=this.rules.escape.exec(src)){src=src.substring(cap[0].length);out+=cap[1];continue}if(cap=this.rules.autolink.exec(src)){src=src.substring(cap[0].length);if(cap[2]==="@"){text=cap[1].charAt(6)===":"?this.mangle(cap[1].substring(7)):this.mangle(cap[1]);href=this.mangle("mailto:")+text}else{text=escape(cap[1]);href=text}out+=this.renderer.link(href,null,text);continue}if(!this.inLink&&(cap=this.rules.url.exec(src))){src=src.substring(cap[0].length);text=escape(cap[1]);href=text;out+=this.renderer.link(href,null,text);continue}if(cap=this.rules.tag.exec(src)){if(!this.inLink&&/^<a /i.test(cap[0])){this.inLink=true}else if(this.inLink&&/^<\/a>/i.test(cap[0])){this.inLink=false}src=src.substring(cap[0].length);out+=this.options.sanitize?this.options.sanitizer?this.options.sanitizer(cap[0]):escape(cap[0]):cap[0];continue}if(cap=this.rules.link.exec(src)){src=src.substring(cap[0].length);this.inLink=true;out+=this.outputLink(cap,{href:cap[2],title:cap[3]});this.inLink=false;continue}if((cap=this.rules.reflink.exec(src))||(cap=this.rules.nolink.exec(src))){src=src.substring(cap[0].length);link=(cap[2]||cap[1]).replace(/\s+/g," ");link=this.links[link.toLowerCase()];if(!link||!link.href){out+=cap[0].charAt(0);src=cap[0].substring(1)+src;continue}this.inLink=true;out+=this.outputLink(cap,link);this.inLink=false;continue}if(cap=this.rules.strong.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.strong(this.output(cap[2]||cap[1]));continue}if(cap=this.rules.em.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.em(this.output(cap[2]||cap[1]));continue}if(cap=this.rules.code.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.codespan(escape(cap[2],true));continue}if(cap=this.rules.br.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.br();continue}if(cap=this.rules.del.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.del(this.output(cap[1]));continue}if(cap=this.rules.text.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.text(escape(this.smartypants(cap[0])));continue}if(src){throw new Error("Infinite loop on byte: "+src.charCodeAt(0))}}return out};InlineLexer.prototype.outputLink=function(cap,link){var href=escape(link.href),title=link.title?escape(link.title):null;return cap[0].charAt(0)!=="!"?this.renderer.link(href,title,this.output(cap[1])):this.renderer.image(href,title,escape(cap[1]))};InlineLexer.prototype.smartypants=function(text){if(!this.options.smartypants)return text;return text.replace(/---/g,"").replace(/--/g,"").replace(/(^|[-\u2014\/(\[{"\s])'/g,"$1").replace(/'/g,"").replace(/(^|[-\u2014\/(\[{\u2018\s])"/g,"$1").replace(/"/g,"").replace(/\.{3}/g,"")};InlineLexer.prototype.mangle=function(text){if(!this.options.mangle)return text;var out="",l=text.length,i=0,ch;for(;i<l;i++){ch=text.charCodeAt(i);if(Math.random()>.5){ch="x"+ch.toString(16)}out+="&#"+ch+";"}return out};function Renderer(options){this.options=options||{}}Renderer.prototype.code=function(code,lang,escaped){if(this.options.highlight){var out=this.options.highlight(code,lang);if(out!=null&&out!==code){escaped=true;code=out}}if(!lang){return"<pre><code>"+(escaped?code:escape(code,true))+"\n</code></pre>"}return'<pre><code class="'+this.options.langPrefix+escape(lang,true)+'">'+(escaped?code:escape(code,true))+"\n</code></pre>\n"};Renderer.prototype.blockquote=function(quote){return"<blockquote>\n"+quote+"</blockquote>\n"};Renderer.prototype.html=function(html){return html};Renderer.prototype.heading=function(text,level,raw){return"<h"+level+' id="'+this.options.headerPrefix+raw.toLowerCase().replace(/[^\w]+/g,"-")+'">'+text+"</h"+level+">\n"};Renderer.prototype.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"};Renderer.prototype.list=function(body,ordered){var type=ordered?"ol":"ul";return"<"+type+">\n"+body+"</"+type+">\n"};Renderer.prototype.listitem=function(text){return"<li>"+text+"</li>\n"};Renderer.prototype.paragraph=function(text){return"<p>"+text+"</p>\n"};Renderer.prototype.table=function(header,body){return"<table>\n"+"<thead>\n"+header+"</thead>\n"+"<tbody>\n"+body+"</tbody>\n"+"</table>\n"};Renderer.prototype.tablerow=function(content){return"<tr>\n"+content+"</tr>\n"};Renderer.prototype.tablecell=function(content,flags){var type=flags.header?"th":"td";var tag=flags.align?"<"+type+' style="text-align:'+flags.align+'">':"<"+type+">";return tag+content+"</"+type+">\n"};Renderer.prototype.strong=function(text){return"<strong>"+text+"</strong>"};Renderer.prototype.em=function(text){return"<em>"+text+"</em>"};Renderer.prototype.codespan=function(text){return"<code>"+text+"</code>"};Renderer.prototype.br=function(){return this.options.xhtml?"<br/>":"<br>"};Renderer.prototype.del=function(text){return"<del>"+text+"</del>"};Renderer.prototype.link=function(href,title,text){if(this.options.sanitize){try{var prot=decodeURIComponent(unescape(href)).replace(/[^\w:]/g,"").toLowerCase()}catch(e){return""}if(prot.indexOf("javascript:")===0||prot.indexOf("vbscript:")===0||prot.indexOf("data:")===0){return""}}var out='<a href="'+href+'"';if(title){out+=' title="'+title+'"'}out+=">"+text+"</a>";return out};Renderer.prototype.image=function(href,title,text){var out='<img src="'+href+'" alt="'+text+'"';if(title){out+=' title="'+title+'"'}out+=this.options.xhtml?"/>":">";return out};Renderer.prototype.text=function(text){return text};function Parser(options){this.tokens=[];this.token=null;this.options=options||marked.defaults;this.options.renderer=this.options.renderer||new Renderer;this.renderer=this.options.renderer;this.renderer.options=this.options}Parser.parse=function(src,options,renderer){var parser=new Parser(options,renderer);return parser.parse(src)};Parser.prototype.parse=function(src){this.inline=new InlineLexer(src.links,this.options,this.renderer);this.tokens=src.reverse();var out="";while(this.next()){out+=this.tok()}return out};Parser.prototype.next=function(){return this.token=this.tokens.pop()};Parser.prototype.peek=function(){return this.tokens[this.tokens.length-1]||0};Parser.prototype.parseText=function(){var body=this.token.text;while(this.peek().type==="text"){body+="\n"+this.next().text}return this.inline.output(body)};Parser.prototype.tok=function(){switch(this.token.type){case"space":{return""}case"hr":{return this.renderer.hr()}case"heading":{return this.renderer.heading(this.inline.output(this.token.text),this.token.depth,this.token.text)}case"code":{return this.renderer.code(this.token.text,this.token.lang,this.token.escaped)}case"table":{var header="",body="",i,row,cell,flags,j;cell="";for(i=0;i<this.token.header.length;i++){flags={header:true,align:this.token.align[i]};cell+=this.renderer.tablecell(this.inline.output(this.token.header[i]),{header:true,align:this.token.align[i]})}header+=this.renderer.tablerow(cell);for(i=0;i<this.token.cells.length;i++){row=this.token.cells[i];cell="";for(j=0;j<row.length;j++){cell+=this.renderer.tablecell(this.inline.output(row[j]),{header:false,align:this.token.align[j]})}body+=this.renderer.tablerow(cell)}return this.renderer.table(header,body)}case"blockquote_start":{var body="";while(this.next().type!=="blockquote_end"){body+=this.tok()}return this.renderer.blockquote(body)}case"list_start":{var body="",ordered=this.token.ordered;while(this.next().type!=="list_end"){body+=this.tok()}return this.renderer.list(body,ordered)}case"list_item_start":{var body="";while(this.next().type!=="list_item_end"){body+=this.token.type==="text"?this.parseText():this.tok()}return this.renderer.listitem(body)}case"loose_item_start":{var body="";while(this.next().type!=="list_item_end"){body+=this.tok()}return this.renderer.listitem(body)}case"html":{var html=!this.token.pre&&!this.options.pedantic?this.inline.output(this.token.text):this.token.text;return this.renderer.html(html)}case"paragraph":{return this.renderer.paragraph(this.inline.output(this.token.text))}case"text":{return this.renderer.paragraph(this.parseText())}}};function escape(html,encode){return html.replace(!encode?/&(?!#?\w+;)/g:/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function unescape(html){return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g,function(_,n){n=n.toLowerCase();if(n==="colon")return":";if(n.charAt(0)==="#"){return n.charAt(1)==="x"?String.fromCharCode(parseInt(n.substring(2),16)):String.fromCharCode(+n.substring(1))}return""})}function replace(regex,opt){regex=regex.source;opt=opt||"";return function self(name,val){if(!name)return new RegExp(regex,opt);val=val.source||val;val=val.replace(/(^|[^\[])\^/g,"$1");regex=regex.replace(name,val);return self}}function noop(){}noop.exec=noop;function merge(obj){var i=1,target,key;for(;i<arguments.length;i++){target=arguments[i];for(key in target){if(Object.prototype.hasOwnProperty.call(target,key)){obj[key]=target[key]}}}return obj}function marked(src,opt,callback){if(callback||typeof opt==="function"){if(!callback){callback=opt;opt=null}opt=merge({},marked.defaults,opt||{});var highlight=opt.highlight,tokens,pending,i=0;try{tokens=Lexer.lex(src,opt)}catch(e){return callback(e)}pending=tokens.length;var done=function(err){if(err){opt.highlight=highlight;return callback(err)}var out;try{out=Parser.parse(tokens,opt)}catch(e){err=e}opt.highlight=highlight;return err?callback(err):callback(null,out)};if(!highlight||highlight.length<3){return done()}delete opt.highlight;if(!pending)return done();for(;i<tokens.length;i++){(function(token){if(token.type!=="code"){return--pending||done()}return highlight(token.text,token.lang,function(err,code){if(err)return done(err);if(code==null||code===token.text){return--pending||done()}token.text=code;token.escaped=true;--pending||done()})})(tokens[i])}return}try{if(opt)opt=merge({},marked.defaults,opt);return Parser.parse(Lexer.lex(src,opt),opt)}catch(e){e.message+="\nPlease report this to https://github.com/chjj/marked.";if((opt||marked.defaults).silent){return"<p>An error occured:</p><pre>"+escape(e.message+"",true)+"</pre>"}throw e}}marked.options=marked.setOptions=function(opt){merge(marked.defaults,opt);return marked};marked.defaults={gfm:true,tables:true,breaks:false,pedantic:false,sanitize:false,sanitizer:null,mangle:true,smartLists:false,silent:false,highlight:null,langPrefix:"lang-",smartypants:false,headerPrefix:"",renderer:new Renderer,xhtml:false};marked.Parser=Parser;marked.parser=Parser.parse;marked.Renderer=Renderer;marked.Lexer=Lexer;marked.lexer=Lexer.lex;marked.InlineLexer=InlineLexer;marked.inlineLexer=InlineLexer.output;marked.parse=marked;if(typeof module!=="undefined"&&typeof exports==="object"){module.exports=marked}else if(typeof define==="function"&&define.amd){define(function(){return marked})}else{this.marked=marked}}).call(function(){return this||(typeof window!=="undefined"?window:global)}());

	return module.exports;
}();


// FORMAT OPTIONS FOR MARKED IMPLEMENTATION

function _Markdown_formatOptions(options)
{
	function toHighlight(code, lang)
	{
		if (!lang && $elm$core$Maybe$isJust(options.defaultHighlighting))
		{
			lang = options.defaultHighlighting.a;
		}

		if (typeof hljs !== 'undefined' && lang && hljs.listLanguages().indexOf(lang) >= 0)
		{
			return hljs.highlight(lang, code, true).value;
		}

		return code;
	}

	var gfm = options.githubFlavored.a;

	return {
		highlight: toHighlight,
		gfm: gfm,
		tables: gfm && gfm.tables,
		breaks: gfm && gfm.breaks,
		sanitize: options.sanitize,
		smartypants: options.smartypants
	};
}


// CREATE

var _Regex_never = /.^/;

var _Regex_fromStringWith = F2(function(options, string)
{
	var flags = 'g';
	if (options.multiline) { flags += 'm'; }
	if (options.caseInsensitive) { flags += 'i'; }

	try
	{
		return $elm$core$Maybe$Just(new RegExp(string, flags));
	}
	catch(error)
	{
		return $elm$core$Maybe$Nothing;
	}
});


// USE

var _Regex_contains = F2(function(re, string)
{
	return string.match(re) !== null;
});


var _Regex_findAtMost = F3(function(n, re, str)
{
	var out = [];
	var number = 0;
	var string = str;
	var lastIndex = re.lastIndex;
	var prevLastIndex = -1;
	var result;
	while (number++ < n && (result = re.exec(string)))
	{
		if (prevLastIndex == re.lastIndex) break;
		var i = result.length - 1;
		var subs = new Array(i);
		while (i > 0)
		{
			var submatch = result[i];
			subs[--i] = submatch
				? $elm$core$Maybe$Just(submatch)
				: $elm$core$Maybe$Nothing;
		}
		out.push(A4($elm$regex$Regex$Match, result[0], result.index, number, _List_fromArray(subs)));
		prevLastIndex = re.lastIndex;
	}
	re.lastIndex = lastIndex;
	return _List_fromArray(out);
});


var _Regex_replaceAtMost = F4(function(n, re, replacer, string)
{
	var count = 0;
	function jsReplacer(match)
	{
		if (count++ >= n)
		{
			return match;
		}
		var i = arguments.length - 3;
		var submatches = new Array(i);
		while (i > 0)
		{
			var submatch = arguments[i];
			submatches[--i] = submatch
				? $elm$core$Maybe$Just(submatch)
				: $elm$core$Maybe$Nothing;
		}
		return replacer(A4($elm$regex$Regex$Match, match, arguments[arguments.length - 2], count, _List_fromArray(submatches)));
	}
	return string.replace(re, jsReplacer);
});

var _Regex_splitAtMost = F3(function(n, re, str)
{
	var string = str;
	var out = [];
	var start = re.lastIndex;
	var restoreLastIndex = re.lastIndex;
	while (n--)
	{
		var result = re.exec(string);
		if (!result) break;
		out.push(string.slice(start, result.index));
		start = re.lastIndex;
	}
	out.push(string.slice(start));
	re.lastIndex = restoreLastIndex;
	return _List_fromArray(out);
});

var _Regex_infinity = Infinity;
var $elm$core$Basics$apR = F2(
	function (x, f) {
		return f(x);
	});
var $elm$core$Tuple$first = function (_v0) {
	var x = _v0.a;
	return x;
};
var $elm$core$Dict$RBEmpty_elm_builtin = {$: 'RBEmpty_elm_builtin'};
var $elm$core$Dict$empty = $elm$core$Dict$RBEmpty_elm_builtin;
var $elm$core$List$foldl = F3(
	function (func, acc, list) {
		foldl:
		while (true) {
			if (!list.b) {
				return acc;
			} else {
				var x = list.a;
				var xs = list.b;
				var $temp$func = func,
					$temp$acc = A2(func, x, acc),
					$temp$list = xs;
				func = $temp$func;
				acc = $temp$acc;
				list = $temp$list;
				continue foldl;
			}
		}
	});
var $elm$core$Dict$Black = {$: 'Black'};
var $elm$core$Dict$RBNode_elm_builtin = F5(
	function (a, b, c, d, e) {
		return {$: 'RBNode_elm_builtin', a: a, b: b, c: c, d: d, e: e};
	});
var $elm$core$Dict$Red = {$: 'Red'};
var $elm$core$Dict$balance = F5(
	function (color, key, value, left, right) {
		if ((right.$ === 'RBNode_elm_builtin') && (right.a.$ === 'Red')) {
			var _v1 = right.a;
			var rK = right.b;
			var rV = right.c;
			var rLeft = right.d;
			var rRight = right.e;
			if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) {
				var _v3 = left.a;
				var lK = left.b;
				var lV = left.c;
				var lLeft = left.d;
				var lRight = left.e;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Red,
					key,
					value,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					color,
					rK,
					rV,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, left, rLeft),
					rRight);
			}
		} else {
			if ((((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) && (left.d.$ === 'RBNode_elm_builtin')) && (left.d.a.$ === 'Red')) {
				var _v5 = left.a;
				var lK = left.b;
				var lV = left.c;
				var _v6 = left.d;
				var _v7 = _v6.a;
				var llK = _v6.b;
				var llV = _v6.c;
				var llLeft = _v6.d;
				var llRight = _v6.e;
				var lRight = left.e;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Red,
					lK,
					lV,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, lRight, right));
			} else {
				return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, left, right);
			}
		}
	});
var $elm$core$Basics$EQ = {$: 'EQ'};
var $elm$core$Basics$LT = {$: 'LT'};
var $elm$core$List$cons = _List_cons;
var $elm$core$Elm$JsArray$foldr = _JsArray_foldr;
var $elm$core$Array$foldr = F3(
	function (func, baseCase, _v0) {
		var tree = _v0.c;
		var tail = _v0.d;
		var helper = F2(
			function (node, acc) {
				if (node.$ === 'SubTree') {
					var subTree = node.a;
					return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
				} else {
					var values = node.a;
					return A3($elm$core$Elm$JsArray$foldr, func, acc, values);
				}
			});
		return A3(
			$elm$core$Elm$JsArray$foldr,
			helper,
			A3($elm$core$Elm$JsArray$foldr, func, baseCase, tail),
			tree);
	});
var $elm$core$Array$toList = function (array) {
	return A3($elm$core$Array$foldr, $elm$core$List$cons, _List_Nil, array);
};
var $elm$core$Dict$foldr = F3(
	function (func, acc, t) {
		foldr:
		while (true) {
			if (t.$ === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var key = t.b;
				var value = t.c;
				var left = t.d;
				var right = t.e;
				var $temp$func = func,
					$temp$acc = A3(
					func,
					key,
					value,
					A3($elm$core$Dict$foldr, func, acc, right)),
					$temp$t = left;
				func = $temp$func;
				acc = $temp$acc;
				t = $temp$t;
				continue foldr;
			}
		}
	});
var $elm$core$Dict$toList = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, list) {
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(key, value),
					list);
			}),
		_List_Nil,
		dict);
};
var $elm$core$Dict$keys = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, keyList) {
				return A2($elm$core$List$cons, key, keyList);
			}),
		_List_Nil,
		dict);
};
var $elm$core$Set$toList = function (_v0) {
	var dict = _v0.a;
	return $elm$core$Dict$keys(dict);
};
var $elm$core$Basics$GT = {$: 'GT'};
var $elm$core$Basics$compare = _Utils_compare;
var $elm$core$Dict$insertHelp = F3(
	function (key, value, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
		} else {
			var nColor = dict.a;
			var nKey = dict.b;
			var nValue = dict.c;
			var nLeft = dict.d;
			var nRight = dict.e;
			var _v1 = A2($elm$core$Basics$compare, key, nKey);
			switch (_v1.$) {
				case 'LT':
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						A3($elm$core$Dict$insertHelp, key, value, nLeft),
						nRight);
				case 'EQ':
					return A5($elm$core$Dict$RBNode_elm_builtin, nColor, nKey, value, nLeft, nRight);
				default:
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						nLeft,
						A3($elm$core$Dict$insertHelp, key, value, nRight));
			}
		}
	});
var $elm$core$Dict$insert = F3(
	function (key, value, dict) {
		var _v0 = A3($elm$core$Dict$insertHelp, key, value, dict);
		if ((_v0.$ === 'RBNode_elm_builtin') && (_v0.a.$ === 'Red')) {
			var _v1 = _v0.a;
			var k = _v0.b;
			var v = _v0.c;
			var l = _v0.d;
			var r = _v0.e;
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
		} else {
			var x = _v0;
			return x;
		}
	});
var $elm$core$Dict$fromList = function (assocs) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (_v0, dict) {
				var key = _v0.a;
				var value = _v0.b;
				return A3($elm$core$Dict$insert, key, value, dict);
			}),
		$elm$core$Dict$empty,
		assocs);
};
var $elm$core$Maybe$Just = function (a) {
	return {$: 'Just', a: a};
};
var $elm$core$Maybe$Nothing = {$: 'Nothing'};
var $elm$core$List$head = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(x);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm$core$String$trim = _String_trim;
var $author$project$Main$overviewString = $elm$core$String$trim('\n[#\n   SquarePants has no import statements: instead, project-wide imports are\n   declared in the `meta` file.\n\n   Among other things, this makes it really easy to flag globals, for example\n   by underscoring them.\n#]\n\n\n# Declare a constant\nnumberOne =\n    1\n\n# Declare a function\naddThreeNumbers x y z =\n    x + y + z\n\n\n# TODO: polymorphism for number types is not yet implemented,\n# so I\'m cheating and adding these aliases.\nalias Int = Number\nalias Float = Number\nalias Vec2 = Number\n\n\n# Declarations can have a type annotation\nfloatSix : Float\nfloatSix =\n    # parens are not needed for calling functions\n    addThreeNumbers 1 2 3\n\n\n# if-then-else always yields a value\nfibonacci : Int -> Int\nfibonacci n =\n    if n < 2 then n else n + fibonacci (n - 1)\n\n\n# operators can be used prefixed, like functions\n# `left - right` becomes `(-) right left`\nsubtractTwoFrom : Vec2 -> Vec2\nsubtractTwoFrom n =\n    (-) 2 n\n\n\n# Square brackets for Lists.\n# All items must be of the same type\nlistOfText : [ Text ]\nlistOfText = [\n    , "Gary"\n    , "Bikini Bottom"\n    , "I\'m ready! Promotion!"\n    ]\n\n\n# `>>` and `<<` are just syntactic sugar, read them as "send to".\n# They help using less parens and help visualizing how a value is\n# transformed step-by-step.\nrepeatHello : Int -> Text\nrepeatHello times =\n    "Hello!"\n        >> List.repeat times\n        >> Text.join ", "\n        >> (..) " And append this text at the end"\n\n\n# When you see `@`, it means "this stuff is mutable"\naverage : List Int -> Float\naverage numbers =\n    # mutable variables can only be local and can\'t leave their scope.\n    # `average` is still a pure function.\n    n @= 0\n    sum @= 0\n\n    # anonymous functions start with `fn`\n    List.each numbers fn x =\n        @n += 1\n        @sum += x\n\n    # division by 0 yields 0\n    sum / n\n\n\n# The argument preceding `@>` is mutable\ngenerateTwoRandomNumbers : Int -> Int -> Random.Seed @> Int & Int\ngenerateTwoRandomNumbers min max seed =\n    # \'&\' is used for tuples\n    Random.number min max @seed & Random.number min max @seed\n\n\n\n# Algebraic Data Types\n\nunion LoadingState payload =\n    , NotRequested\n    , Requested\n    , Error Text\n    , Available payload\n\ngetStatusName : LoadingState payload -> Text\ngetStatusName loadingState =\n    try loadingState as\n        NotRequested then "Not needed"\n        Requested then "Awaiting server response"\n        Error message then "Error: " .. message\n        Available _ then "Successfully loaded"\n\ngetPayload : LoadingState payload -> Maybe payload\ngetPayload loadingState =\n    try loadingState as Available payload then Just payload else Nothing\n\n\n\n# Records\n\nalias Crab = {\n    , name : Text\n    , money : Float\n    }\n\neugeneKrabs : Crab\neugeneKrabs = {\n    , name = "Eugene H. Krabs"\n    , money = 2 #TODO 2_345_678.90\n    }\n\n\n# TODO add a record access example\n\n\nearnMoney : Float -> Crab -> Crab\nearnMoney profit crab =\n    # `.money` is a shorthand for `crab.money`\n    { crab with money = .money + profit }\n\n\n# to-notation\ngetAllHouses : (Text -> Maybe house) -> Maybe { rock : house, moai : house, pineapple : house }\ngetAllHouses getAsset =\n    to = Maybe.andThen\n    getAsset "rock" >> to fn rock =\n    getAsset "moai" >> to fn moai =\n    getAsset "pineapple" >> to fn pineapple =\n       Just { rock, moai, pineapple }\n    ');
var $author$project$Main$languageOverview = _Utils_Tuple2('Language/Overview', $author$project$Main$overviewString);
var $elm$core$Basics$add = _Basics_add;
var $elm$core$Basics$gt = _Utils_gt;
var $elm$core$List$reverse = function (list) {
	return A3($elm$core$List$foldl, $elm$core$List$cons, _List_Nil, list);
};
var $elm$core$List$foldrHelper = F4(
	function (fn, acc, ctr, ls) {
		if (!ls.b) {
			return acc;
		} else {
			var a = ls.a;
			var r1 = ls.b;
			if (!r1.b) {
				return A2(fn, a, acc);
			} else {
				var b = r1.a;
				var r2 = r1.b;
				if (!r2.b) {
					return A2(
						fn,
						a,
						A2(fn, b, acc));
				} else {
					var c = r2.a;
					var r3 = r2.b;
					if (!r3.b) {
						return A2(
							fn,
							a,
							A2(
								fn,
								b,
								A2(fn, c, acc)));
					} else {
						var d = r3.a;
						var r4 = r3.b;
						var res = (ctr > 500) ? A3(
							$elm$core$List$foldl,
							fn,
							acc,
							$elm$core$List$reverse(r4)) : A4($elm$core$List$foldrHelper, fn, acc, ctr + 1, r4);
						return A2(
							fn,
							a,
							A2(
								fn,
								b,
								A2(
									fn,
									c,
									A2(fn, d, res))));
					}
				}
			}
		}
	});
var $elm$core$List$foldr = F3(
	function (fn, acc, ls) {
		return A4($elm$core$List$foldrHelper, fn, acc, 0, ls);
	});
var $elm$core$List$map = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$foldr,
			F2(
				function (x, acc) {
					return A2(
						$elm$core$List$cons,
						f(x),
						acc);
				}),
			_List_Nil,
			xs);
	});
var $elm$core$Tuple$mapSecond = F2(
	function (func, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			x,
			func(y));
	});
var $author$project$Main$metaFileName = 'meta';
var $author$project$Prelude$metaString = '\n    {\n      "sourceDirs": [{\n        "path": "",\n        "moduleExceptions": [{\n          "path": "SPCore",\n          "importAs": "SPCore",\n          "globalValues": [\n            "None",\n            "True",\n            "False"\n          ],\n          "globalTypes": [\n            "None",\n            "Bool",\n            "Text",\n            "List",\n            "Number"\n          ]\n        }, {\n          "path": "SPCore/List",\n          "importAs": "List",\n          "globalValues": [\n          ],\n          "globalTypes": [\n          ]\n        }, {\n          "path": "SPCore/Maybe",\n          "importAs": "Maybe",\n          "globalValues": [\n            "Just",\n            "Nothing"\n          ],\n          "globalTypes": [\n            "Maybe"\n          ]\n        }, {\n          "path": "SPCore/Random",\n          "importAs": "Random",\n          "globalValues": [\n          ],\n          "globalTypes": [\n          ]\n        }, {\n          "path": "SPCore/Text",\n          "importAs": "Text",\n          "globalValues": [\n          ],\n          "globalTypes": [\n          ]\n        }, {\n          "path": "SPCore/Debug",\n          "importAs": "Debug",\n          "globalValues": [\n            "log",\n            "todo"\n          ],\n          "globalTypes": [\n          ]\n        }]\n      }],\n      "libraries": []\n    }\n    ';
var $author$project$Main$moduleList = _Utils_Tuple2('SPCore/List', '\neach : List a -> (a -> b) -> None\neach ls f =\n    try ls as\n        SPCore.Nil then\n            None\n\n        SPCore.Cons head tail then\n            f head\n            each tail f\n\n\nreverse : List a -> List a\nreverse aList =\n    rec ls acc =\n        try ls as\n            SPCore.Nil then\n                acc\n\n            SPCore.Cons head tail then\n                rec tail (SPCore.Cons head acc)\n\n    rec aList []\n\n\nrepeat : Number -> a -> List a\nrepeat n a =\n    rec c acc =\n        if c > 0 then rec (c - 1) (SPCore.Cons a acc) else acc\n\n    rec n []\n        ');
var $author$project$Main$moduleMain = _Utils_Tuple2('Main', '\nresult =\n    # define a function\n    getAssets url =\n      Just << url .. ".jpg"\n\n    # the value of the last statement is returned\n    Language/Overview.getAllHouses getAssets\n      ');
var $author$project$Main$moduleMaybe = _Utils_Tuple2('SPCore/Maybe', '\n      union Maybe a = Nothing, Just a\n\n      andThen : (a -> Maybe b) -> Maybe a -> Maybe b\n      andThen f ma =\n          try ma as\n              Nothing then\n                  Nothing\n              Just a then\n                  f a\n\n      map : (a -> b) -> Maybe a -> Maybe b\n      map f m =\n        try m as\n          Nothing then\n            Nothing\n          Just v then\n            Just (f v)\n        ');
var $author$project$Main$moduleRandom = _Utils_Tuple2('SPCore/Random', '\n[# DOC\n\nComments starting with `DOC` are documentation. =)\n\nThe main codebase always exposes everything.\nOnly libraries can hide types, values and constructors, and they are not yet supported.\n\n#]\nunion Seed = Seed Number\n\n\n[# DOC\n\nThis function is here just to illustrate how to use mutables.\n\nIt\'s very much not a practical pseudo random generator.\n\n#]\nnumber : Number -> Number -> Seed @> Number\nnumber min max wrappedSeed =\n\n    Seed seed = wrappedSeed\n\n    @wrappedSeed :=\n      seed * 4871\n          # TODO implement `modBy` =(\n          # >> modBy 2147483647\n          >> Seed\n\n    # TODO implement `clamp`\n    if seed > max then\n        max\n    else if seed < min then\n        min\n    else\n        seed\n      ');
var $author$project$Main$moduleText = _Utils_Tuple2('SPCore/Text', '\n      fromInt : Number -> Text\n      fromInt n =\n        "<native>"\n\n      join : Text -> List Text -> Text\n      join sep listOfText =\n        try listOfText as\n            SPCore.Nil then\n              ""\n\n            SPCore.Cons head tail then\n              rec ls acc =\n                try ls as\n                  SPCore.Nil then\n                    acc\n                  SPCore.Cons h t then\n                    rec t << acc .. sep .. h\n\n              rec tail head\n        ');
var $elm$core$String$any = _String_any;
var $elm$core$String$length = _String_length;
var $elm$core$Basics$lt = _Utils_lt;
var $elm$core$String$slice = _String_slice;
var $elm$core$String$dropLeft = F2(
	function (n, string) {
		return (n < 1) ? string : A3(
			$elm$core$String$slice,
			n,
			$elm$core$String$length(string),
			string);
	});
var $elm$core$List$filter = F2(
	function (isGood, list) {
		return A3(
			$elm$core$List$foldr,
			F2(
				function (x, xs) {
					return isGood(x) ? A2($elm$core$List$cons, x, xs) : xs;
				}),
			_List_Nil,
			list);
	});
var $elm$core$String$join = F2(
	function (sep, chunks) {
		return A2(
			_String_join,
			sep,
			_List_toArray(chunks));
	});
var $elm$core$String$lines = _String_lines;
var $elm$core$Basics$min = F2(
	function (x, y) {
		return (_Utils_cmp(x, y) < 0) ? x : y;
	});
var $elm$core$List$minimum = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(
			A3($elm$core$List$foldl, $elm$core$Basics$min, x, xs));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm$core$Basics$neq = _Utils_notEqual;
var $elm$core$String$uncons = _String_uncons;
var $elm$core$Maybe$withDefault = F2(
	function (_default, maybe) {
		if (maybe.$ === 'Just') {
			var value = maybe.a;
			return value;
		} else {
			return _default;
		}
	});
var $author$project$Compiler$TestHelpers$unindent = function (multilineString) {
	var lines = $elm$core$String$lines(multilineString);
	var countLeadingSpaces = function (line) {
		var _v0 = $elm$core$String$uncons(line);
		if (_v0.$ === 'Nothing') {
			return 0;
		} else {
			var _v1 = _v0.a;
			var _char = _v1.a;
			var xs = _v1.b;
			if (' ' === _char.valueOf()) {
				return 1 + countLeadingSpaces(xs);
			} else {
				return 0;
			}
		}
	};
	var minLead = A2(
		$elm$core$Maybe$withDefault,
		0,
		$elm$core$List$minimum(
			A2(
				$elm$core$List$map,
				countLeadingSpaces,
				A2(
					$elm$core$List$filter,
					$elm$core$String$any(
						$elm$core$Basics$neq(
							_Utils_chr(' '))),
					lines))));
	return A2(
		$elm$core$String$join,
		'\n',
		A2(
			$elm$core$List$map,
			$elm$core$String$dropLeft(minLead),
			lines));
};
var $author$project$Main$initialFiles = A2(
	$elm$core$List$map,
	$elm$core$Tuple$mapSecond($author$project$Compiler$TestHelpers$unindent),
	_List_fromArray(
		[
			$author$project$Main$moduleMain,
			$author$project$Main$moduleMaybe,
			$author$project$Main$moduleList,
			$author$project$Main$moduleText,
			$author$project$Main$moduleRandom,
			$author$project$Main$languageOverview,
			_Utils_Tuple2($author$project$Main$metaFileName, $author$project$Prelude$metaString)
		]));
var $elm$core$Maybe$map = F2(
	function (f, maybe) {
		if (maybe.$ === 'Just') {
			var value = maybe.a;
			return $elm$core$Maybe$Just(
				f(value));
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Main$init = {
	files: $elm$core$Dict$fromList($author$project$Main$initialFiles),
	selectedFile: A2(
		$elm$core$Maybe$withDefault,
		'',
		A2(
			$elm$core$Maybe$map,
			$elm$core$Tuple$first,
			$elm$core$List$head($author$project$Main$initialFiles)))
};
var $elm$core$Result$Err = function (a) {
	return {$: 'Err', a: a};
};
var $elm$json$Json$Decode$Failure = F2(
	function (a, b) {
		return {$: 'Failure', a: a, b: b};
	});
var $elm$json$Json$Decode$Field = F2(
	function (a, b) {
		return {$: 'Field', a: a, b: b};
	});
var $elm$json$Json$Decode$Index = F2(
	function (a, b) {
		return {$: 'Index', a: a, b: b};
	});
var $elm$core$Result$Ok = function (a) {
	return {$: 'Ok', a: a};
};
var $elm$json$Json$Decode$OneOf = function (a) {
	return {$: 'OneOf', a: a};
};
var $elm$core$Basics$False = {$: 'False'};
var $elm$core$String$all = _String_all;
var $elm$core$Basics$and = _Basics_and;
var $elm$core$Basics$append = _Utils_append;
var $elm$json$Json$Encode$encode = _Json_encode;
var $elm$core$String$fromInt = _String_fromNumber;
var $elm$core$String$split = F2(
	function (sep, string) {
		return _List_fromArray(
			A2(_String_split, sep, string));
	});
var $elm$json$Json$Decode$indent = function (str) {
	return A2(
		$elm$core$String$join,
		'\n    ',
		A2($elm$core$String$split, '\n', str));
};
var $elm$core$List$length = function (xs) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (_v0, i) {
				return i + 1;
			}),
		0,
		xs);
};
var $elm$core$List$map2 = _List_map2;
var $elm$core$Basics$le = _Utils_le;
var $elm$core$Basics$sub = _Basics_sub;
var $elm$core$List$rangeHelp = F3(
	function (lo, hi, list) {
		rangeHelp:
		while (true) {
			if (_Utils_cmp(lo, hi) < 1) {
				var $temp$lo = lo,
					$temp$hi = hi - 1,
					$temp$list = A2($elm$core$List$cons, hi, list);
				lo = $temp$lo;
				hi = $temp$hi;
				list = $temp$list;
				continue rangeHelp;
			} else {
				return list;
			}
		}
	});
var $elm$core$List$range = F2(
	function (lo, hi) {
		return A3($elm$core$List$rangeHelp, lo, hi, _List_Nil);
	});
var $elm$core$List$indexedMap = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$map2,
			f,
			A2(
				$elm$core$List$range,
				0,
				$elm$core$List$length(xs) - 1),
			xs);
	});
var $elm$core$Char$toCode = _Char_toCode;
var $elm$core$Char$isLower = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (97 <= code) && (code <= 122);
};
var $elm$core$Char$isUpper = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (code <= 90) && (65 <= code);
};
var $elm$core$Basics$or = _Basics_or;
var $elm$core$Char$isAlpha = function (_char) {
	return $elm$core$Char$isLower(_char) || $elm$core$Char$isUpper(_char);
};
var $elm$core$Char$isDigit = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (code <= 57) && (48 <= code);
};
var $elm$core$Char$isAlphaNum = function (_char) {
	return $elm$core$Char$isLower(_char) || ($elm$core$Char$isUpper(_char) || $elm$core$Char$isDigit(_char));
};
var $elm$json$Json$Decode$errorOneOf = F2(
	function (i, error) {
		return '\n\n(' + ($elm$core$String$fromInt(i + 1) + (') ' + $elm$json$Json$Decode$indent(
			$elm$json$Json$Decode$errorToString(error))));
	});
var $elm$json$Json$Decode$errorToString = function (error) {
	return A2($elm$json$Json$Decode$errorToStringHelp, error, _List_Nil);
};
var $elm$json$Json$Decode$errorToStringHelp = F2(
	function (error, context) {
		errorToStringHelp:
		while (true) {
			switch (error.$) {
				case 'Field':
					var f = error.a;
					var err = error.b;
					var isSimple = function () {
						var _v1 = $elm$core$String$uncons(f);
						if (_v1.$ === 'Nothing') {
							return false;
						} else {
							var _v2 = _v1.a;
							var _char = _v2.a;
							var rest = _v2.b;
							return $elm$core$Char$isAlpha(_char) && A2($elm$core$String$all, $elm$core$Char$isAlphaNum, rest);
						}
					}();
					var fieldName = isSimple ? ('.' + f) : ('[\'' + (f + '\']'));
					var $temp$error = err,
						$temp$context = A2($elm$core$List$cons, fieldName, context);
					error = $temp$error;
					context = $temp$context;
					continue errorToStringHelp;
				case 'Index':
					var i = error.a;
					var err = error.b;
					var indexName = '[' + ($elm$core$String$fromInt(i) + ']');
					var $temp$error = err,
						$temp$context = A2($elm$core$List$cons, indexName, context);
					error = $temp$error;
					context = $temp$context;
					continue errorToStringHelp;
				case 'OneOf':
					var errors = error.a;
					if (!errors.b) {
						return 'Ran into a Json.Decode.oneOf with no possibilities' + function () {
							if (!context.b) {
								return '!';
							} else {
								return ' at json' + A2(
									$elm$core$String$join,
									'',
									$elm$core$List$reverse(context));
							}
						}();
					} else {
						if (!errors.b.b) {
							var err = errors.a;
							var $temp$error = err,
								$temp$context = context;
							error = $temp$error;
							context = $temp$context;
							continue errorToStringHelp;
						} else {
							var starter = function () {
								if (!context.b) {
									return 'Json.Decode.oneOf';
								} else {
									return 'The Json.Decode.oneOf at json' + A2(
										$elm$core$String$join,
										'',
										$elm$core$List$reverse(context));
								}
							}();
							var introduction = starter + (' failed in the following ' + ($elm$core$String$fromInt(
								$elm$core$List$length(errors)) + ' ways:'));
							return A2(
								$elm$core$String$join,
								'\n\n',
								A2(
									$elm$core$List$cons,
									introduction,
									A2($elm$core$List$indexedMap, $elm$json$Json$Decode$errorOneOf, errors)));
						}
					}
				default:
					var msg = error.a;
					var json = error.b;
					var introduction = function () {
						if (!context.b) {
							return 'Problem with the given value:\n\n';
						} else {
							return 'Problem with the value at json' + (A2(
								$elm$core$String$join,
								'',
								$elm$core$List$reverse(context)) + ':\n\n    ');
						}
					}();
					return introduction + ($elm$json$Json$Decode$indent(
						A2($elm$json$Json$Encode$encode, 4, json)) + ('\n\n' + msg));
			}
		}
	});
var $elm$core$Array$branchFactor = 32;
var $elm$core$Array$Array_elm_builtin = F4(
	function (a, b, c, d) {
		return {$: 'Array_elm_builtin', a: a, b: b, c: c, d: d};
	});
var $elm$core$Elm$JsArray$empty = _JsArray_empty;
var $elm$core$Basics$ceiling = _Basics_ceiling;
var $elm$core$Basics$fdiv = _Basics_fdiv;
var $elm$core$Basics$logBase = F2(
	function (base, number) {
		return _Basics_log(number) / _Basics_log(base);
	});
var $elm$core$Basics$toFloat = _Basics_toFloat;
var $elm$core$Array$shiftStep = $elm$core$Basics$ceiling(
	A2($elm$core$Basics$logBase, 2, $elm$core$Array$branchFactor));
var $elm$core$Array$empty = A4($elm$core$Array$Array_elm_builtin, 0, $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, $elm$core$Elm$JsArray$empty);
var $elm$core$Elm$JsArray$initialize = _JsArray_initialize;
var $elm$core$Array$Leaf = function (a) {
	return {$: 'Leaf', a: a};
};
var $elm$core$Basics$apL = F2(
	function (f, x) {
		return f(x);
	});
var $elm$core$Basics$eq = _Utils_equal;
var $elm$core$Basics$floor = _Basics_floor;
var $elm$core$Elm$JsArray$length = _JsArray_length;
var $elm$core$Basics$max = F2(
	function (x, y) {
		return (_Utils_cmp(x, y) > 0) ? x : y;
	});
var $elm$core$Basics$mul = _Basics_mul;
var $elm$core$Array$SubTree = function (a) {
	return {$: 'SubTree', a: a};
};
var $elm$core$Elm$JsArray$initializeFromList = _JsArray_initializeFromList;
var $elm$core$Array$compressNodes = F2(
	function (nodes, acc) {
		compressNodes:
		while (true) {
			var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodes);
			var node = _v0.a;
			var remainingNodes = _v0.b;
			var newAcc = A2(
				$elm$core$List$cons,
				$elm$core$Array$SubTree(node),
				acc);
			if (!remainingNodes.b) {
				return $elm$core$List$reverse(newAcc);
			} else {
				var $temp$nodes = remainingNodes,
					$temp$acc = newAcc;
				nodes = $temp$nodes;
				acc = $temp$acc;
				continue compressNodes;
			}
		}
	});
var $elm$core$Array$treeFromBuilder = F2(
	function (nodeList, nodeListSize) {
		treeFromBuilder:
		while (true) {
			var newNodeSize = $elm$core$Basics$ceiling(nodeListSize / $elm$core$Array$branchFactor);
			if (newNodeSize === 1) {
				return A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodeList).a;
			} else {
				var $temp$nodeList = A2($elm$core$Array$compressNodes, nodeList, _List_Nil),
					$temp$nodeListSize = newNodeSize;
				nodeList = $temp$nodeList;
				nodeListSize = $temp$nodeListSize;
				continue treeFromBuilder;
			}
		}
	});
var $elm$core$Array$builderToArray = F2(
	function (reverseNodeList, builder) {
		if (!builder.nodeListSize) {
			return A4(
				$elm$core$Array$Array_elm_builtin,
				$elm$core$Elm$JsArray$length(builder.tail),
				$elm$core$Array$shiftStep,
				$elm$core$Elm$JsArray$empty,
				builder.tail);
		} else {
			var treeLen = builder.nodeListSize * $elm$core$Array$branchFactor;
			var depth = $elm$core$Basics$floor(
				A2($elm$core$Basics$logBase, $elm$core$Array$branchFactor, treeLen - 1));
			var correctNodeList = reverseNodeList ? $elm$core$List$reverse(builder.nodeList) : builder.nodeList;
			var tree = A2($elm$core$Array$treeFromBuilder, correctNodeList, builder.nodeListSize);
			return A4(
				$elm$core$Array$Array_elm_builtin,
				$elm$core$Elm$JsArray$length(builder.tail) + treeLen,
				A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep),
				tree,
				builder.tail);
		}
	});
var $elm$core$Basics$idiv = _Basics_idiv;
var $elm$core$Array$initializeHelp = F5(
	function (fn, fromIndex, len, nodeList, tail) {
		initializeHelp:
		while (true) {
			if (fromIndex < 0) {
				return A2(
					$elm$core$Array$builderToArray,
					false,
					{nodeList: nodeList, nodeListSize: (len / $elm$core$Array$branchFactor) | 0, tail: tail});
			} else {
				var leaf = $elm$core$Array$Leaf(
					A3($elm$core$Elm$JsArray$initialize, $elm$core$Array$branchFactor, fromIndex, fn));
				var $temp$fn = fn,
					$temp$fromIndex = fromIndex - $elm$core$Array$branchFactor,
					$temp$len = len,
					$temp$nodeList = A2($elm$core$List$cons, leaf, nodeList),
					$temp$tail = tail;
				fn = $temp$fn;
				fromIndex = $temp$fromIndex;
				len = $temp$len;
				nodeList = $temp$nodeList;
				tail = $temp$tail;
				continue initializeHelp;
			}
		}
	});
var $elm$core$Basics$remainderBy = _Basics_remainderBy;
var $elm$core$Array$initialize = F2(
	function (len, fn) {
		if (len <= 0) {
			return $elm$core$Array$empty;
		} else {
			var tailLen = len % $elm$core$Array$branchFactor;
			var tail = A3($elm$core$Elm$JsArray$initialize, tailLen, len - tailLen, fn);
			var initialFromIndex = (len - tailLen) - $elm$core$Array$branchFactor;
			return A5($elm$core$Array$initializeHelp, fn, initialFromIndex, len, _List_Nil, tail);
		}
	});
var $elm$core$Basics$True = {$: 'True'};
var $elm$core$Result$isOk = function (result) {
	if (result.$ === 'Ok') {
		return true;
	} else {
		return false;
	}
};
var $elm$json$Json$Decode$map = _Json_map1;
var $elm$json$Json$Decode$map2 = _Json_map2;
var $elm$json$Json$Decode$succeed = _Json_succeed;
var $elm$virtual_dom$VirtualDom$toHandlerInt = function (handler) {
	switch (handler.$) {
		case 'Normal':
			return 0;
		case 'MayStopPropagation':
			return 1;
		case 'MayPreventDefault':
			return 2;
		default:
			return 3;
	}
};
var $elm$browser$Browser$External = function (a) {
	return {$: 'External', a: a};
};
var $elm$browser$Browser$Internal = function (a) {
	return {$: 'Internal', a: a};
};
var $elm$core$Basics$identity = function (x) {
	return x;
};
var $elm$browser$Browser$Dom$NotFound = function (a) {
	return {$: 'NotFound', a: a};
};
var $elm$url$Url$Http = {$: 'Http'};
var $elm$url$Url$Https = {$: 'Https'};
var $elm$url$Url$Url = F6(
	function (protocol, host, port_, path, query, fragment) {
		return {fragment: fragment, host: host, path: path, port_: port_, protocol: protocol, query: query};
	});
var $elm$core$String$contains = _String_contains;
var $elm$core$String$indexes = _String_indexes;
var $elm$core$String$isEmpty = function (string) {
	return string === '';
};
var $elm$core$String$left = F2(
	function (n, string) {
		return (n < 1) ? '' : A3($elm$core$String$slice, 0, n, string);
	});
var $elm$core$String$toInt = _String_toInt;
var $elm$url$Url$chompBeforePath = F5(
	function (protocol, path, params, frag, str) {
		if ($elm$core$String$isEmpty(str) || A2($elm$core$String$contains, '@', str)) {
			return $elm$core$Maybe$Nothing;
		} else {
			var _v0 = A2($elm$core$String$indexes, ':', str);
			if (!_v0.b) {
				return $elm$core$Maybe$Just(
					A6($elm$url$Url$Url, protocol, str, $elm$core$Maybe$Nothing, path, params, frag));
			} else {
				if (!_v0.b.b) {
					var i = _v0.a;
					var _v1 = $elm$core$String$toInt(
						A2($elm$core$String$dropLeft, i + 1, str));
					if (_v1.$ === 'Nothing') {
						return $elm$core$Maybe$Nothing;
					} else {
						var port_ = _v1;
						return $elm$core$Maybe$Just(
							A6(
								$elm$url$Url$Url,
								protocol,
								A2($elm$core$String$left, i, str),
								port_,
								path,
								params,
								frag));
					}
				} else {
					return $elm$core$Maybe$Nothing;
				}
			}
		}
	});
var $elm$url$Url$chompBeforeQuery = F4(
	function (protocol, params, frag, str) {
		if ($elm$core$String$isEmpty(str)) {
			return $elm$core$Maybe$Nothing;
		} else {
			var _v0 = A2($elm$core$String$indexes, '/', str);
			if (!_v0.b) {
				return A5($elm$url$Url$chompBeforePath, protocol, '/', params, frag, str);
			} else {
				var i = _v0.a;
				return A5(
					$elm$url$Url$chompBeforePath,
					protocol,
					A2($elm$core$String$dropLeft, i, str),
					params,
					frag,
					A2($elm$core$String$left, i, str));
			}
		}
	});
var $elm$url$Url$chompBeforeFragment = F3(
	function (protocol, frag, str) {
		if ($elm$core$String$isEmpty(str)) {
			return $elm$core$Maybe$Nothing;
		} else {
			var _v0 = A2($elm$core$String$indexes, '?', str);
			if (!_v0.b) {
				return A4($elm$url$Url$chompBeforeQuery, protocol, $elm$core$Maybe$Nothing, frag, str);
			} else {
				var i = _v0.a;
				return A4(
					$elm$url$Url$chompBeforeQuery,
					protocol,
					$elm$core$Maybe$Just(
						A2($elm$core$String$dropLeft, i + 1, str)),
					frag,
					A2($elm$core$String$left, i, str));
			}
		}
	});
var $elm$url$Url$chompAfterProtocol = F2(
	function (protocol, str) {
		if ($elm$core$String$isEmpty(str)) {
			return $elm$core$Maybe$Nothing;
		} else {
			var _v0 = A2($elm$core$String$indexes, '#', str);
			if (!_v0.b) {
				return A3($elm$url$Url$chompBeforeFragment, protocol, $elm$core$Maybe$Nothing, str);
			} else {
				var i = _v0.a;
				return A3(
					$elm$url$Url$chompBeforeFragment,
					protocol,
					$elm$core$Maybe$Just(
						A2($elm$core$String$dropLeft, i + 1, str)),
					A2($elm$core$String$left, i, str));
			}
		}
	});
var $elm$core$String$startsWith = _String_startsWith;
var $elm$url$Url$fromString = function (str) {
	return A2($elm$core$String$startsWith, 'http://', str) ? A2(
		$elm$url$Url$chompAfterProtocol,
		$elm$url$Url$Http,
		A2($elm$core$String$dropLeft, 7, str)) : (A2($elm$core$String$startsWith, 'https://', str) ? A2(
		$elm$url$Url$chompAfterProtocol,
		$elm$url$Url$Https,
		A2($elm$core$String$dropLeft, 8, str)) : $elm$core$Maybe$Nothing);
};
var $elm$core$Basics$never = function (_v0) {
	never:
	while (true) {
		var nvr = _v0.a;
		var $temp$_v0 = nvr;
		_v0 = $temp$_v0;
		continue never;
	}
};
var $elm$core$Task$Perform = function (a) {
	return {$: 'Perform', a: a};
};
var $elm$core$Task$succeed = _Scheduler_succeed;
var $elm$core$Task$init = $elm$core$Task$succeed(_Utils_Tuple0);
var $elm$core$Task$andThen = _Scheduler_andThen;
var $elm$core$Task$map = F2(
	function (func, taskA) {
		return A2(
			$elm$core$Task$andThen,
			function (a) {
				return $elm$core$Task$succeed(
					func(a));
			},
			taskA);
	});
var $elm$core$Task$map2 = F3(
	function (func, taskA, taskB) {
		return A2(
			$elm$core$Task$andThen,
			function (a) {
				return A2(
					$elm$core$Task$andThen,
					function (b) {
						return $elm$core$Task$succeed(
							A2(func, a, b));
					},
					taskB);
			},
			taskA);
	});
var $elm$core$Task$sequence = function (tasks) {
	return A3(
		$elm$core$List$foldr,
		$elm$core$Task$map2($elm$core$List$cons),
		$elm$core$Task$succeed(_List_Nil),
		tasks);
};
var $elm$core$Platform$sendToApp = _Platform_sendToApp;
var $elm$core$Task$spawnCmd = F2(
	function (router, _v0) {
		var task = _v0.a;
		return _Scheduler_spawn(
			A2(
				$elm$core$Task$andThen,
				$elm$core$Platform$sendToApp(router),
				task));
	});
var $elm$core$Task$onEffects = F3(
	function (router, commands, state) {
		return A2(
			$elm$core$Task$map,
			function (_v0) {
				return _Utils_Tuple0;
			},
			$elm$core$Task$sequence(
				A2(
					$elm$core$List$map,
					$elm$core$Task$spawnCmd(router),
					commands)));
	});
var $elm$core$Task$onSelfMsg = F3(
	function (_v0, _v1, _v2) {
		return $elm$core$Task$succeed(_Utils_Tuple0);
	});
var $elm$core$Task$cmdMap = F2(
	function (tagger, _v0) {
		var task = _v0.a;
		return $elm$core$Task$Perform(
			A2($elm$core$Task$map, tagger, task));
	});
_Platform_effectManagers['Task'] = _Platform_createManager($elm$core$Task$init, $elm$core$Task$onEffects, $elm$core$Task$onSelfMsg, $elm$core$Task$cmdMap);
var $elm$core$Task$command = _Platform_leaf('Task');
var $elm$core$Task$perform = F2(
	function (toMessage, task) {
		return $elm$core$Task$command(
			$elm$core$Task$Perform(
				A2($elm$core$Task$map, toMessage, task)));
	});
var $elm$core$Platform$Cmd$batch = _Platform_batch;
var $elm$core$Platform$Cmd$none = $elm$core$Platform$Cmd$batch(_List_Nil);
var $elm$core$Platform$Sub$batch = _Platform_batch;
var $elm$core$Platform$Sub$none = $elm$core$Platform$Sub$batch(_List_Nil);
var $elm$browser$Browser$sandbox = function (impl) {
	return _Browser_element(
		{
			init: function (_v0) {
				return _Utils_Tuple2(impl.init, $elm$core$Platform$Cmd$none);
			},
			subscriptions: function (_v1) {
				return $elm$core$Platform$Sub$none;
			},
			update: F2(
				function (msg, model) {
					return _Utils_Tuple2(
						A2(impl.update, msg, model),
						$elm$core$Platform$Cmd$none);
				}),
			view: impl.view
		});
};
var $author$project$Main$update = F2(
	function (msg, model) {
		if (msg.$ === 'OnInput') {
			var code = msg.a;
			return _Utils_update(
				model,
				{
					files: A3($elm$core$Dict$insert, model.selectedFile, code, model.files)
				});
		} else {
			var name = msg.a;
			return _Utils_update(
				model,
				{selectedFile: name});
		}
	});
var $elm$json$Json$Encode$string = _Json_wrap;
var $elm$html$Html$Attributes$stringProperty = F2(
	function (key, string) {
		return A2(
			_VirtualDom_property,
			key,
			$elm$json$Json$Encode$string(string));
	});
var $elm$html$Html$Attributes$class = $elm$html$Html$Attributes$stringProperty('className');
var $author$project$Css$css = '\n.row { display: flex; }\n.col { display: flex; flex-direction: column; }\n\n.mt { margin-top: 1em; }\n.mb { margin-bottom: 1em; }\n.ml { margin-left: 1em; }\n.mr { margin-right: 1em; }\n\n.p { padding: 1em; }\n\n.header {\n  font-family: sans;\n  font-weight: bold;\n}\n\n.border { border: 1px solid lightgray; }\n\n.thirds > * {\n  max-width: 90vw;\n}\n\n\nbody {\n  background: #151515;\n  color: lightgray;\n}\n\n*, *::before, *::after {\n  box-sizing: border-box;\n}\n\n\n\n.editor {\n  border: 1px solid gray;\n}\n\n\n.editor-content {\n  position: relative;\n  background: #151515;\n\n  margin-left: 8px;\n}\n\n.editor-overlay, .editor-textarea {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  width: 100%;\n}\n\n\n.editor-overlay, .editor-textarea, .editor-line-numbers {\n  height: 100%;\n\n  margin: 0;\n  resize: none;\n  border: none;\n  outline: none;\n  background: none;\n\n  padding: 2px;\n  font-size: 14px;\n  font-family: monospace;\n  white-space: pre;\n\n  caret-color: #c6b6ee;\n}\n\n.editor-overlay {\n  pointer-events: none;\n}\n\n.editor-line-numbers {\n  text-align: right;\n}\n\n/* from https://github.com/metalelf0/jellybeans-nvim/blob/main/lua/lush_theme/jellybeans-nvim.lua */\n.valueLo  { color: #81c0df; }\n.globalLo { color: #81c0df; text-decoration: underline; }\n\n.valueUp  { color: #fad07a; }\n.globalUp { color: #fad07a; text-decoration: underline; }\n\n.comment  { color: #888888; }\n\n.literal  { color: #de6240; }\n\n.mutable  { color: #fe99c0; }\n.op       { color: #ffcd6; }\n.keyword  { color: #ee8eff; }\n.paren    { color: #4f9631; }\n\n\n    ';
var $elm$html$Html$div = _VirtualDom_node('div');
var $elm$virtual_dom$VirtualDom$node = function (tag) {
	return _VirtualDom_node(
		_VirtualDom_noScript(tag));
};
var $elm$html$Html$node = $elm$virtual_dom$VirtualDom$node;
var $elm$virtual_dom$VirtualDom$text = _VirtualDom_text;
var $elm$html$Html$text = $elm$virtual_dom$VirtualDom$text;
var $author$project$Main$OnSelect = function (a) {
	return {$: 'OnSelect', a: a};
};
var $elm$html$Html$button = _VirtualDom_node('button');
var $elm$json$Json$Encode$bool = _Json_wrap;
var $elm$html$Html$Attributes$boolProperty = F2(
	function (key, bool) {
		return A2(
			_VirtualDom_property,
			key,
			$elm$json$Json$Encode$bool(bool));
	});
var $elm$html$Html$Attributes$disabled = $elm$html$Html$Attributes$boolProperty('disabled');
var $elm$virtual_dom$VirtualDom$Normal = function (a) {
	return {$: 'Normal', a: a};
};
var $elm$virtual_dom$VirtualDom$on = _VirtualDom_on;
var $elm$html$Html$Events$on = F2(
	function (event, decoder) {
		return A2(
			$elm$virtual_dom$VirtualDom$on,
			event,
			$elm$virtual_dom$VirtualDom$Normal(decoder));
	});
var $elm$html$Html$Events$onClick = function (msg) {
	return A2(
		$elm$html$Html$Events$on,
		'click',
		$elm$json$Json$Decode$succeed(msg));
};
var $elm$core$List$sortBy = _List_sortBy;
var $elm$core$List$sort = function (xs) {
	return A2($elm$core$List$sortBy, $elm$core$Basics$identity, xs);
};
var $author$project$Main$viewFilesSelector = function (model) {
	var viewButton = function (name) {
		return A2(
			$elm$html$Html$button,
			_List_fromArray(
				[
					$elm$html$Html$Events$onClick(
					$author$project$Main$OnSelect(name)),
					$elm$html$Html$Attributes$disabled(
					_Utils_eq(model.selectedFile, name)),
					$elm$html$Html$Attributes$class('ml')
				]),
			_List_fromArray(
				[
					_Utils_eq(name, $author$project$Main$metaFileName) ? $elm$html$Html$text(name + '.json') : $elm$html$Html$text(name + '.sp')
				]));
	};
	return A2(
		$elm$html$Html$div,
		_List_fromArray(
			[
				$elm$html$Html$Attributes$class('row mt')
			]),
		A2(
			$elm$core$List$map,
			viewButton,
			A2(
				$elm$core$List$cons,
				$author$project$Main$metaFileName,
				$elm$core$List$sort(
					A2(
						$elm$core$List$filter,
						$elm$core$Basics$neq($author$project$Main$metaFileName),
						$elm$core$Dict$keys(model.files))))));
};
var $author$project$Types$CanonicalAst$Alias = function (a) {
	return {$: 'Alias', a: a};
};
var $author$project$Types$CanonicalAst$Union = function (a) {
	return {$: 'Union', a: a};
};
var $author$project$Types$CanonicalAst$Value = function (a) {
	return {$: 'Value', a: a};
};
var $elm$core$Set$Set_elm_builtin = function (a) {
	return {$: 'Set_elm_builtin', a: a};
};
var $elm$core$Set$empty = $elm$core$Set$Set_elm_builtin($elm$core$Dict$empty);
var $elm$core$Dict$foldl = F3(
	function (func, acc, dict) {
		foldl:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var key = dict.b;
				var value = dict.c;
				var left = dict.d;
				var right = dict.e;
				var $temp$func = func,
					$temp$acc = A3(
					func,
					key,
					value,
					A3($elm$core$Dict$foldl, func, acc, left)),
					$temp$dict = right;
				func = $temp$func;
				acc = $temp$acc;
				dict = $temp$dict;
				continue foldl;
			}
		}
	});
var $elm$core$Dict$singleton = F2(
	function (key, value) {
		return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
	});
var $elm$core$Set$singleton = function (key) {
	return $elm$core$Set$Set_elm_builtin(
		A2($elm$core$Dict$singleton, key, _Utils_Tuple0));
};
var $elm$core$Dict$union = F2(
	function (t1, t2) {
		return A3($elm$core$Dict$foldl, $elm$core$Dict$insert, t2, t1);
	});
var $elm$core$Set$union = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$union, dict1, dict2));
	});
var $author$project$Compiler$ApplyAliases$findAllRefs_type = function (ty) {
	findAllRefs_type:
	while (true) {
		switch (ty.$) {
			case 'TypeConstant':
				var pos = ty.a;
				var ref = ty.b;
				var args = ty.c;
				return A3(
					$elm$core$List$foldl,
					function (ar) {
						return $elm$core$Set$union(
							$author$project$Compiler$ApplyAliases$findAllRefs_type(ar));
					},
					$elm$core$Set$singleton(ref),
					args);
			case 'TypeVariable':
				var pos = ty.a;
				var name = ty.b;
				return $elm$core$Set$empty;
			case 'TypeFunction':
				var pos = ty.a;
				var from = ty.b;
				var maybeMut = ty.c;
				var to = ty.d;
				return A2(
					$elm$core$Set$union,
					$author$project$Compiler$ApplyAliases$findAllRefs_type(from),
					$author$project$Compiler$ApplyAliases$findAllRefs_type(to));
			case 'TypeRecord':
				var pos = ty.a;
				var extensible = ty.b;
				var attrs = ty.c;
				return A3(
					$elm$core$Dict$foldl,
					F2(
						function (name, t) {
							return $elm$core$Set$union(
								$author$project$Compiler$ApplyAliases$findAllRefs_type(t));
						}),
					$elm$core$Set$empty,
					attrs);
			default:
				var pos = ty.a;
				var path = ty.b;
				var t = ty.c;
				var $temp$ty = t;
				ty = $temp$ty;
				continue findAllRefs_type;
		}
	}
};
var $author$project$Compiler$ApplyAliases$findAllRefs_alias = function (al) {
	return $author$project$Compiler$ApplyAliases$findAllRefs_type(al.ty);
};
var $author$project$Lib$list_foldlRes = F3(
	function (f, ls, accum) {
		list_foldlRes:
		while (true) {
			if (!ls.b) {
				return $elm$core$Result$Ok(accum);
			} else {
				var head = ls.a;
				var tail = ls.b;
				var _v1 = A2(f, head, accum);
				if (_v1.$ === 'Err') {
					var x = _v1.a;
					return $elm$core$Result$Err(x);
				} else {
					var newAccum = _v1.a;
					var $temp$f = f,
						$temp$ls = tail,
						$temp$accum = newAccum;
					f = $temp$f;
					ls = $temp$ls;
					accum = $temp$accum;
					continue list_foldlRes;
				}
			}
		}
	});
var $author$project$Types$Error$Simple = function (a) {
	return {$: 'Simple', a: a};
};
var $author$project$Types$Error$makeError = F2(
	function (file, content) {
		return $author$project$Types$Error$Simple(
			{content: content, file: file});
	});
var $author$project$Types$Error$makeRes = F2(
	function (file, content) {
		return $elm$core$Result$Err(
			A2($author$project$Types$Error$makeError, file, content));
	});
var $author$project$Types$Error$Text = function (a) {
	return {$: 'Text', a: a};
};
var $author$project$Types$Error$text = $author$project$Types$Error$Text;
var $author$project$Types$Error$errorTodo = function (s) {
	return A2(
		$author$project$Types$Error$makeRes,
		'TODO',
		_List_fromArray(
			[
				$author$project$Types$Error$text(s)
			]));
};
var $elm$core$Dict$get = F2(
	function (targetKey, dict) {
		get:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return $elm$core$Maybe$Nothing;
			} else {
				var key = dict.b;
				var value = dict.c;
				var left = dict.d;
				var right = dict.e;
				var _v1 = A2($elm$core$Basics$compare, targetKey, key);
				switch (_v1.$) {
					case 'LT':
						var $temp$targetKey = targetKey,
							$temp$dict = left;
						targetKey = $temp$targetKey;
						dict = $temp$dict;
						continue get;
					case 'EQ':
						return $elm$core$Maybe$Just(value);
					default:
						var $temp$targetKey = targetKey,
							$temp$dict = right;
						targetKey = $temp$targetKey;
						dict = $temp$dict;
						continue get;
				}
			}
		}
	});
var $elm$core$Dict$member = F2(
	function (key, dict) {
		var _v0 = A2($elm$core$Dict$get, key, dict);
		if (_v0.$ === 'Just') {
			return true;
		} else {
			return false;
		}
	});
var $author$project$Types$CanonicalAst$TypeAlias = F3(
	function (a, b, c) {
		return {$: 'TypeAlias', a: a, b: b, c: c};
	});
var $author$project$Types$CanonicalAst$TypeConstant = F3(
	function (a, b, c) {
		return {$: 'TypeConstant', a: a, b: b, c: c};
	});
var $author$project$Types$CanonicalAst$TypeFunction = F4(
	function (a, b, c, d) {
		return {$: 'TypeFunction', a: a, b: b, c: c, d: d};
	});
var $author$project$Types$CanonicalAst$TypeRecord = F3(
	function (a, b, c) {
		return {$: 'TypeRecord', a: a, b: b, c: c};
	});
var $elm$core$Result$andThen = F2(
	function (callback, result) {
		if (result.$ === 'Ok') {
			var value = result.a;
			return callback(value);
		} else {
			var msg = result.a;
			return $elm$core$Result$Err(msg);
		}
	});
var $author$project$Lib$dict_foldRes = F3(
	function (f, dict, accum) {
		return A3(
			$elm$core$Dict$foldl,
			F2(
				function (k, v) {
					return $elm$core$Result$andThen(
						A2(f, k, v));
				}),
			$elm$core$Result$Ok(accum),
			dict);
	});
var $elm$core$Result$map = F2(
	function (func, ra) {
		if (ra.$ === 'Ok') {
			var a = ra.a;
			return $elm$core$Result$Ok(
				func(a));
		} else {
			var e = ra.a;
			return $elm$core$Result$Err(e);
		}
	});
var $author$project$Lib$dict_mapRes = F2(
	function (f, aDict) {
		return A3(
			$author$project$Lib$dict_foldRes,
			F3(
				function (k, a, bAcc) {
					return A2(
						$elm$core$Result$map,
						function (b) {
							return A3($elm$core$Dict$insert, k, b, bAcc);
						},
						A2(f, k, a));
				}),
			aDict,
			$elm$core$Dict$empty);
	});
var $elm$core$Dict$map = F2(
	function (func, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		} else {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				key,
				A2(func, key, value),
				A2($elm$core$Dict$map, func, left),
				A2($elm$core$Dict$map, func, right));
		}
	});
var $author$project$Compiler$ApplyAliases$expandAliasVariables = F2(
	function (typeByArgName, ty) {
		switch (ty.$) {
			case 'TypeVariable':
				var pos = ty.a;
				var name = ty.b;
				var _v1 = A2($elm$core$Dict$get, name, typeByArgName);
				if (_v1.$ === 'Nothing') {
					return ty;
				} else {
					var t = _v1.a;
					return t;
				}
			case 'TypeFunction':
				var pos = ty.a;
				var from = ty.b;
				var fromIsMutable = ty.c;
				var to = ty.d;
				return A4(
					$author$project$Types$CanonicalAst$TypeFunction,
					pos,
					A2($author$project$Compiler$ApplyAliases$expandAliasVariables, typeByArgName, from),
					fromIsMutable,
					A2($author$project$Compiler$ApplyAliases$expandAliasVariables, typeByArgName, to));
			case 'TypeRecord':
				var pos = ty.a;
				var extensible = ty.b;
				var attrs = ty.c;
				return A3(
					$author$project$Types$CanonicalAst$TypeRecord,
					pos,
					extensible,
					A2(
						$elm$core$Dict$map,
						function (k) {
							return $author$project$Compiler$ApplyAliases$expandAliasVariables(typeByArgName);
						},
						attrs));
			case 'TypeConstant':
				var pos = ty.a;
				var ref = ty.b;
				var args = ty.c;
				return A3(
					$author$project$Types$CanonicalAst$TypeConstant,
					pos,
					ref,
					A2(
						$elm$core$List$map,
						$author$project$Compiler$ApplyAliases$expandAliasVariables(typeByArgName),
						args));
			default:
				var pos = ty.a;
				var ref = ty.b;
				var t = ty.c;
				return A3(
					$author$project$Types$CanonicalAst$TypeAlias,
					pos,
					ref,
					A2($author$project$Compiler$ApplyAliases$expandAliasVariables, typeByArgName, t));
		}
	});
var $author$project$Lib$list_mapRes = F2(
	function (f, ls) {
		return A2(
			$elm$core$Result$map,
			$elm$core$List$reverse,
			A3(
				$author$project$Lib$list_foldlRes,
				F2(
					function (a, acc) {
						return A2(
							$elm$core$Result$map,
							function (b) {
								return A2($elm$core$List$cons, b, acc);
							},
							f(a));
					}),
				ls,
				_List_Nil));
	});
var $elm$core$Result$map2 = F3(
	function (func, ra, rb) {
		if (ra.$ === 'Err') {
			var x = ra.a;
			return $elm$core$Result$Err(x);
		} else {
			var a = ra.a;
			if (rb.$ === 'Err') {
				var x = rb.a;
				return $elm$core$Result$Err(x);
			} else {
				var b = rb.a;
				return $elm$core$Result$Ok(
					A2(func, a, b));
			}
		}
	});
var $elm$core$Tuple$pair = F2(
	function (a, b) {
		return _Utils_Tuple2(a, b);
	});
var $author$project$Lib$result_do = F2(
	function (a, b) {
		return A2($elm$core$Result$andThen, b, a);
	});
var $author$project$Compiler$ApplyAliases$replaceType = F2(
	function (ga, ty) {
		switch (ty.$) {
			case 'TypeVariable':
				var pos = ty.a;
				var name = ty.b;
				return $elm$core$Result$Ok(ty);
			case 'TypeFunction':
				var pos = ty.a;
				var from = ty.b;
				var fromIsMutable = ty.c;
				var to = ty.d;
				return A3(
					$elm$core$Result$map2,
					F2(
						function (f, t) {
							return A4($author$project$Types$CanonicalAst$TypeFunction, pos, f, fromIsMutable, t);
						}),
					A2($author$project$Compiler$ApplyAliases$replaceType, ga, from),
					A2($author$project$Compiler$ApplyAliases$replaceType, ga, to));
			case 'TypeRecord':
				var pos = ty.a;
				var extensible = ty.b;
				var attrs = ty.c;
				return A2(
					$elm$core$Result$map,
					A2($author$project$Types$CanonicalAst$TypeRecord, pos, extensible),
					A2(
						$author$project$Lib$dict_mapRes,
						function (k) {
							return $author$project$Compiler$ApplyAliases$replaceType(ga);
						},
						attrs));
			case 'TypeAlias':
				var pos = ty.a;
				var path = ty.b;
				var t = ty.c;
				return $author$project$Types$Error$errorTodo('Did we apply aliases twice?');
			default:
				var pos = ty.a;
				var ref = ty.b;
				var args = ty.c;
				return A2(
					$author$project$Lib$result_do,
					A2(
						$author$project$Lib$list_mapRes,
						$author$project$Compiler$ApplyAliases$replaceType(ga),
						args),
					function (replacedArgs) {
						var _v1 = ga(ref);
						if (_v1.$ === 'Err') {
							var e = _v1.a;
							return $elm$core$Result$Err(e);
						} else {
							if (_v1.a.$ === 'Nothing') {
								var _v2 = _v1.a;
								return $elm$core$Result$Ok(
									A3($author$project$Types$CanonicalAst$TypeConstant, pos, ref, replacedArgs));
							} else {
								var al = _v1.a.a;
								if (!_Utils_eq(
									$elm$core$List$length(al.args),
									$elm$core$List$length(replacedArgs))) {
									return $author$project$Types$Error$errorTodo(
										'alias ' + (al.name + (' needs ' + ($elm$core$String$fromInt(
											$elm$core$List$length(al.args)) + (' args, but was used with ' + $elm$core$String$fromInt(
											$elm$core$List$length(replacedArgs)))))));
								} else {
									var typeByArgName = $elm$core$Dict$fromList(
										A3($elm$core$List$map2, $elm$core$Tuple$pair, al.args, replacedArgs));
									return $elm$core$Result$Ok(
										A3(
											$author$project$Types$CanonicalAst$TypeAlias,
											pos,
											ref,
											A2($author$project$Compiler$ApplyAliases$expandAliasVariables, typeByArgName, al.ty)));
								}
							}
						}
					});
		}
	});
var $author$project$Compiler$ApplyAliases$processAlias = F3(
	function (allAliases, al, processedAliases) {
		var getAlias = function (name) {
			if (A2($elm$core$Dict$member, name, allAliases)) {
				var _v0 = A2($elm$core$Dict$get, name, processedAliases);
				if (_v0.$ === 'Nothing') {
					return $author$project$Types$Error$errorTodo('circular!');
				} else {
					var processedAlias = _v0.a;
					return $elm$core$Result$Ok(
						$elm$core$Maybe$Just(processedAlias));
				}
			} else {
				return $elm$core$Result$Ok($elm$core$Maybe$Nothing);
			}
		};
		return A2(
			$author$project$Lib$result_do,
			A2($author$project$Compiler$ApplyAliases$replaceType, getAlias, al.ty),
			function (ty) {
				return $elm$core$Result$Ok(
					A3(
						$elm$core$Dict$insert,
						al.name,
						_Utils_update(
							al,
							{ty: ty}),
						processedAliases));
			});
	});
var $elm$core$Set$foldl = F3(
	function (func, initialState, _v0) {
		var dict = _v0.a;
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (key, _v1, state) {
					return A2(func, key, state);
				}),
			initialState,
			dict);
	});
var $elm$core$Set$insert = F2(
	function (key, _v0) {
		var dict = _v0.a;
		return $elm$core$Set$Set_elm_builtin(
			A3($elm$core$Dict$insert, key, _Utils_Tuple0, dict));
	});
var $elm$core$Set$fromList = function (list) {
	return A3($elm$core$List$foldl, $elm$core$Set$insert, $elm$core$Set$empty, list);
};
var $elm$core$Dict$filter = F2(
	function (isGood, dict) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, d) {
					return A2(isGood, k, v) ? A3($elm$core$Dict$insert, k, v, d) : d;
				}),
			$elm$core$Dict$empty,
			dict);
	});
var $elm$core$Dict$intersect = F2(
	function (t1, t2) {
		return A2(
			$elm$core$Dict$filter,
			F2(
				function (k, _v0) {
					return A2($elm$core$Dict$member, k, t2);
				}),
			t1);
	});
var $elm$core$Set$intersect = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$intersect, dict1, dict2));
	});
var $elm$core$Set$member = F2(
	function (key, _v0) {
		var dict = _v0.a;
		return A2($elm$core$Dict$member, key, dict);
	});
var $elm$core$List$sortWith = _List_sortWith;
var $author$project$RefHierarchy$reorder = F3(
	function (getName, getSiblingRefs, items) {
		var names = $elm$core$Set$fromList(
			A2($elm$core$List$map, getName, items));
		var referencedSiblings = A3(
			$elm$core$List$foldl,
			function (item) {
				return A2(
					$elm$core$Dict$insert,
					getName(item),
					A2(
						$elm$core$Set$intersect,
						names,
						getSiblingRefs(item)));
			},
			$elm$core$Dict$empty,
			items);
		var findAllNestedSiblingReferences = F2(
			function (name, accum) {
				return A2($elm$core$Set$member, name, accum) ? accum : A3(
					$elm$core$Set$foldl,
					findAllNestedSiblingReferences,
					A2($elm$core$Set$insert, name, accum),
					A2(
						$elm$core$Maybe$withDefault,
						$elm$core$Set$empty,
						A2($elm$core$Dict$get, name, referencedSiblings)));
			});
		var allNestedSiblingRefs = A2(
			$elm$core$Dict$map,
			F2(
				function (k, v) {
					return A2(findAllNestedSiblingReferences, k, $elm$core$Set$empty);
				}),
			referencedSiblings);
		var oneReferencesTwo = F2(
			function (one, two) {
				var _v1 = A2($elm$core$Dict$get, one, allNestedSiblingRefs);
				if (_v1.$ === 'Nothing') {
					return false;
				} else {
					var set = _v1.a;
					return A2($elm$core$Set$member, two, set);
				}
			});
		var order = F2(
			function (aItem, bItem) {
				var b = getName(bItem);
				var a = getName(aItem);
				var _v0 = _Utils_Tuple2(
					A2(oneReferencesTwo, a, b),
					A2(oneReferencesTwo, b, a));
				if (_v0.a) {
					if (_v0.b) {
						return $elm$core$Basics$EQ;
					} else {
						return $elm$core$Basics$GT;
					}
				} else {
					if (_v0.b) {
						return $elm$core$Basics$LT;
					} else {
						return $elm$core$Basics$EQ;
					}
				}
			});
		return A2($elm$core$List$sortWith, order, items);
	});
var $elm$core$Dict$values = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, valueList) {
				return A2($elm$core$List$cons, value, valueList);
			}),
		_List_Nil,
		dict);
};
var $author$project$Compiler$ApplyAliases$applyAliasesToAliases = function (als) {
	var orderedAliases = A3(
		$author$project$RefHierarchy$reorder,
		function ($) {
			return $.name;
		},
		$author$project$Compiler$ApplyAliases$findAllRefs_alias,
		$elm$core$Dict$values(als));
	return A3(
		$author$project$Lib$list_foldlRes,
		$author$project$Compiler$ApplyAliases$processAlias(als),
		orderedAliases,
		$elm$core$Dict$empty);
};
var $author$project$Compiler$ApplyAliases$applyAliasesToUnions = function (aliases) {
	var getAlias = function (name) {
		return $elm$core$Result$Ok(
			A2($elm$core$Dict$get, name, aliases));
	};
	var mapConstructor = F2(
		function (name, args) {
			return A2(
				$author$project$Lib$list_mapRes,
				$author$project$Compiler$ApplyAliases$replaceType(getAlias),
				args);
		});
	var mapUnion = F2(
		function (name, union) {
			return A2(
				$elm$core$Result$map,
				function (cs) {
					return _Utils_update(
						union,
						{constructors: cs});
				},
				A2($author$project$Lib$dict_mapRes, mapConstructor, union.constructors));
		});
	return $author$project$Lib$dict_mapRes(mapUnion);
};
var $author$project$Types$CanonicalAst$ArgumentExpression = function (a) {
	return {$: 'ArgumentExpression', a: a};
};
var $author$project$Types$CanonicalAst$Call = F3(
	function (a, b, c) {
		return {$: 'Call', a: a, b: b, c: c};
	});
var $author$project$Types$CanonicalAst$Definition = function (a) {
	return {$: 'Definition', a: a};
};
var $author$project$Types$CanonicalAst$Evaluation = function (a) {
	return {$: 'Evaluation', a: a};
};
var $author$project$Types$CanonicalAst$If = F2(
	function (a, b) {
		return {$: 'If', a: a, b: b};
	});
var $author$project$Types$CanonicalAst$Lambda = F3(
	function (a, b, c) {
		return {$: 'Lambda', a: a, b: b, c: c};
	});
var $author$project$Types$CanonicalAst$Record = F3(
	function (a, b, c) {
		return {$: 'Record', a: a, b: b, c: c};
	});
var $author$project$Types$CanonicalAst$Try = F3(
	function (a, b, c) {
		return {$: 'Try', a: a, b: b, c: c};
	});
var $elm$core$Result$map3 = F4(
	function (func, ra, rb, rc) {
		if (ra.$ === 'Err') {
			var x = ra.a;
			return $elm$core$Result$Err(x);
		} else {
			var a = ra.a;
			if (rb.$ === 'Err') {
				var x = rb.a;
				return $elm$core$Result$Err(x);
			} else {
				var b = rb.a;
				if (rc.$ === 'Err') {
					var x = rc.a;
					return $elm$core$Result$Err(x);
				} else {
					var c = rc.a;
					return $elm$core$Result$Ok(
						A3(func, a, b, c));
				}
			}
		}
	});
var $author$project$Compiler$ApplyAliases$normalizeAnnotation = F2(
	function (ga, maybeType) {
		if (maybeType.$ === 'Nothing') {
			return $elm$core$Result$Ok($elm$core$Maybe$Nothing);
		} else {
			var ty = maybeType.a;
			return A2(
				$elm$core$Result$map,
				$elm$core$Maybe$Just,
				A2($author$project$Compiler$ApplyAliases$replaceType, ga, ty));
		}
	});
var $author$project$Lib$tuple_mapSecondRes = F2(
	function (f, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2(
			$elm$core$Result$map,
			function (c) {
				return _Utils_Tuple2(a, c);
			},
			f(b));
	});
var $author$project$Compiler$ApplyAliases$normalizeArg = F2(
	function (ga, arg) {
		if (arg.$ === 'ArgumentMutable') {
			return $elm$core$Result$Ok(arg);
		} else {
			var expr = arg.a;
			return A2(
				$elm$core$Result$map,
				$author$project$Types$CanonicalAst$ArgumentExpression,
				A2($author$project$Compiler$ApplyAliases$normalizeExpr, ga, expr));
		}
	});
var $author$project$Compiler$ApplyAliases$normalizeBlock = function (ga) {
	return $author$project$Lib$list_mapRes(
		$author$project$Compiler$ApplyAliases$normalizeStatement(ga));
};
var $author$project$Compiler$ApplyAliases$normalizeExpr = F2(
	function (ga, expr) {
		switch (expr.$) {
			case 'Literal':
				return $elm$core$Result$Ok(expr);
			case 'Variable':
				return $elm$core$Result$Ok(expr);
			case 'Lambda':
				var pos = expr.a;
				var pattern = expr.b;
				var body0 = expr.c;
				return A2(
					$elm$core$Result$map,
					A2($author$project$Types$CanonicalAst$Lambda, pos, pattern),
					A2($author$project$Compiler$ApplyAliases$normalizeBlock, ga, body0));
			case 'Record':
				var pos = expr.a;
				var extend = expr.b;
				var attrs0 = expr.c;
				return A2(
					$elm$core$Result$map,
					A2($author$project$Types$CanonicalAst$Record, pos, extend),
					A2(
						$author$project$Lib$dict_mapRes,
						function (k) {
							return $author$project$Compiler$ApplyAliases$normalizeExpr(ga);
						},
						attrs0));
			case 'Call':
				var pos = expr.a;
				var ref0 = expr.b;
				var arg0 = expr.c;
				return A3(
					$elm$core$Result$map2,
					$author$project$Types$CanonicalAst$Call(pos),
					A2($author$project$Compiler$ApplyAliases$normalizeExpr, ga, ref0),
					A2($author$project$Compiler$ApplyAliases$normalizeArg, ga, arg0));
			case 'If':
				var pos = expr.a;
				var ar = expr.b;
				return A4(
					$elm$core$Result$map3,
					F3(
						function (c, t, f) {
							return A2(
								$author$project$Types$CanonicalAst$If,
								pos,
								{condition: c, _false: f, _true: t});
						}),
					A2($author$project$Compiler$ApplyAliases$normalizeBlock, ga, ar.condition),
					A2($author$project$Compiler$ApplyAliases$normalizeBlock, ga, ar._true),
					A2($author$project$Compiler$ApplyAliases$normalizeBlock, ga, ar._false));
			default:
				var pos = expr.a;
				var value = expr.b;
				var tries = expr.c;
				return A3(
					$elm$core$Result$map2,
					$author$project$Types$CanonicalAst$Try(pos),
					A2($author$project$Compiler$ApplyAliases$normalizeExpr, ga, value),
					A2(
						$author$project$Lib$list_mapRes,
						$author$project$Lib$tuple_mapSecondRes(
							$author$project$Compiler$ApplyAliases$normalizeBlock(ga)),
						tries));
		}
	});
var $author$project$Compiler$ApplyAliases$normalizeStatement = F2(
	function (ga, s) {
		if (s.$ === 'Definition') {
			var vdef = s.a;
			return A2(
				$elm$core$Result$map,
				$author$project$Types$CanonicalAst$Definition,
				A2($author$project$Compiler$ApplyAliases$normalizeValueDef, ga, vdef));
		} else {
			var expr = s.a;
			return A2(
				$elm$core$Result$map,
				$author$project$Types$CanonicalAst$Evaluation,
				A2($author$project$Compiler$ApplyAliases$normalizeExpr, ga, expr));
		}
	});
var $author$project$Compiler$ApplyAliases$normalizeValueDef = F2(
	function (ga, vdef) {
		return A3(
			$elm$core$Result$map2,
			F2(
				function (maybeAnnotation, body) {
					return _Utils_update(
						vdef,
						{body: body, maybeAnnotation: maybeAnnotation});
				}),
			A2($author$project$Compiler$ApplyAliases$normalizeAnnotation, ga, vdef.maybeAnnotation),
			A2($author$project$Compiler$ApplyAliases$normalizeBlock, ga, vdef.body));
	});
var $author$project$Compiler$ApplyAliases$applyAliasesToValues = function (aliases) {
	var ga = function (name) {
		return $elm$core$Result$Ok(
			A2($elm$core$Dict$get, name, aliases));
	};
	return $author$project$Lib$dict_mapRes(
		function (k) {
			return $author$project$Compiler$ApplyAliases$normalizeValueDef(ga);
		});
};
var $author$project$Types$CanonicalAst$split = function () {
	var part3 = F3(
		function (n, rootDef, _v1) {
			var als = _v1.a;
			var uns = _v1.b;
			var vals = _v1.c;
			switch (rootDef.$) {
				case 'Alias':
					var a = rootDef.a;
					return _Utils_Tuple3(
						A3($elm$core$Dict$insert, n, a, als),
						uns,
						vals);
				case 'Union':
					var u = rootDef.a;
					return _Utils_Tuple3(
						als,
						A3($elm$core$Dict$insert, n, u, uns),
						vals);
				default:
					var v = rootDef.a;
					return _Utils_Tuple3(
						als,
						uns,
						A3($elm$core$Dict$insert, n, v, vals));
			}
		});
	return A2(
		$elm$core$Dict$foldl,
		part3,
		_Utils_Tuple3($elm$core$Dict$empty, $elm$core$Dict$empty, $elm$core$Dict$empty));
}();
var $author$project$Compiler$ApplyAliases$applyAliasesToModule = function (mod) {
	var _do = $author$project$Lib$result_do;
	var _v0 = $author$project$Types$CanonicalAst$split(mod);
	var aliases = _v0.a;
	var unions = _v0.b;
	var values = _v0.c;
	return A2(
		_do,
		$author$project$Compiler$ApplyAliases$applyAliasesToAliases(aliases),
		function (resolved_aliases) {
			return A2(
				_do,
				A2($author$project$Compiler$ApplyAliases$applyAliasesToUnions, resolved_aliases, unions),
				function (resolved_unions) {
					return A2(
						_do,
						A2($author$project$Compiler$ApplyAliases$applyAliasesToValues, resolved_aliases, values),
						function (resolved_values) {
							var a0 = $elm$core$Dict$empty;
							var a1 = A3(
								$elm$core$Dict$foldl,
								F2(
									function (k, v) {
										return A2(
											$elm$core$Dict$insert,
											k,
											$author$project$Types$CanonicalAst$Alias(v));
									}),
								a0,
								resolved_aliases);
							var a2 = A3(
								$elm$core$Dict$foldl,
								F2(
									function (k, v) {
										return A2(
											$elm$core$Dict$insert,
											k,
											$author$project$Types$CanonicalAst$Union(v));
									}),
								a1,
								resolved_unions);
							var a3 = A3(
								$elm$core$Dict$foldl,
								F2(
									function (k, v) {
										return A2(
											$elm$core$Dict$insert,
											k,
											$author$project$Types$CanonicalAst$Value(v));
									}),
								a2,
								resolved_values);
							return $elm$core$Result$Ok(a3);
						});
				});
		});
};
var $elm$html$Html$code = _VirtualDom_node('code');
var $elm$core$Bitwise$and = _Bitwise_and;
var $elm$core$Bitwise$shiftRightBy = _Bitwise_shiftRightBy;
var $elm$core$String$repeatHelp = F3(
	function (n, chunk, result) {
		return (n <= 0) ? result : A3(
			$elm$core$String$repeatHelp,
			n >> 1,
			_Utils_ap(chunk, chunk),
			(!(n & 1)) ? result : _Utils_ap(result, chunk));
	});
var $elm$core$String$repeat = F2(
	function (n, chunk) {
		return A3($elm$core$String$repeatHelp, n, chunk, '');
	});
var $author$project$Compiler$JsToString$id = function (level) {
	return A2($elm$core$String$repeat, level, '  ');
};
var $author$project$Compiler$JsToString$emitBlock = F2(
	function (l, block) {
		var lines = A2(
			$elm$core$String$join,
			'\n',
			A2(
				$elm$core$List$map,
				$author$project$Compiler$JsToString$emitStatement(l + 1),
				block));
		return '{\n' + (lines + ('\n' + ($author$project$Compiler$JsToString$id(l) + '}')));
	});
var $author$project$Compiler$JsToString$emitExpr = F2(
	function (l, expression) {
		switch (expression.$) {
			case 'Literal':
				var s = expression.a;
				return s;
			case 'Var':
				var n = expression.a;
				return n;
			case 'Call':
				var ref = expression.a;
				var args = expression.b;
				return '(' + (A2($author$project$Compiler$JsToString$emitExpr, l, ref) + (')(' + (A2(
					$elm$core$String$join,
					', ',
					A2(
						$elm$core$List$map,
						$author$project$Compiler$JsToString$emitExpr(l),
						args)) + ')')));
			case 'Binop':
				var op = expression.a;
				var left = expression.b;
				var right = expression.c;
				return '(' + (A2($author$project$Compiler$JsToString$emitExpr, l, left) + (' ' + (op + (' ' + (A2($author$project$Compiler$JsToString$emitExpr, l, right) + ')')))));
			case 'Mutop':
				var op = expression.a;
				var _yield = expression.b;
				var left = expression.c;
				var right = expression.d;
				return '(' + (A2($author$project$Compiler$JsToString$emitExpr, l, left) + (' ' + (op + (' ' + (A2($author$project$Compiler$JsToString$emitExpr, l, right) + (', ' + (_yield + ')')))))));
			case 'SimpleLambda':
				var params = expression.a;
				var expr = expression.b;
				return '((' + (A2($elm$core$String$join, ', ', params) + (') => ' + (A2($author$project$Compiler$JsToString$emitExpr, l, expr) + ')')));
			case 'BlockLambda':
				var params = expression.a;
				var stats = expression.b;
				return '((' + (A2($elm$core$String$join, ', ', params) + (') => ' + (A2($author$project$Compiler$JsToString$emitBlock, l, stats) + ')')));
			case 'Record':
				var attrs = expression.a;
				return _Utils_eq(attrs, $elm$core$Dict$empty) ? '{}' : function (a) {
					return '({\n' + (A2($elm$core$String$join, '\n', a) + ('\n' + ($author$project$Compiler$JsToString$id(l) + '})')));
				}(
					A2(
						$elm$core$List$map,
						function (_v2) {
							var key = _v2.a;
							var value = _v2.b;
							return $author$project$Compiler$JsToString$id(l + 1) + (key + (': ' + (A2($author$project$Compiler$JsToString$emitExpr, l + 1, value) + ',')));
						},
						A2(
							$elm$core$List$sortBy,
							$elm$core$Tuple$first,
							$elm$core$Dict$toList(attrs))));
			case 'AccessWithDot':
				var name = expression.a;
				var e = expression.b;
				return A2($author$project$Compiler$JsToString$emitExpr, l, e) + ('.' + name);
			case 'AccessWithBrackets':
				var i = expression.a;
				var expr = expression.b;
				return '(' + (A2($author$project$Compiler$JsToString$emitExpr, l, expr) + (')[' + (A2($author$project$Compiler$JsToString$emitExpr, l, i) + ']')));
			case 'Conditional':
				var p = expression.a;
				var _true = expression.b;
				var _false = expression.c;
				return ('(' + (A2($author$project$Compiler$JsToString$emitExpr, l, p) + '\n')) + (($author$project$Compiler$JsToString$id(l + 1) + ('? ' + A2($author$project$Compiler$JsToString$emitExpr, l + 1, _true))) + ('\n' + (($author$project$Compiler$JsToString$id(l + 1) + (': ' + A2($author$project$Compiler$JsToString$emitExpr, l + 1, _false))) + ')')));
			default:
				var items = expression.a;
				return _Utils_eq(items, _List_Nil) ? '[]' : function (a) {
					return '([\n' + (A2($elm$core$String$join, '\n', a) + ('\n' + ($author$project$Compiler$JsToString$id(l) + '])')));
				}(
					A2(
						$elm$core$List$map,
						function (i) {
							return $author$project$Compiler$JsToString$id(l + 1) + (A2($author$project$Compiler$JsToString$emitExpr, l + 1, i) + ',');
						},
						items));
		}
	});
var $author$project$Compiler$JsToString$emitStatement = F2(
	function (l, stat) {
		var std = F2(
			function (mid, expr) {
				return $author$project$Compiler$JsToString$id(l) + (mid + (A2($author$project$Compiler$JsToString$emitExpr, l, expr) + ';'));
			});
		switch (stat.$) {
			case 'Eval':
				var e = stat.a;
				return A2(std, '', e);
			case 'Return':
				var e = stat.a;
				return A2(std, 'return ', e);
			case 'Define':
				var name = stat.a;
				var e = stat.b;
				return A2(std, 'const ' + (name + ' = '), e);
			default:
				var condition = stat.a;
				var block = stat.b;
				return $author$project$Compiler$JsToString$id(l) + ('if (' + (A2($author$project$Compiler$JsToString$emitExpr, l, condition) + (') ' + A2($author$project$Compiler$JsToString$emitBlock, l, block))));
		}
	});
var $elm$core$Basics$composeR = F3(
	function (f, g, x) {
		return g(
			f(x));
	});
var $elm$json$Json$Decode$decodeString = _Json_runOnString;
var $elm$json$Json$Decode$andThen = _Json_andThen;
var $author$project$MetaFile$do = F2(
	function (a, b) {
		return A2($elm$json$Json$Decode$andThen, b, a);
	});
var $elm$json$Json$Decode$field = _Json_decodeField;
var $elm$json$Json$Decode$list = _Json_decodeList;
var $elm$json$Json$Decode$oneOf = _Json_oneOf;
var $elm$json$Json$Decode$maybe = function (decoder) {
	return $elm$json$Json$Decode$oneOf(
		_List_fromArray(
			[
				A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, decoder),
				$elm$json$Json$Decode$succeed($elm$core$Maybe$Nothing)
			]));
};
var $elm$json$Json$Decode$string = _Json_decodeString;
var $author$project$MetaFile$moduleDecoder = A2(
	$author$project$MetaFile$do,
	A2($elm$json$Json$Decode$field, 'path', $elm$json$Json$Decode$string),
	function (path) {
		return A2(
			$author$project$MetaFile$do,
			$elm$json$Json$Decode$maybe(
				A2($elm$json$Json$Decode$field, 'importAs', $elm$json$Json$Decode$string)),
			function (maybeImportAs) {
				return A2(
					$author$project$MetaFile$do,
					$elm$json$Json$Decode$maybe(
						A2(
							$elm$json$Json$Decode$field,
							'globalValues',
							$elm$json$Json$Decode$list($elm$json$Json$Decode$string))),
					function (maybeGlobalValues) {
						return A2(
							$author$project$MetaFile$do,
							$elm$json$Json$Decode$maybe(
								A2(
									$elm$json$Json$Decode$field,
									'globalTypes',
									$elm$json$Json$Decode$list($elm$json$Json$Decode$string))),
							function (maybeGlobalTypes) {
								return $elm$json$Json$Decode$succeed(
									{
										globalTypes: A2($elm$core$Maybe$withDefault, _List_Nil, maybeGlobalTypes),
										globalValues: A2($elm$core$Maybe$withDefault, _List_Nil, maybeGlobalValues),
										importAs: A2($elm$core$Maybe$withDefault, '', maybeImportAs),
										path: path
									});
							});
					});
			});
	});
var $author$project$MetaFile$libraryDecoder = A2(
	$author$project$MetaFile$do,
	A2($elm$json$Json$Decode$field, 'source', $elm$json$Json$Decode$string),
	function (source) {
		return A2(
			$author$project$MetaFile$do,
			A2(
				$elm$json$Json$Decode$field,
				'modules',
				$elm$json$Json$Decode$list($author$project$MetaFile$moduleDecoder)),
			function (modules) {
				return $elm$json$Json$Decode$succeed(
					{modules: modules, source: source});
			});
	});
var $author$project$MetaFile$sourceDirDecoder = A2(
	$author$project$MetaFile$do,
	A2($elm$json$Json$Decode$field, 'path', $elm$json$Json$Decode$string),
	function (path) {
		return A2(
			$author$project$MetaFile$do,
			A2(
				$elm$json$Json$Decode$field,
				'moduleExceptions',
				$elm$json$Json$Decode$list($author$project$MetaFile$moduleDecoder)),
			function (moduleExceptions) {
				return $elm$json$Json$Decode$succeed(
					{moduleExceptions: moduleExceptions, path: path});
			});
	});
var $author$project$MetaFile$fileDecoder = A2(
	$author$project$MetaFile$do,
	A2(
		$elm$json$Json$Decode$field,
		'sourceDirs',
		$elm$json$Json$Decode$list($author$project$MetaFile$sourceDirDecoder)),
	function (sds) {
		return A2(
			$author$project$MetaFile$do,
			A2(
				$elm$json$Json$Decode$field,
				'libraries',
				$elm$json$Json$Decode$list($author$project$MetaFile$libraryDecoder)),
			function (libs) {
				return $elm$json$Json$Decode$succeed(
					{libraries: libs, sourceDirs: sds});
			});
	});
var $elm$core$Result$mapError = F2(
	function (f, result) {
		if (result.$ === 'Ok') {
			var v = result.a;
			return $elm$core$Result$Ok(v);
		} else {
			var e = result.a;
			return $elm$core$Result$Err(
				f(e));
		}
	});
var $author$project$MetaFile$stringToMetaFile = function (json) {
	return A2(
		$elm$core$Result$mapError,
		$elm$json$Json$Decode$errorToString,
		A2($elm$json$Json$Decode$decodeString, $author$project$MetaFile$fileDecoder, json));
};
var $elm$core$List$append = F2(
	function (xs, ys) {
		if (!ys.b) {
			return xs;
		} else {
			return A3($elm$core$List$foldr, $elm$core$List$cons, ys, xs);
		}
	});
var $elm$core$List$concat = function (lists) {
	return A3($elm$core$List$foldr, $elm$core$List$append, _List_Nil, lists);
};
var $elm$core$List$concatMap = F2(
	function (f, list) {
		return $elm$core$List$concat(
			A2($elm$core$List$map, f, list));
	});
var $author$project$Types$Meta$init = {bynames: $elm$core$Dict$empty, globalTypes: $elm$core$Dict$empty, globalValues: $elm$core$Dict$empty};
var $author$project$MetaFile$insertModule = F2(
	function (mod, meta) {
		return {
			bynames: A3($elm$core$Dict$insert, mod.importAs, mod.path, meta.bynames),
			globalTypes: A3(
				$elm$core$List$foldl,
				function (varName) {
					return A2($elm$core$Dict$insert, varName, mod.path + ('.' + varName));
				},
				meta.globalTypes,
				mod.globalTypes),
			globalValues: A3(
				$elm$core$List$foldl,
				function (varName) {
					return A2($elm$core$Dict$insert, varName, mod.path + ('.' + varName));
				},
				meta.globalValues,
				mod.globalValues)
		};
	});
var $author$project$MetaFile$toMeta = function (metaFile) {
	return A3(
		$elm$core$List$foldl,
		$author$project$MetaFile$insertModule,
		$author$project$Types$Meta$init,
		A2(
			$elm$core$List$concatMap,
			function ($) {
				return $.moduleExceptions;
			},
			metaFile.sourceDirs));
};
var $author$project$MetaFile$stringToMeta = A2(
	$elm$core$Basics$composeR,
	$author$project$MetaFile$stringToMetaFile,
	$elm$core$Result$map($author$project$MetaFile$toMeta));
var $author$project$Main$getMeta = function (model) {
	return $elm$core$Basics$identity(
		$author$project$MetaFile$stringToMeta(
			A2(
				$elm$core$Maybe$withDefault,
				'',
				A2($elm$core$Dict$get, $author$project$Main$metaFileName, model.files))));
};
var $elm$html$Html$h6 = _VirtualDom_node('h6');
var $author$project$Types$CanonicalAst$TypeVariable = F2(
	function (a, b) {
		return {$: 'TypeVariable', a: a, b: b};
	});
var $elm$core$Basics$negate = function (n) {
	return -n;
};
var $author$project$Compiler$TypeInference$todoPos = {c: '', e: -1, n: 'ti', s: -1};
var $elm$core$List$maybeCons = F3(
	function (f, mx, xs) {
		var _v0 = f(mx);
		if (_v0.$ === 'Just') {
			var x = _v0.a;
			return A2($elm$core$List$cons, x, xs);
		} else {
			return xs;
		}
	});
var $elm$core$List$filterMap = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$foldr,
			$elm$core$List$maybeCons(f),
			_List_Nil,
			xs);
	});
var $author$project$Compiler$TypeInference$validateType = F2(
	function (mutable, ty) {
		validateType:
		while (true) {
			switch (ty.$) {
				case 'TypeConstant':
					return $elm$core$Maybe$Nothing;
				case 'TypeVariable':
					var name = ty.b;
					return $elm$core$Maybe$Nothing;
				case 'TypeAlias':
					var path = ty.b;
					var t = ty.c;
					var $temp$mutable = mutable,
						$temp$ty = t;
					mutable = $temp$mutable;
					ty = $temp$ty;
					continue validateType;
				case 'TypeFunction':
					var from = ty.b;
					var fromIsMutable = ty.c;
					var to = ty.d;
					if (mutable) {
						return $elm$core$Maybe$Just('mutable values can\'t contain functions');
					} else {
						var _v1 = A2(
							$author$project$Compiler$TypeInference$validateType,
							A2($elm$core$Maybe$withDefault, false, fromIsMutable),
							from);
						if (_v1.$ === 'Just') {
							var e = _v1.a;
							return $elm$core$Maybe$Just(e);
						} else {
							var $temp$mutable = false,
								$temp$ty = to;
							mutable = $temp$mutable;
							ty = $temp$ty;
							continue validateType;
						}
					}
				default:
					var ext = ty.b;
					var attrs = ty.c;
					return $elm$core$List$head(
						A2(
							$elm$core$List$filterMap,
							$author$project$Compiler$TypeInference$validateType(mutable),
							$elm$core$Dict$values(attrs)));
			}
		}
	});
var $author$project$Compiler$TypeInference$addConstructor = F4(
	function (unionDef, ctorName, ctorArgs, env) {
		var fold = F2(
			function (ty, accum) {
				return A4(
					$author$project$Types$CanonicalAst$TypeFunction,
					$author$project$Compiler$TypeInference$todoPos,
					ty,
					$elm$core$Maybe$Just(false),
					accum);
			});
		var args = A2(
			$elm$core$List$map,
			function (name) {
				return A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Compiler$TypeInference$todoPos, name);
			},
			unionDef.args);
		var ctorType = A3(
			$elm$core$List$foldr,
			fold,
			A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TypeInference$todoPos, unionDef.name, args),
			ctorArgs);
		var _v0 = A2($author$project$Compiler$TypeInference$validateType, false, ctorType);
		if (_v0.$ === 'Just') {
			var err = _v0.a;
			return $author$project$Types$Error$errorTodo(err);
		} else {
			return $elm$core$Result$Ok(
				A3(
					$elm$core$Dict$insert,
					ctorName,
					{
						forall: $elm$core$Set$fromList(unionDef.args),
						mutable: $elm$core$Maybe$Just(false),
						type_: ctorType
					},
					env));
		}
	});
var $author$project$Compiler$TypeInference$addConstructors = F2(
	function (rootDef, env) {
		if (rootDef.$ === 'Union') {
			var def = rootDef.a;
			return A3(
				$author$project$Lib$dict_foldRes,
				$author$project$Compiler$TypeInference$addConstructor(def),
				def.constructors,
				env);
		} else {
			return $elm$core$Result$Ok(env);
		}
	});
var $author$project$Generator$Generator = function (a) {
	return {$: 'Generator', a: a};
};
var $author$project$Generator$do = F2(
	function (_v0, f) {
		var genA = _v0.a;
		return $author$project$Generator$Generator(
			function (state) {
				var _v1 = genA(state);
				var result = _v1.a;
				var newState = _v1.b;
				var _v2 = f(result);
				var genB = _v2.a;
				return genB(newState);
			});
	});
var $author$project$Generator$wrap = function (v) {
	return $author$project$Generator$Generator(
		function (state) {
			return _Utils_Tuple2(v, state);
		});
};
var $author$project$Compiler$TypeInference$do_nr = F2(
	function (nra, f) {
		return A2(
			$author$project$Generator$do,
			nra,
			function (ra) {
				if (ra.$ === 'Ok') {
					var a = ra.a;
					return f(a);
				} else {
					var e = ra.a;
					return $author$project$Generator$wrap(
						$elm$core$Result$Err(e));
				}
			});
	});
var $author$project$Types$CanonicalAst$Variable = F2(
	function (a, b) {
		return {$: 'Variable', a: a, b: b};
	});
var $elm$core$Tuple$mapFirst = F2(
	function (func, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			func(x),
			y);
	});
var $author$project$Generator$map = F2(
	function (f, _v0) {
		var genA = _v0.a;
		return $author$project$Generator$Generator(
			A2(
				$elm$core$Basics$composeR,
				genA,
				$elm$core$Tuple$mapFirst(f)));
	});
var $author$project$Compiler$TypeInference$map_nr = F2(
	function (f, tr) {
		return A2(
			$author$project$Generator$map,
			$elm$core$Result$map(f),
			tr);
	});
var $author$project$Compiler$TypeInference$andEnv = function (env) {
	return $author$project$Compiler$TypeInference$map_nr(
		function (subs) {
			return _Utils_Tuple2(env, subs);
		});
};
var $elm$core$Dict$sizeHelp = F2(
	function (n, dict) {
		sizeHelp:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return n;
			} else {
				var left = dict.d;
				var right = dict.e;
				var $temp$n = A2($elm$core$Dict$sizeHelp, n + 1, right),
					$temp$dict = left;
				n = $temp$n;
				dict = $temp$dict;
				continue sizeHelp;
			}
		}
	});
var $elm$core$Dict$size = function (dict) {
	return A2($elm$core$Dict$sizeHelp, 0, dict);
};
var $elm$core$Set$size = function (_v0) {
	var dict = _v0.a;
	return $elm$core$Dict$size(dict);
};
var $elm$core$Debug$toString = _Debug_toString;
var $author$project$Compiler$TypeInference$typeVarsFromType = function (ty) {
	typeVarsFromType:
	while (true) {
		switch (ty.$) {
			case 'TypeVariable':
				var name = ty.b;
				return $elm$core$Set$singleton(name);
			case 'TypeFunction':
				var from = ty.b;
				var fromIsMutable = ty.c;
				var to = ty.d;
				return A2(
					$elm$core$Set$union,
					$author$project$Compiler$TypeInference$typeVarsFromType(from),
					$author$project$Compiler$TypeInference$typeVarsFromType(to));
			case 'TypeConstant':
				var pos = ty.a;
				var ref = ty.b;
				var args = ty.c;
				return A3(
					$elm$core$List$foldl,
					function (a) {
						return $elm$core$Set$union(
							$author$project$Compiler$TypeInference$typeVarsFromType(a));
					},
					$elm$core$Set$empty,
					args);
			case 'TypeAlias':
				var path = ty.b;
				var t = ty.c;
				var $temp$ty = t;
				ty = $temp$ty;
				continue typeVarsFromType;
			default:
				var extensible = ty.b;
				var attrs = ty.c;
				var init = function () {
					if (extensible.$ === 'Nothing') {
						return $elm$core$Set$empty;
					} else {
						var name = extensible.a;
						return $elm$core$Set$singleton(name);
					}
				}();
				return A3(
					$elm$core$Dict$foldl,
					F2(
						function (n, t) {
							return $elm$core$Set$union(
								$author$project$Compiler$TypeInference$typeVarsFromType(t));
						}),
					init,
					attrs);
		}
	}
};
var $author$project$Compiler$TypeInference$annotationTooGeneral = F2(
	function (annotation, inferredForall) {
		var annotationForall = $author$project$Compiler$TypeInference$typeVarsFromType(annotation);
		return (_Utils_cmp(
			$elm$core$Set$size(annotationForall),
			$elm$core$Set$size(inferredForall)) > 0) ? $elm$core$Maybe$Just(
			'annotation too general : ' + ($elm$core$Debug$toString(annotationForall) + (' vs ' + $elm$core$Debug$toString(inferredForall)))) : $elm$core$Maybe$Nothing;
	});
var $elm$core$List$any = F2(
	function (isOkay, list) {
		any:
		while (true) {
			if (!list.b) {
				return false;
			} else {
				var x = list.a;
				var xs = list.b;
				if (isOkay(x)) {
					return true;
				} else {
					var $temp$isOkay = isOkay,
						$temp$list = xs;
					isOkay = $temp$isOkay;
					list = $temp$list;
					continue any;
				}
			}
		}
	});
var $author$project$Compiler$CoreModule$moduleName = 'SPCore';
var $author$project$Compiler$CoreModule$root = function (name) {
	return $author$project$Compiler$CoreModule$moduleName + ('.' + name);
};
var $author$project$Compiler$CoreModule$falseValue = $author$project$Compiler$CoreModule$root('False');
var $author$project$Compiler$CoreModule$trueValue = $author$project$Compiler$CoreModule$root('True');
var $author$project$Compiler$CoreModule$bool = {
	args: _List_Nil,
	constructors: $elm$core$Dict$fromList(
		A2(
			$elm$core$List$map,
			function (c) {
				return _Utils_Tuple2(c.name, c.args);
			},
			_List_fromArray(
				[
					{args: _List_Nil, name: $author$project$Compiler$CoreModule$trueValue},
					{args: _List_Nil, name: $author$project$Compiler$CoreModule$falseValue}
				]))),
	name: $author$project$Compiler$CoreModule$root('Bool')
};
var $author$project$Compiler$CoreModule$p = {c: '', e: -2, n: 'Core', s: -2};
var $author$project$Compiler$CoreModule$boolType = A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$CoreModule$p, $author$project$Compiler$CoreModule$bool.name, _List_Nil);
var $elm$core$Debug$todo = _Debug_todo;
var $author$project$Compiler$TypeInference$dict_get = F3(
	function (caller, k, d) {
		var _v0 = A2($elm$core$Dict$get, k, d);
		if (_v0.$ === 'Nothing') {
			return _Debug_todo(
				'Compiler.TypeInference',
				{
					start: {line: 67, column: 13},
					end: {line: 67, column: 23}
				})(caller);
		} else {
			var v = _v0.a;
			return v;
		}
	});
var $author$project$Types$Error$CodeBlockWithLineNumber = F2(
	function (a, b) {
		return {$: 'CodeBlockWithLineNumber', a: a, b: b};
	});
var $elm$core$Basics$clamp = F3(
	function (low, high, number) {
		return (_Utils_cmp(number, low) < 0) ? low : ((_Utils_cmp(number, high) > 0) ? high : number);
	});
var $elm$core$List$drop = F2(
	function (n, list) {
		drop:
		while (true) {
			if (n <= 0) {
				return list;
			} else {
				if (!list.b) {
					return list;
				} else {
					var x = list.a;
					var xs = list.b;
					var $temp$n = n - 1,
						$temp$list = xs;
					n = $temp$n;
					list = $temp$list;
					continue drop;
				}
			}
		}
	});
var $elm$core$String$indices = _String_indexes;
var $author$project$Types$Error$positionToLineAndColumn = F2(
	function (s, index) {
		var before = A3($elm$core$String$slice, 0, index, s);
		var newLineIndices = A2($elm$core$String$indices, '\n', before);
		var lastNewLineIndex = A2(
			$elm$core$Maybe$withDefault,
			0,
			$elm$core$List$head(
				$elm$core$List$reverse(newLineIndices)));
		var colNumber = index - lastNewLineIndex;
		var lineNumber = $elm$core$List$length(newLineIndices) + 1;
		return _Utils_Tuple2(lineNumber, colNumber);
	});
var $elm$core$List$takeReverse = F3(
	function (n, list, kept) {
		takeReverse:
		while (true) {
			if (n <= 0) {
				return kept;
			} else {
				if (!list.b) {
					return kept;
				} else {
					var x = list.a;
					var xs = list.b;
					var $temp$n = n - 1,
						$temp$list = xs,
						$temp$kept = A2($elm$core$List$cons, x, kept);
					n = $temp$n;
					list = $temp$list;
					kept = $temp$kept;
					continue takeReverse;
				}
			}
		}
	});
var $elm$core$List$takeTailRec = F2(
	function (n, list) {
		return $elm$core$List$reverse(
			A3($elm$core$List$takeReverse, n, list, _List_Nil));
	});
var $elm$core$List$takeFast = F3(
	function (ctr, n, list) {
		if (n <= 0) {
			return _List_Nil;
		} else {
			var _v0 = _Utils_Tuple2(n, list);
			_v0$1:
			while (true) {
				_v0$5:
				while (true) {
					if (!_v0.b.b) {
						return list;
					} else {
						if (_v0.b.b.b) {
							switch (_v0.a) {
								case 1:
									break _v0$1;
								case 2:
									var _v2 = _v0.b;
									var x = _v2.a;
									var _v3 = _v2.b;
									var y = _v3.a;
									return _List_fromArray(
										[x, y]);
								case 3:
									if (_v0.b.b.b.b) {
										var _v4 = _v0.b;
										var x = _v4.a;
										var _v5 = _v4.b;
										var y = _v5.a;
										var _v6 = _v5.b;
										var z = _v6.a;
										return _List_fromArray(
											[x, y, z]);
									} else {
										break _v0$5;
									}
								default:
									if (_v0.b.b.b.b && _v0.b.b.b.b.b) {
										var _v7 = _v0.b;
										var x = _v7.a;
										var _v8 = _v7.b;
										var y = _v8.a;
										var _v9 = _v8.b;
										var z = _v9.a;
										var _v10 = _v9.b;
										var w = _v10.a;
										var tl = _v10.b;
										return (ctr > 1000) ? A2(
											$elm$core$List$cons,
											x,
											A2(
												$elm$core$List$cons,
												y,
												A2(
													$elm$core$List$cons,
													z,
													A2(
														$elm$core$List$cons,
														w,
														A2($elm$core$List$takeTailRec, n - 4, tl))))) : A2(
											$elm$core$List$cons,
											x,
											A2(
												$elm$core$List$cons,
												y,
												A2(
													$elm$core$List$cons,
													z,
													A2(
														$elm$core$List$cons,
														w,
														A3($elm$core$List$takeFast, ctr + 1, n - 4, tl)))));
									} else {
										break _v0$5;
									}
							}
						} else {
							if (_v0.a === 1) {
								break _v0$1;
							} else {
								break _v0$5;
							}
						}
					}
				}
				return list;
			}
			var _v1 = _v0.b;
			var x = _v1.a;
			return _List_fromArray(
				[x]);
		}
	});
var $elm$core$List$take = F2(
	function (n, list) {
		return A3($elm$core$List$takeFast, 0, n, list);
	});
var $author$project$Types$Error$showLines = F3(
	function (code, lineSpan, pos) {
		var lines = A2($elm$core$String$split, '\n', code);
		var _v0 = A2($author$project$Types$Error$positionToLineAndColumn, code, pos);
		var line = _v0.a;
		var start = A3(
			$elm$core$Basics$clamp,
			0,
			$elm$core$List$length(lines) - 1,
			(line - lineSpan) - 1);
		var size = A2($elm$core$Basics$max, 1, (line - start) + lineSpan);
		return A2(
			$author$project$Types$Error$CodeBlockWithLineNumber,
			start + 1,
			A2(
				$elm$core$List$take,
				size,
				A2($elm$core$List$drop, start, lines)));
	});
var $author$project$Compiler$TypeInference$errorUnboundVariable = F2(
	function (pos, s) {
		return A2(
			$author$project$Types$Error$makeRes,
			pos.n,
			_List_fromArray(
				[
					A3($author$project$Types$Error$showLines, pos.c, 2, pos.s),
					$author$project$Types$Error$text('unbound variable: ' + s)
				]));
	});
var $author$project$Generator$next = F2(
	function (nextState, stateToOutput) {
		return $author$project$Generator$Generator(
			function (state) {
				return _Utils_Tuple2(
					stateToOutput(state),
					nextState(state));
			});
	});
var $author$project$Compiler$TypeInference$newName = A2(
	$author$project$Generator$next,
	$elm$core$Basics$add(1),
	$elm$core$String$fromInt);
var $author$project$Compiler$TypeInference$newType = function (pos) {
	return A2(
		$author$project$Generator$map,
		$author$project$Types$CanonicalAst$TypeVariable(pos),
		$author$project$Compiler$TypeInference$newName);
};
var $elm$core$Maybe$andThen = F2(
	function (callback, maybeValue) {
		if (maybeValue.$ === 'Just') {
			var value = maybeValue.a;
			return callback(value);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Compiler$TypeInference$refineType = F2(
	function (subs, ty) {
		refineType:
		while (true) {
			switch (ty.$) {
				case 'TypeConstant':
					var pos = ty.a;
					var ref = ty.b;
					var args = ty.c;
					return A3(
						$author$project$Types$CanonicalAst$TypeConstant,
						pos,
						ref,
						A2(
							$elm$core$List$map,
							$author$project$Compiler$TypeInference$refineType(subs),
							args));
				case 'TypeVariable':
					var name = ty.b;
					var _v1 = A2($elm$core$Dict$get, name, subs);
					if (_v1.$ === 'Just') {
						var substitutionType = _v1.a;
						var $temp$subs = subs,
							$temp$ty = substitutionType;
						subs = $temp$subs;
						ty = $temp$ty;
						continue refineType;
					} else {
						return ty;
					}
				case 'TypeFunction':
					var pos = ty.a;
					var from = ty.b;
					var fromIsMutable = ty.c;
					var to = ty.d;
					return A4(
						$author$project$Types$CanonicalAst$TypeFunction,
						pos,
						A2($author$project$Compiler$TypeInference$refineType, subs, from),
						fromIsMutable,
						A2($author$project$Compiler$TypeInference$refineType, subs, to));
				case 'TypeAlias':
					var pos = ty.a;
					var path = ty.b;
					var t = ty.c;
					return A3(
						$author$project$Types$CanonicalAst$TypeAlias,
						pos,
						path,
						A2($author$project$Compiler$TypeInference$refineType, subs, t));
				default:
					var pos = ty.a;
					var extensible = ty.b;
					var attrs = ty.c;
					var _v2 = A2(
						$elm$core$Maybe$andThen,
						function (name) {
							return A2($elm$core$Dict$get, name, subs);
						},
						extensible);
					if (_v2.$ === 'Nothing') {
						return A3(
							$author$project$Types$CanonicalAst$TypeRecord,
							pos,
							extensible,
							A2(
								$elm$core$Dict$map,
								function (name) {
									return $author$project$Compiler$TypeInference$refineType(subs);
								},
								attrs));
					} else {
						switch (_v2.a.$) {
							case 'TypeVariable':
								var _v3 = _v2.a;
								var n = _v3.b;
								return A3(
									$author$project$Types$CanonicalAst$TypeRecord,
									pos,
									$elm$core$Maybe$Just(n),
									A2(
										$elm$core$Dict$map,
										function (name) {
											return $author$project$Compiler$TypeInference$refineType(subs);
										},
										attrs));
							case 'TypeRecord':
								var _v4 = _v2.a;
								var ext2 = _v4.b;
								var attrs2 = _v4.c;
								return A3(
									$author$project$Types$CanonicalAst$TypeRecord,
									pos,
									ext2,
									A2(
										$elm$core$Dict$map,
										function (name) {
											return $author$project$Compiler$TypeInference$refineType(subs);
										},
										attrs2));
							default:
								var what = _v2.a;
								return A2(
									_Debug_todo(
										'Compiler.TypeInference',
										{
											start: {line: 263, column: 21},
											end: {line: 263, column: 31}
										}),
									'replacing record extension with non-var',
									$elm$core$Debug$toString(what));
						}
					}
			}
		}
	});
var $author$project$Compiler$TypeInference$instantiateType = F2(
	function (t, tvars) {
		var substituteTvar = F2(
			function (tvar, genSubs) {
				return A2(
					$author$project$Generator$do,
					$author$project$Compiler$TypeInference$newType($author$project$Compiler$TypeInference$todoPos),
					function (nt) {
						return A2(
							$author$project$Generator$do,
							genSubs,
							function (subs) {
								return $author$project$Generator$wrap(
									A3($elm$core$Dict$insert, tvar, nt, subs));
							});
					});
			});
		var genAllSubs = A3(
			$elm$core$Set$foldl,
			substituteTvar,
			$author$project$Generator$wrap($elm$core$Dict$empty),
			tvars);
		return A2(
			$author$project$Generator$do,
			genAllSubs,
			function (subs) {
				return $author$project$Generator$wrap(
					A2($author$project$Compiler$TypeInference$refineType, subs, t));
			});
	});
var $author$project$Compiler$TypeInference$envGet = F3(
	function (pos, v, e) {
		var _v0 = A2($elm$core$Dict$get, v, e);
		if (_v0.$ === 'Just') {
			var type_ = _v0.a.type_;
			var forall = _v0.a.forall;
			var mutable = _v0.a.mutable;
			return A2(
				$author$project$Generator$map,
				$elm$core$Result$Ok,
				A2($author$project$Compiler$TypeInference$instantiateType, type_, forall));
		} else {
			return $author$project$Generator$wrap(
				A2($author$project$Compiler$TypeInference$errorUnboundVariable, pos, v));
		}
	});
var $elm$core$Dict$getMin = function (dict) {
	getMin:
	while (true) {
		if ((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) {
			var left = dict.d;
			var $temp$dict = left;
			dict = $temp$dict;
			continue getMin;
		} else {
			return dict;
		}
	}
};
var $elm$core$Dict$moveRedLeft = function (dict) {
	if (((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) && (dict.e.$ === 'RBNode_elm_builtin')) {
		if ((dict.e.d.$ === 'RBNode_elm_builtin') && (dict.e.d.a.$ === 'Red')) {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v1 = dict.d;
			var lClr = _v1.a;
			var lK = _v1.b;
			var lV = _v1.c;
			var lLeft = _v1.d;
			var lRight = _v1.e;
			var _v2 = dict.e;
			var rClr = _v2.a;
			var rK = _v2.b;
			var rV = _v2.c;
			var rLeft = _v2.d;
			var _v3 = rLeft.a;
			var rlK = rLeft.b;
			var rlV = rLeft.c;
			var rlL = rLeft.d;
			var rlR = rLeft.e;
			var rRight = _v2.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				$elm$core$Dict$Red,
				rlK,
				rlV,
				A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					rlL),
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rlR, rRight));
		} else {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v4 = dict.d;
			var lClr = _v4.a;
			var lK = _v4.b;
			var lV = _v4.c;
			var lLeft = _v4.d;
			var lRight = _v4.e;
			var _v5 = dict.e;
			var rClr = _v5.a;
			var rK = _v5.b;
			var rV = _v5.c;
			var rLeft = _v5.d;
			var rRight = _v5.e;
			if (clr.$ === 'Black') {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			}
		}
	} else {
		return dict;
	}
};
var $elm$core$Dict$moveRedRight = function (dict) {
	if (((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) && (dict.e.$ === 'RBNode_elm_builtin')) {
		if ((dict.d.d.$ === 'RBNode_elm_builtin') && (dict.d.d.a.$ === 'Red')) {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v1 = dict.d;
			var lClr = _v1.a;
			var lK = _v1.b;
			var lV = _v1.c;
			var _v2 = _v1.d;
			var _v3 = _v2.a;
			var llK = _v2.b;
			var llV = _v2.c;
			var llLeft = _v2.d;
			var llRight = _v2.e;
			var lRight = _v1.e;
			var _v4 = dict.e;
			var rClr = _v4.a;
			var rK = _v4.b;
			var rV = _v4.c;
			var rLeft = _v4.d;
			var rRight = _v4.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				$elm$core$Dict$Red,
				lK,
				lV,
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
				A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					lRight,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)));
		} else {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v5 = dict.d;
			var lClr = _v5.a;
			var lK = _v5.b;
			var lV = _v5.c;
			var lLeft = _v5.d;
			var lRight = _v5.e;
			var _v6 = dict.e;
			var rClr = _v6.a;
			var rK = _v6.b;
			var rV = _v6.c;
			var rLeft = _v6.d;
			var rRight = _v6.e;
			if (clr.$ === 'Black') {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			}
		}
	} else {
		return dict;
	}
};
var $elm$core$Dict$removeHelpPrepEQGT = F7(
	function (targetKey, dict, color, key, value, left, right) {
		if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) {
			var _v1 = left.a;
			var lK = left.b;
			var lV = left.c;
			var lLeft = left.d;
			var lRight = left.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				lK,
				lV,
				lLeft,
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, lRight, right));
		} else {
			_v2$2:
			while (true) {
				if ((right.$ === 'RBNode_elm_builtin') && (right.a.$ === 'Black')) {
					if (right.d.$ === 'RBNode_elm_builtin') {
						if (right.d.a.$ === 'Black') {
							var _v3 = right.a;
							var _v4 = right.d;
							var _v5 = _v4.a;
							return $elm$core$Dict$moveRedRight(dict);
						} else {
							break _v2$2;
						}
					} else {
						var _v6 = right.a;
						var _v7 = right.d;
						return $elm$core$Dict$moveRedRight(dict);
					}
				} else {
					break _v2$2;
				}
			}
			return dict;
		}
	});
var $elm$core$Dict$removeMin = function (dict) {
	if ((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) {
		var color = dict.a;
		var key = dict.b;
		var value = dict.c;
		var left = dict.d;
		var lColor = left.a;
		var lLeft = left.d;
		var right = dict.e;
		if (lColor.$ === 'Black') {
			if ((lLeft.$ === 'RBNode_elm_builtin') && (lLeft.a.$ === 'Red')) {
				var _v3 = lLeft.a;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					color,
					key,
					value,
					$elm$core$Dict$removeMin(left),
					right);
			} else {
				var _v4 = $elm$core$Dict$moveRedLeft(dict);
				if (_v4.$ === 'RBNode_elm_builtin') {
					var nColor = _v4.a;
					var nKey = _v4.b;
					var nValue = _v4.c;
					var nLeft = _v4.d;
					var nRight = _v4.e;
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						$elm$core$Dict$removeMin(nLeft),
						nRight);
				} else {
					return $elm$core$Dict$RBEmpty_elm_builtin;
				}
			}
		} else {
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				key,
				value,
				$elm$core$Dict$removeMin(left),
				right);
		}
	} else {
		return $elm$core$Dict$RBEmpty_elm_builtin;
	}
};
var $elm$core$Dict$removeHelp = F2(
	function (targetKey, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		} else {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			if (_Utils_cmp(targetKey, key) < 0) {
				if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Black')) {
					var _v4 = left.a;
					var lLeft = left.d;
					if ((lLeft.$ === 'RBNode_elm_builtin') && (lLeft.a.$ === 'Red')) {
						var _v6 = lLeft.a;
						return A5(
							$elm$core$Dict$RBNode_elm_builtin,
							color,
							key,
							value,
							A2($elm$core$Dict$removeHelp, targetKey, left),
							right);
					} else {
						var _v7 = $elm$core$Dict$moveRedLeft(dict);
						if (_v7.$ === 'RBNode_elm_builtin') {
							var nColor = _v7.a;
							var nKey = _v7.b;
							var nValue = _v7.c;
							var nLeft = _v7.d;
							var nRight = _v7.e;
							return A5(
								$elm$core$Dict$balance,
								nColor,
								nKey,
								nValue,
								A2($elm$core$Dict$removeHelp, targetKey, nLeft),
								nRight);
						} else {
							return $elm$core$Dict$RBEmpty_elm_builtin;
						}
					}
				} else {
					return A5(
						$elm$core$Dict$RBNode_elm_builtin,
						color,
						key,
						value,
						A2($elm$core$Dict$removeHelp, targetKey, left),
						right);
				}
			} else {
				return A2(
					$elm$core$Dict$removeHelpEQGT,
					targetKey,
					A7($elm$core$Dict$removeHelpPrepEQGT, targetKey, dict, color, key, value, left, right));
			}
		}
	});
var $elm$core$Dict$removeHelpEQGT = F2(
	function (targetKey, dict) {
		if (dict.$ === 'RBNode_elm_builtin') {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			if (_Utils_eq(targetKey, key)) {
				var _v1 = $elm$core$Dict$getMin(right);
				if (_v1.$ === 'RBNode_elm_builtin') {
					var minKey = _v1.b;
					var minValue = _v1.c;
					return A5(
						$elm$core$Dict$balance,
						color,
						minKey,
						minValue,
						left,
						$elm$core$Dict$removeMin(right));
				} else {
					return $elm$core$Dict$RBEmpty_elm_builtin;
				}
			} else {
				return A5(
					$elm$core$Dict$balance,
					color,
					key,
					value,
					left,
					A2($elm$core$Dict$removeHelp, targetKey, right));
			}
		} else {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		}
	});
var $elm$core$Dict$remove = F2(
	function (key, dict) {
		var _v0 = A2($elm$core$Dict$removeHelp, key, dict);
		if ((_v0.$ === 'RBNode_elm_builtin') && (_v0.a.$ === 'Red')) {
			var _v1 = _v0.a;
			var k = _v0.b;
			var v = _v0.c;
			var l = _v0.d;
			var r = _v0.e;
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
		} else {
			var x = _v0;
			return x;
		}
	});
var $elm$core$Dict$diff = F2(
	function (t1, t2) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, t) {
					return A2($elm$core$Dict$remove, k, t);
				}),
			t1,
			t2);
	});
var $elm$core$Set$diff = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$diff, dict1, dict2));
	});
var $author$project$Compiler$TypeInference$generalize = F3(
	function (names, env, ty) {
		var addEnvTvar = F3(
			function (k, schema, acc) {
				return A2($elm$core$Set$member, k, names) ? acc : A2(
					$elm$core$Set$union,
					A2(
						$elm$core$Set$diff,
						$author$project$Compiler$TypeInference$typeVarsFromType(schema.type_),
						schema.forall),
					acc);
			});
		var tyvarsFromEnv = A3($elm$core$Dict$foldl, addEnvTvar, $elm$core$Set$empty, env);
		return A2(
			$elm$core$Set$diff,
			$author$project$Compiler$TypeInference$typeVarsFromType(ty),
			tyvarsFromEnv);
	});
var $elm$core$Set$filter = F2(
	function (isGood, _v0) {
		var dict = _v0.a;
		return $elm$core$Set$Set_elm_builtin(
			A2(
				$elm$core$Dict$filter,
				F2(
					function (key, _v1) {
						return isGood(key);
					}),
				dict));
	});
var $author$project$Compiler$TypeInference$list_foldl_nr = F3(
	function (f, ls, accum) {
		if (!ls.b) {
			return $author$project$Generator$wrap(
				$elm$core$Result$Ok(accum));
		} else {
			var head = ls.a;
			var tail = ls.b;
			return A2(
				$author$project$Compiler$TypeInference$do_nr,
				A2(f, head, accum),
				function (newAccum) {
					return A3($author$project$Compiler$TypeInference$list_foldl_nr, f, tail, newAccum);
				});
		}
	});
var $author$project$Types$CanonicalAst$patternNames = function (p) {
	switch (p.$) {
		case 'PatternDiscard':
			var pos = p.a;
			return $elm$core$Set$empty;
		case 'PatternAny':
			var pos = p.a;
			var n = p.b;
			return $elm$core$Set$singleton(n);
		case 'PatternLiteral':
			var pos = p.a;
			return $elm$core$Set$empty;
		case 'PatternConstructor':
			var pos = p.a;
			var path = p.b;
			var ps = p.c;
			return A3(
				$elm$core$List$foldl,
				A2($elm$core$Basics$composeR, $author$project$Types$CanonicalAst$patternNames, $elm$core$Set$union),
				$elm$core$Set$empty,
				ps);
		default:
			var pos = p.a;
			var ps = p.b;
			return A3(
				$elm$core$Dict$foldl,
				function (k) {
					return A2($elm$core$Basics$composeR, $author$project$Types$CanonicalAst$patternNames, $elm$core$Set$union);
				},
				$elm$core$Set$empty,
				ps);
	}
};
var $author$project$Compiler$TypeInference$insertDefinitionRec = F2(
	function (def, env) {
		var varNames = $author$project$Types$CanonicalAst$patternNames(def.pattern);
		var duplicates = A2(
			$elm$core$Set$filter,
			function (name) {
				return A2($elm$core$Dict$member, name, env);
			},
			varNames);
		if (!_Utils_eq(duplicates, $elm$core$Set$empty)) {
			return $author$project$Generator$wrap(
				$author$project$Types$Error$errorTodo(
					function (s) {
						return s + ' already declared in scope!';
					}(
						A2(
							$elm$core$String$join,
							', ',
							$elm$core$List$sort(
								$elm$core$Set$toList(duplicates))))));
		} else {
			var _v0 = def.maybeAnnotation;
			if (_v0.$ === 'Just') {
				var annotation = _v0.a;
				var _v1 = A2($author$project$Compiler$TypeInference$validateType, def.mutable, annotation);
				if (_v1.$ === 'Just') {
					var err = _v1.a;
					return $author$project$Generator$wrap(
						$author$project$Types$Error$errorTodo(err));
				} else {
					var insert = function (varName) {
						return A2(
							$elm$core$Dict$insert,
							varName,
							{
								forall: $author$project$Compiler$TypeInference$typeVarsFromType(annotation),
								mutable: $elm$core$Maybe$Just(def.mutable),
								type_: annotation
							});
					};
					return $author$project$Generator$wrap(
						$elm$core$Result$Ok(
							A3($elm$core$Set$foldl, insert, env, varNames)));
				}
			} else {
				var insert_nr = F2(
					function (varName, e) {
						return A2(
							$author$project$Generator$do,
							$author$project$Compiler$TypeInference$newName,
							function (typeName) {
								return $author$project$Generator$wrap(
									$elm$core$Result$Ok(
										A3(
											$elm$core$Dict$insert,
											varName,
											{
												forall: $elm$core$Set$singleton(typeName),
												mutable: $elm$core$Maybe$Just(def.mutable),
												type_: A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Compiler$TypeInference$todoPos, typeName)
											},
											e)));
							});
					});
				return A3(
					$author$project$Compiler$TypeInference$list_foldl_nr,
					insert_nr,
					$elm$core$Set$toList(varNames),
					env);
			}
		}
	});
var $author$project$Compiler$TypeInference$refineEnv = F2(
	function (s, env) {
		var refine_entry = F2(
			function (_v0, entry) {
				return _Utils_update(
					entry,
					{
						type_: A2(
							$author$project$Compiler$TypeInference$refineType,
							A3($elm$core$Set$foldl, $elm$core$Dict$remove, s, entry.forall),
							entry.type_)
					});
			});
		return A2($elm$core$Dict$map, refine_entry, env);
	});
var $author$project$Types$Error$CodeBlock = function (a) {
	return {$: 'CodeBlock', a: a};
};
var $author$project$Types$Error$codeBlock = $author$project$Types$Error$CodeBlock;
var $author$project$Human$CanonicalAst$parensIf = F2(
	function (test, s) {
		return test ? ('(' + (s + ')')) : s;
	});
var $elm$core$Tuple$second = function (_v0) {
	var y = _v0.b;
	return y;
};
var $author$project$Human$CanonicalAst$parensIfGreaterThan = F2(
	function (threshold, ty) {
		var _v4 = $author$project$Human$CanonicalAst$typeToPriAndString(ty);
		var pri = _v4.a;
		var str = _v4.b;
		return A2(
			$author$project$Human$CanonicalAst$parensIf,
			_Utils_cmp(pri, threshold) > 0,
			str);
	});
var $author$project$Human$CanonicalAst$typeToPriAndString = function (type_) {
	switch (type_.$) {
		case 'TypeConstant':
			var pos = type_.a;
			var name = type_.b;
			var args = type_.c;
			return _Utils_Tuple2(
				_Utils_eq(args, _List_Nil) ? 0 : 1,
				A2(
					$elm$core$String$join,
					' ',
					A2(
						$elm$core$List$cons,
						name,
						A2(
							$elm$core$List$map,
							$author$project$Human$CanonicalAst$parensIfGreaterThan(0),
							args))));
		case 'TypeVariable':
			var pos = type_.a;
			var name = type_.b;
			return _Utils_Tuple2(0, name);
		case 'TypeFunction':
			var pos = type_.a;
			var from = type_.b;
			var fromIsMut = type_.c;
			var to = type_.d;
			var arrow = function () {
				if (fromIsMut.$ === 'Nothing') {
					return '?>';
				} else {
					if (fromIsMut.a) {
						return '@>';
					} else {
						return '->';
					}
				}
			}();
			return _Utils_Tuple2(
				2,
				A2(
					$elm$core$String$join,
					' ',
					_List_fromArray(
						[
							A2($author$project$Human$CanonicalAst$parensIfGreaterThan, 1, from),
							arrow,
							A2($author$project$Human$CanonicalAst$parensIfGreaterThan, 2, to)
						])));
		case 'TypeRecord':
			var pos = type_.a;
			var extend = type_.b;
			var attrs = type_.c;
			var attrsString = A2(
				$elm$core$String$join,
				', ',
				A2(
					$elm$core$List$map,
					function (_v3) {
						var name = _v3.a;
						var ty = _v3.b;
						return name + (' : ' + $author$project$Human$CanonicalAst$cyclic$typeToString()(ty));
					},
					A2(
						$elm$core$List$sortBy,
						$elm$core$Tuple$first,
						$elm$core$Dict$toList(attrs))));
			return _Utils_Tuple2(
				0,
				A2(
					$elm$core$String$join,
					'',
					_List_fromArray(
						[
							'{ ',
							function () {
							if (extend.$ === 'Nothing') {
								return '';
							} else {
								var n = extend.a;
								return n + ' with';
							}
						}(),
							attrsString,
							' }'
						])));
		default:
			var pos = type_.a;
			var name = type_.b;
			var ty2 = type_.c;
			return _Utils_Tuple2(
				0,
				A2(
					$elm$core$String$join,
					' ',
					_List_fromArray(
						[
							'<',
							name,
							'=',
							$author$project$Human$CanonicalAst$cyclic$typeToString()(ty2),
							'>'
						])));
	}
};
function $author$project$Human$CanonicalAst$cyclic$typeToString() {
	return A2($elm$core$Basics$composeR, $author$project$Human$CanonicalAst$typeToPriAndString, $elm$core$Tuple$second);
}
try {
	var $author$project$Human$CanonicalAst$typeToString = $author$project$Human$CanonicalAst$cyclic$typeToString();
	$author$project$Human$CanonicalAst$cyclic$typeToString = function () {
		return $author$project$Human$CanonicalAst$typeToString;
	};
} catch ($) {
	throw 'Some top-level definitions from `Human.CanonicalAst` are causing infinite recursion:\n\n  \n      parensIfGreaterThan\n       \n      typeToString\n       \n      typeToPriAndString\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$TypeInference$errorCannotUnify = F4(
	function (ctx, subs, a, b) {
		return $author$project$Generator$wrap(
			A2(
				$author$project$Types$Error$makeRes,
				ctx.pos.n,
				_List_fromArray(
					[
						$author$project$Types$Error$text('Cannot unify:'),
						$author$project$Types$Error$text(
						'* t1 = ' + $author$project$Human$CanonicalAst$typeToString(a)),
						$author$project$Types$Error$text(
						'* t2 = ' + $author$project$Human$CanonicalAst$typeToString(b)),
						$author$project$Types$Error$text('why : ' + ctx.why),
						$author$project$Types$Error$text(
						'expr = ' + A3($elm$core$String$slice, ctx.pos.s, ctx.pos.e, ctx.pos.c)),
						A3($author$project$Types$Error$showLines, ctx.pos.c, 2, ctx.pos.s),
						$author$project$Types$Error$codeBlock(
						A2(
							$elm$core$String$join,
							'\n',
							A2(
								$elm$core$List$map,
								function (_v0) {
									var n = _v0.a;
									var t = _v0.b;
									return n + (' = ' + $author$project$Human$CanonicalAst$typeToString(t));
								},
								A2(
									$elm$core$List$sortBy,
									$elm$core$Tuple$first,
									$elm$core$Dict$toList(subs)))))
					])));
	});
var $elm$core$Maybe$map2 = F3(
	function (func, ma, mb) {
		if (ma.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var a = ma.a;
			if (mb.$ === 'Nothing') {
				return $elm$core$Maybe$Nothing;
			} else {
				var b = mb.a;
				return $elm$core$Maybe$Just(
					A2(func, a, b));
			}
		}
	});
var $elm$core$Dict$merge = F6(
	function (leftStep, bothStep, rightStep, leftDict, rightDict, initialResult) {
		var stepState = F3(
			function (rKey, rValue, _v0) {
				stepState:
				while (true) {
					var list = _v0.a;
					var result = _v0.b;
					if (!list.b) {
						return _Utils_Tuple2(
							list,
							A3(rightStep, rKey, rValue, result));
					} else {
						var _v2 = list.a;
						var lKey = _v2.a;
						var lValue = _v2.b;
						var rest = list.b;
						if (_Utils_cmp(lKey, rKey) < 0) {
							var $temp$rKey = rKey,
								$temp$rValue = rValue,
								$temp$_v0 = _Utils_Tuple2(
								rest,
								A3(leftStep, lKey, lValue, result));
							rKey = $temp$rKey;
							rValue = $temp$rValue;
							_v0 = $temp$_v0;
							continue stepState;
						} else {
							if (_Utils_cmp(lKey, rKey) > 0) {
								return _Utils_Tuple2(
									list,
									A3(rightStep, rKey, rValue, result));
							} else {
								return _Utils_Tuple2(
									rest,
									A4(bothStep, lKey, lValue, rValue, result));
							}
						}
					}
				}
			});
		var _v3 = A3(
			$elm$core$Dict$foldl,
			stepState,
			_Utils_Tuple2(
				$elm$core$Dict$toList(leftDict),
				initialResult),
			rightDict);
		var leftovers = _v3.a;
		var intermediateResult = _v3.b;
		return A3(
			$elm$core$List$foldl,
			F2(
				function (_v4, result) {
					var k = _v4.a;
					var v = _v4.b;
					return A3(leftStep, k, v, result);
				}),
			intermediateResult,
			leftovers);
	});
var $author$project$Compiler$TypeInference$unwrapAlias = F2(
	function (prevPath, ty) {
		unwrapAlias:
		while (true) {
			if (ty.$ === 'TypeAlias') {
				var path = ty.b;
				var t = ty.c;
				var $temp$prevPath = $elm$core$Maybe$Just(path),
					$temp$ty = t;
				prevPath = $temp$prevPath;
				ty = $temp$ty;
				continue unwrapAlias;
			} else {
				return _Utils_Tuple2(ty, prevPath);
			}
		}
	});
var $author$project$Compiler$TypeInference$unify = F4(
	function (ctx, at1, at2, s) {
		unify:
		while (true) {
			var cycle = F2(
				function (v, t) {
					return A2(
						$elm$core$Set$member,
						v,
						$author$project$Compiler$TypeInference$typeVarsFromType(t));
				});
			var _v11 = A2($author$project$Compiler$TypeInference$unwrapAlias, $elm$core$Maybe$Nothing, at2);
			var t2 = _v11.a;
			var path2 = _v11.b;
			var t2_refined = A2($author$project$Compiler$TypeInference$refineType, s, t2);
			var _v12 = A2($author$project$Compiler$TypeInference$unwrapAlias, $elm$core$Maybe$Nothing, at1);
			var t1 = _v12.a;
			var path1 = _v12.b;
			var t1_refined = A2($author$project$Compiler$TypeInference$refineType, s, t1);
			var _v13 = _Utils_Tuple2(t1_refined, t2_refined);
			_v13$3:
			while (true) {
				_v13$6:
				while (true) {
					switch (_v13.a.$) {
						case 'TypeConstant':
							switch (_v13.b.$) {
								case 'TypeConstant':
									var _v14 = _v13.a;
									var c1_ref = _v14.b;
									var c1_args = _v14.c;
									var _v15 = _v13.b;
									var c2_ref = _v15.b;
									var c2_args = _v15.c;
									if (!_Utils_eq(c1_ref, c2_ref)) {
										return A4($author$project$Compiler$TypeInference$errorCannotUnify, ctx, s, t1_refined, t2_refined);
									} else {
										var rec = F3(
											function (a1, a2, subs) {
												var _v16 = _Utils_Tuple2(a1, a2);
												_v16$2:
												while (true) {
													if (!_v16.a.b) {
														if (!_v16.b.b) {
															return $author$project$Generator$wrap(
																$elm$core$Result$Ok(subs));
														} else {
															break _v16$2;
														}
													} else {
														if (_v16.b.b) {
															var _v17 = _v16.a;
															var head1 = _v17.a;
															var tail1 = _v17.b;
															var _v18 = _v16.b;
															var head2 = _v18.a;
															var tail2 = _v18.b;
															return A2(
																$author$project$Compiler$TypeInference$do_nr,
																A4($author$project$Compiler$TypeInference$unify, ctx, head1, head2, subs),
																A2(rec, tail1, tail2));
														} else {
															break _v16$2;
														}
													}
												}
												return $author$project$Generator$wrap(
													$author$project$Types$Error$errorTodo('one of the two has wrong number of args: ' + (c1_ref + (' and ' + c2_ref))));
											});
										return A3(rec, c1_args, c2_args, s);
									}
								case 'TypeVariable':
									break _v13$3;
								default:
									break _v13$6;
							}
						case 'TypeVariable':
							if (_v13.b.$ === 'TypeVariable') {
								var _v19 = _v13.a;
								var v1_name = _v19.b;
								var _v20 = _v13.b;
								var v2_name = _v20.b;
								return $author$project$Generator$wrap(
									_Utils_eq(v1_name, v2_name) ? $elm$core$Result$Ok(s) : $elm$core$Result$Ok(
										A3($elm$core$Dict$insert, v1_name, t2_refined, s)));
							} else {
								var _v21 = _v13.a;
								var v1_name = _v21.b;
								return $author$project$Generator$wrap(
									A2(cycle, v1_name, t2) ? $author$project$Types$Error$errorTodo('cycle!') : $elm$core$Result$Ok(
										A3($elm$core$Dict$insert, v1_name, t2_refined, s)));
							}
						case 'TypeFunction':
							switch (_v13.b.$) {
								case 'TypeVariable':
									break _v13$3;
								case 'TypeFunction':
									var _v23 = _v13.a;
									var a_from = _v23.b;
									var a_fromIsMutable = _v23.c;
									var a_to = _v23.d;
									var _v24 = _v13.b;
									var b_from = _v24.b;
									var b_fromIsMutable = _v24.c;
									var b_to = _v24.d;
									var maybeClash = A3(
										$elm$core$Maybe$map2,
										F2(
											function (aa, bb) {
												return !_Utils_eq(aa, bb);
											}),
										a_fromIsMutable,
										b_fromIsMutable);
									return A2($elm$core$Maybe$withDefault, false, maybeClash) ? $author$project$Generator$wrap(
										$author$project$Types$Error$errorTodo(
											'mutability clash: ' + ($elm$core$Debug$toString(t1_refined) + (' and ' + $elm$core$Debug$toString(t2_refined))))) : A2(
										$author$project$Compiler$TypeInference$do_nr,
										A4($author$project$Compiler$TypeInference$unify, ctx, a_to, b_to, s),
										A3($author$project$Compiler$TypeInference$unify, ctx, a_from, b_from));
								default:
									break _v13$6;
							}
						case 'TypeRecord':
							switch (_v13.b.$) {
								case 'TypeVariable':
									break _v13$3;
								case 'TypeRecord':
									var _v25 = _v13.a;
									var a_ext = _v25.b;
									var a_attrs = _v25.c;
									var _v26 = _v13.b;
									var b_ext = _v26.b;
									var b_attrs = _v26.c;
									return A4(
										$author$project$Compiler$TypeInference$unifyRecords,
										ctx,
										_Utils_Tuple2(a_ext, a_attrs),
										_Utils_Tuple2(b_ext, b_attrs),
										s);
								default:
									break _v13$6;
							}
						default:
							if (_v13.b.$ === 'TypeVariable') {
								break _v13$3;
							} else {
								break _v13$6;
							}
					}
				}
				return A4($author$project$Compiler$TypeInference$errorCannotUnify, ctx, s, t1_refined, t2_refined);
			}
			var _v22 = _v13.b;
			var v2 = _v22.b;
			var $temp$ctx = ctx,
				$temp$at1 = t2_refined,
				$temp$at2 = t1_refined,
				$temp$s = s;
			ctx = $temp$ctx;
			at1 = $temp$at1;
			at2 = $temp$at2;
			s = $temp$s;
			continue unify;
		}
	});
var $author$project$Compiler$TypeInference$unifyRecords = F4(
	function (ctx, _v0, _v1, subs0) {
		var a_ext = _v0.a;
		var a_attrs = _v0.b;
		var b_ext = _v1.a;
		var b_attrs = _v1.b;
		var unifyBothRec = F2(
			function (subs, ls) {
				if (!ls.b) {
					return $author$project$Generator$wrap(
						$elm$core$Result$Ok(subs));
				} else {
					var _v3 = ls.a;
					var name = _v3.a;
					var _v4 = _v3.b;
					var aType = _v4.a;
					var bType = _v4.b;
					var tail = ls.b;
					return A2(
						$author$project$Compiler$TypeInference$do_nr,
						A4($author$project$Compiler$TypeInference$unify, ctx, aType, bType, subs),
						function (subsN) {
							return A2(unifyBothRec, subsN, tail);
						});
				}
			});
		var onBoth = F4(
			function (name, aType, bType, state) {
				return _Utils_update(
					state,
					{
						both: A3(
							$elm$core$Dict$insert,
							name,
							_Utils_Tuple2(aType, bType),
							state.both)
					});
			});
		var onB = F3(
			function (name, type_, state) {
				return _Utils_update(
					state,
					{
						bOnly: A3($elm$core$Dict$insert, name, type_, state.bOnly)
					});
			});
		var onA = F3(
			function (name, type_, state) {
				return _Utils_update(
					state,
					{
						aOnly: A3($elm$core$Dict$insert, name, type_, state.aOnly)
					});
			});
		var initState = {aOnly: $elm$core$Dict$empty, bOnly: $elm$core$Dict$empty, both: $elm$core$Dict$empty};
		var _v5 = A6($elm$core$Dict$merge, onA, onBoth, onB, a_attrs, b_attrs, initState);
		var aOnly = _v5.aOnly;
		var bOnly = _v5.bOnly;
		var both = _v5.both;
		var tyResSubs1 = A2(
			unifyBothRec,
			subs0,
			$elm$core$Dict$toList(both));
		return (_Utils_eq(aOnly, $elm$core$Dict$empty) && _Utils_eq(bOnly, $elm$core$Dict$empty)) ? tyResSubs1 : A2(
			$author$project$Compiler$TypeInference$do_nr,
			tyResSubs1,
			function (subs1) {
				var _v6 = _Utils_Tuple2(a_ext, b_ext);
				if (_v6.a.$ === 'Nothing') {
					if (_v6.b.$ === 'Just') {
						var _v8 = _v6.a;
						var bName = _v6.b.a;
						return (!_Utils_eq(bOnly, $elm$core$Dict$empty)) ? $author$project$Generator$wrap(
							$author$project$Types$Error$errorTodo('b has attributes that do not exist in a')) : $author$project$Generator$wrap(
							$elm$core$Result$Ok(
								A3(
									$elm$core$Dict$insert,
									bName,
									A3($author$project$Types$CanonicalAst$TypeRecord, $author$project$Compiler$TypeInference$todoPos, a_ext, a_attrs),
									subs1)));
					} else {
						var _v9 = _v6.a;
						var _v10 = _v6.b;
						return (_Utils_eq(bOnly, $elm$core$Dict$empty) && _Utils_eq(aOnly, $elm$core$Dict$empty)) ? $author$project$Generator$wrap(
							$elm$core$Result$Ok(subs1)) : $author$project$Generator$wrap(
							$author$project$Types$Error$errorTodo('the two records are just too different'));
					}
				} else {
					if (_v6.b.$ === 'Nothing') {
						var aName = _v6.a.a;
						var _v7 = _v6.b;
						return (!_Utils_eq(aOnly, $elm$core$Dict$empty)) ? $author$project$Generator$wrap(
							$author$project$Types$Error$errorTodo('a has attributes that do not exist in b')) : $author$project$Generator$wrap(
							$elm$core$Result$Ok(
								A3(
									$elm$core$Dict$insert,
									aName,
									A3($author$project$Types$CanonicalAst$TypeRecord, $author$project$Compiler$TypeInference$todoPos, b_ext, b_attrs),
									subs1)));
					} else {
						var aName = _v6.a.a;
						var bName = _v6.b.a;
						return A2(
							$author$project$Generator$do,
							$author$project$Compiler$TypeInference$newName,
							function (_new) {
								var subTy = A3(
									$author$project$Types$CanonicalAst$TypeRecord,
									$author$project$Compiler$TypeInference$todoPos,
									$elm$core$Maybe$Just(_new),
									A2($elm$core$Dict$union, bOnly, a_attrs));
								return $author$project$Generator$wrap(
									$elm$core$Result$Ok(
										A3(
											$elm$core$Dict$insert,
											bName,
											subTy,
											A3($elm$core$Dict$insert, aName, subTy, subs1))));
							});
					}
				}
			});
	});
var $author$project$Compiler$TypeInference$insertVariableFromDefinition = F5(
	function (mutable, maybeAnnotation, name, ty, _v0) {
		var env = _v0.a;
		var subs = _v0.b;
		var def = A3($author$project$Compiler$TypeInference$dict_get, 'SNH inspectPattern PatternAny', name, env);
		return A2(
			$author$project$Compiler$TypeInference$do_nr,
			A4(
				$author$project$Compiler$TypeInference$unify,
				{pos: $author$project$Compiler$TypeInference$todoPos, why: 'insertVariableFromDefinition'},
				ty,
				def.type_,
				subs),
			function (subs2) {
				var refinedType = A2($author$project$Compiler$TypeInference$refineType, subs2, def.type_);
				var forall = mutable ? $elm$core$Set$empty : A3(
					$author$project$Compiler$TypeInference$generalize,
					$elm$core$Set$singleton(name),
					A2($author$project$Compiler$TypeInference$refineEnv, subs2, env),
					refinedType);
				var scheme = {
					forall: forall,
					mutable: $elm$core$Maybe$Just(mutable),
					type_: refinedType
				};
				var env1 = A3($elm$core$Dict$insert, name, scheme, env);
				return $author$project$Generator$wrap(
					$elm$core$Result$Ok(
						_Utils_Tuple2(env1, subs2)));
			});
	});
var $author$project$Compiler$TypeInference$insertVariableFromLambda = F3(
	function (name, ty, _v0) {
		var env = _v0.a;
		var subs = _v0.b;
		return A2($elm$core$Dict$member, name, env) ? $author$project$Generator$wrap(
			$author$project$Types$Error$errorTodo('function parameter `' + (name + '` shadows env variable'))) : $author$project$Generator$wrap(
			$elm$core$Result$Ok(
				_Utils_Tuple2(
					A3(
						$elm$core$Dict$insert,
						name,
						{forall: $elm$core$Set$empty, mutable: $elm$core$Maybe$Nothing, type_: ty},
						env),
					subs)));
	});
var $author$project$Compiler$TypeInference$dict_fold_nr = F3(
	function (f, dict, accum) {
		return A3(
			$author$project$Compiler$TypeInference$list_foldl_nr,
			function (_v0) {
				var k = _v0.a;
				var v = _v0.b;
				return A2(f, k, v);
			},
			$elm$core$Dict$toList(dict),
			accum);
	});
var $author$project$Compiler$CoreModule$char = {
	args: _List_Nil,
	constructors: $elm$core$Dict$empty,
	name: $author$project$Compiler$CoreModule$root('Char')
};
var $author$project$Compiler$CoreModule$charType = A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$CoreModule$p, $author$project$Compiler$CoreModule$char.name, _List_Nil);
var $author$project$Compiler$CoreModule$number = {
	args: _List_Nil,
	constructors: $elm$core$Dict$empty,
	name: $author$project$Compiler$CoreModule$root('Number')
};
var $author$project$Compiler$CoreModule$numberType = A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$CoreModule$p, $author$project$Compiler$CoreModule$number.name, _List_Nil);
var $author$project$Compiler$CoreModule$text = {
	args: _List_Nil,
	constructors: $elm$core$Dict$empty,
	name: $author$project$Compiler$CoreModule$root('Text')
};
var $author$project$Compiler$CoreModule$textType = A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$CoreModule$p, $author$project$Compiler$CoreModule$text.name, _List_Nil);
var $author$project$Compiler$TypeInference$literalToType = function (l) {
	switch (l.$) {
		case 'Number':
			return $author$project$Compiler$CoreModule$numberType;
		case 'Text':
			return $author$project$Compiler$CoreModule$textType;
		default:
			return $author$project$Compiler$CoreModule$charType;
	}
};
var $author$project$Compiler$TypeInference$reversedZipConstructorArgs = F3(
	function (args, constructorType, accum) {
		reversedZipConstructorArgs:
		while (true) {
			switch (constructorType.$) {
				case 'TypeFunction':
					var from = constructorType.b;
					var fromIsMutable = constructorType.c;
					var to = constructorType.d;
					if (!args.b) {
						return $author$project$Types$Error$errorTodo('not enough arguments in constructor pattern');
					} else {
						var a = args.a;
						var aTail = args.b;
						var $temp$args = aTail,
							$temp$constructorType = to,
							$temp$accum = A2(
							$elm$core$List$cons,
							_Utils_Tuple2(a, from),
							accum);
						args = $temp$args;
						constructorType = $temp$constructorType;
						accum = $temp$accum;
						continue reversedZipConstructorArgs;
					}
				case 'TypeAlias':
					var ty = constructorType.c;
					var $temp$args = args,
						$temp$constructorType = ty,
						$temp$accum = accum;
					args = $temp$args;
					constructorType = $temp$constructorType;
					accum = $temp$accum;
					continue reversedZipConstructorArgs;
				default:
					if (!args.b) {
						return $elm$core$Result$Ok(
							_Utils_Tuple2(constructorType, accum));
					} else {
						var a = args.a;
						var aTail = args.b;
						return $author$project$Types$Error$errorTodo('too many arguments in constructor pattern');
					}
			}
		}
	});
var $author$project$Compiler$TypeInference$inspectPattern = F4(
	function (insertVariable, pattern, ty, _v0) {
		var env = _v0.a;
		var subs = _v0.b;
		switch (pattern.$) {
			case 'PatternDiscard':
				return $author$project$Generator$wrap(
					$elm$core$Result$Ok(
						_Utils_Tuple2(env, subs)));
			case 'PatternAny':
				var name = pattern.b;
				return A3(
					insertVariable,
					name,
					ty,
					_Utils_Tuple2(env, subs));
			case 'PatternLiteral':
				var literal = pattern.b;
				return A2(
					$author$project$Compiler$TypeInference$andEnv,
					env,
					A4(
						$author$project$Compiler$TypeInference$unify,
						{pos: $author$project$Compiler$TypeInference$todoPos, why: 'pattern literal'},
						ty,
						$author$project$Compiler$TypeInference$literalToType(literal),
						subs));
			case 'PatternConstructor':
				var path = pattern.b;
				var args = pattern.c;
				var _v2 = A2($elm$core$Dict$get, path, env);
				if (_v2.$ === 'Nothing') {
					return $author$project$Generator$wrap(
						$author$project$Types$Error$errorTodo('undeclared constructor: ' + path));
				} else {
					var envEntry = _v2.a;
					return A2(
						$author$project$Compiler$TypeInference$do_nr,
						$author$project$Generator$wrap(
							A3($author$project$Compiler$TypeInference$reversedZipConstructorArgs, args, envEntry.type_, _List_Nil)),
						function (_v3) {
							var patternType = _v3.a;
							var argsAndTypes = _v3.b;
							return A2(
								$author$project$Compiler$TypeInference$do_nr,
								A4(
									$author$project$Compiler$TypeInference$unify,
									{pos: $author$project$Compiler$TypeInference$todoPos, why: 'PatternConstructor'},
									ty,
									patternType,
									subs),
								function (subs1) {
									var fold = F2(
										function (_v4, eas) {
											var argPattern = _v4.a;
											var argType = _v4.b;
											return A4($author$project$Compiler$TypeInference$inspectPattern, insertVariable, argPattern, argType, eas);
										});
									return A3(
										$author$project$Compiler$TypeInference$list_foldl_nr,
										fold,
										argsAndTypes,
										_Utils_Tuple2(env, subs1));
								});
						});
				}
			default:
				var attrs = pattern.b;
				return A2(
					$author$project$Generator$do,
					$author$project$Compiler$TypeInference$newName,
					function (nn) {
						return A2(
							$author$project$Compiler$TypeInference$do_nr,
							A3(
								$author$project$Compiler$TypeInference$dict_fold_nr,
								F3(
									function (name, pa, acc) {
										return A2(
											$author$project$Generator$map,
											function (t) {
												return $elm$core$Result$Ok(
													A3($elm$core$Dict$insert, name, t, acc));
											},
											$author$project$Compiler$TypeInference$newType($author$project$Compiler$TypeInference$todoPos));
									}),
								attrs,
								$elm$core$Dict$empty),
							function (xxx) {
								return A2(
									$author$project$Compiler$TypeInference$do_nr,
									A4(
										$author$project$Compiler$TypeInference$unify,
										{pos: $author$project$Compiler$TypeInference$todoPos, why: 'PatternRecord'},
										ty,
										A3(
											$author$project$Types$CanonicalAst$TypeRecord,
											$author$project$Compiler$TypeInference$todoPos,
											$elm$core$Maybe$Just(nn),
											xxx),
										subs),
									function (s1) {
										var init = _Utils_Tuple2(
											$elm$core$Dict$empty,
											_Utils_Tuple2(env, s1));
										var fold = F3(
											function (name, pa, _v7) {
												var attrsAcc = _v7.a;
												var easAcc = _v7.b;
												var t = A3($author$project$Compiler$TypeInference$dict_get, 'inspectPattern: CA.PatternRecord', name, xxx);
												return A2(
													$author$project$Compiler$TypeInference$do_nr,
													A4($author$project$Compiler$TypeInference$inspectPattern, insertVariable, pa, t, easAcc),
													function (newEasAcc) {
														return $author$project$Generator$wrap(
															$elm$core$Result$Ok(
																_Utils_Tuple2(
																	A3($elm$core$Dict$insert, name, t, attrsAcc),
																	newEasAcc)));
													});
											});
										return A2(
											$author$project$Compiler$TypeInference$do_nr,
											A3($author$project$Compiler$TypeInference$dict_fold_nr, fold, attrs, init),
											function (_v5) {
												var attrTypes = _v5.a;
												var _v6 = _v5.b;
												var env1 = _v6.a;
												var subs1 = _v6.b;
												var refinedAttrTypes = A2(
													$elm$core$Dict$map,
													F2(
														function (attrName, attrType) {
															return A2($author$project$Compiler$TypeInference$refineType, subs1, attrType);
														}),
													attrTypes);
												return A2(
													$author$project$Compiler$TypeInference$andEnv,
													env1,
													A4(
														$author$project$Compiler$TypeInference$unify,
														{pos: $author$project$Compiler$TypeInference$todoPos, why: 'PatternRecord 2'},
														ty,
														A3(
															$author$project$Types$CanonicalAst$TypeRecord,
															$author$project$Compiler$TypeInference$todoPos,
															$elm$core$Maybe$Just(nn),
															refinedAttrTypes),
														subs1));
											});
									});
							});
					});
		}
	});
var $author$project$Compiler$TypeInference$inspectRecordAttributes = F3(
	function (inspectValue, attrs, eas) {
		var init = $author$project$Generator$wrap(
			$elm$core$Result$Ok(
				_Utils_Tuple2($elm$core$Dict$empty, eas)));
		var foldAttr = F3(
			function (attrName, attrValue, genResAccum) {
				return A2(
					$author$project$Compiler$TypeInference$do_nr,
					genResAccum,
					function (_v0) {
						var attrsAccum = _v0.a;
						var easAccum = _v0.b;
						return A2(
							$author$project$Generator$do,
							$author$project$Compiler$TypeInference$newType($author$project$Compiler$TypeInference$todoPos),
							function (nt) {
								return A2(
									$author$project$Compiler$TypeInference$do_nr,
									A3(inspectValue, attrValue, nt, easAccum),
									function (newEas) {
										return $author$project$Generator$wrap(
											$elm$core$Result$Ok(
												_Utils_Tuple2(
													A3($elm$core$Dict$insert, attrName, nt, attrsAccum),
													newEas)));
									});
							});
					});
			});
		return A3($elm$core$Dict$foldr, foldAttr, init, attrs);
	});
var $author$project$Compiler$CoreModule$noneValue = $author$project$Compiler$CoreModule$root('None');
var $author$project$Compiler$CoreModule$none = {
	args: _List_Nil,
	constructors: $elm$core$Dict$fromList(
		A2(
			$elm$core$List$map,
			function (c) {
				return _Utils_Tuple2(c.name, c.args);
			},
			_List_fromArray(
				[
					{args: _List_Nil, name: $author$project$Compiler$CoreModule$noneValue}
				]))),
	name: $author$project$Compiler$CoreModule$root('None')
};
var $author$project$Compiler$CoreModule$noneType = A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$CoreModule$p, $author$project$Compiler$CoreModule$none.name, _List_Nil);
var $author$project$Types$CanonicalAst$posToUid = function (pos) {
	return pos.n + (' ' + ($elm$core$String$fromInt(pos.s) + (' ' + $elm$core$String$fromInt(pos.e))));
};
var $author$project$Compiler$TypeInference$posToVarType = function (pos) {
	return A2(
		$author$project$Types$CanonicalAst$TypeVariable,
		pos,
		$author$project$Types$CanonicalAst$posToUid(pos));
};
var $author$project$Lib$Left = function (a) {
	return {$: 'Left', a: a};
};
var $author$project$Lib$Right = function (a) {
	return {$: 'Right', a: a};
};
var $author$project$Compiler$TypeInference$findAllRefs_arg = function (arg) {
	if (arg.$ === 'ArgumentMutable') {
		var ar = arg.a;
		return $elm$core$Set$singleton(ar.name);
	} else {
		var expr = arg.a;
		return $author$project$Compiler$TypeInference$findAllRefs_expr(expr);
	}
};
var $author$project$Compiler$TypeInference$findAllRefs_definition = function (def) {
	return A3(
		$elm$core$List$foldl,
		function (stat) {
			return $elm$core$Set$union(
				$author$project$Compiler$TypeInference$findAllRefs_statement(stat));
		},
		$elm$core$Set$empty,
		def.body);
};
var $author$project$Compiler$TypeInference$findAllRefs_expr = function (expr) {
	switch (expr.$) {
		case 'Literal':
			var args = expr.b;
			return $elm$core$Set$empty;
		case 'Variable':
			var args = expr.b;
			return $elm$core$Set$singleton(args.name);
		case 'Lambda':
			var parameter = expr.b;
			var body = expr.c;
			return $author$project$Compiler$TypeInference$findAllRefs_statementBlock(body);
		case 'Record':
			var _extends = expr.b;
			var attrs = expr.c;
			return A3(
				$elm$core$Dict$foldl,
				F2(
					function (name, value) {
						return $elm$core$Set$union(
							$author$project$Compiler$TypeInference$findAllRefs_expr(value));
					}),
				$elm$core$Set$empty,
				attrs);
		case 'Call':
			var reference = expr.b;
			var argument = expr.c;
			return A2(
				$elm$core$Set$union,
				$author$project$Compiler$TypeInference$findAllRefs_expr(reference),
				$author$project$Compiler$TypeInference$findAllRefs_arg(argument));
		case 'If':
			var condition = expr.b.condition;
			var _true = expr.b._true;
			var _false = expr.b._false;
			return A2(
				$elm$core$Set$union,
				$author$project$Compiler$TypeInference$findAllRefs_statementBlock(_false),
				A2(
					$elm$core$Set$union,
					$author$project$Compiler$TypeInference$findAllRefs_statementBlock(_true),
					$author$project$Compiler$TypeInference$findAllRefs_statementBlock(condition)));
		default:
			var value = expr.b;
			var patterns = expr.c;
			return function (refs) {
				return A3(
					$elm$core$List$foldl,
					function (_v2) {
						var pa = _v2.a;
						var block = _v2.b;
						return $elm$core$Set$union(
							$author$project$Compiler$TypeInference$findAllRefs_statementBlock(block));
					},
					refs,
					patterns);
			}(
				$author$project$Compiler$TypeInference$findAllRefs_expr(value));
	}
};
var $author$project$Compiler$TypeInference$findAllRefs_statement = function (stat) {
	if (stat.$ === 'Definition') {
		var def = stat.a;
		return $author$project$Compiler$TypeInference$findAllRefs_definition(def);
	} else {
		var expr = stat.a;
		return $author$project$Compiler$TypeInference$findAllRefs_expr(expr);
	}
};
var $author$project$Compiler$TypeInference$findAllRefs_statementBlock = function (statements) {
	return A3(
		$elm$core$List$foldl,
		function (stat) {
			return $elm$core$Set$union(
				$author$project$Compiler$TypeInference$findAllRefs_statement(stat));
		},
		$elm$core$Set$empty,
		statements);
};
var $author$project$Lib$partition = F2(
	function (f, ls) {
		var fold = F2(
			function (item, _v1) {
				var left = _v1.a;
				var right = _v1.b;
				var _v0 = f(item);
				if (_v0.$ === 'Left') {
					var l = _v0.a;
					return _Utils_Tuple2(
						A2($elm$core$List$cons, l, left),
						right);
				} else {
					var r = _v0.a;
					return _Utils_Tuple2(
						left,
						A2($elm$core$List$cons, r, right));
				}
			});
		return A3(
			$elm$core$List$foldr,
			fold,
			_Utils_Tuple2(_List_Nil, _List_Nil),
			ls);
	});
var $author$project$Compiler$TypeInference$reorderStatements = function (stats) {
	var definitionOrStatement = function (stat) {
		if (stat.$ === 'Definition') {
			var d = stat.a;
			return $author$project$Lib$Left(d);
		} else {
			return $author$project$Lib$Right(stat);
		}
	};
	var _v0 = A2($author$project$Lib$partition, definitionOrStatement, stats);
	var definitions = _v0.a;
	var nonDefs = _v0.b;
	var indexedDefs = A2($elm$core$List$indexedMap, $elm$core$Tuple$pair, definitions);
	var indexByName = A3(
		$elm$core$List$foldl,
		F2(
			function (_v2, dict) {
				var index = _v2.a;
				var def = _v2.b;
				return A3(
					$elm$core$Set$foldl,
					function (name) {
						return A2($elm$core$Dict$insert, name, index);
					},
					dict,
					$author$project$Types$CanonicalAst$patternNames(def.pattern));
			}),
		$elm$core$Dict$empty,
		indexedDefs);
	var findAllIndexes = function (_v1) {
		var index = _v1.a;
		var def = _v1.b;
		return $elm$core$Set$fromList(
			A2(
				$elm$core$List$filterMap,
				function (s) {
					return A2($elm$core$Dict$get, s, indexByName);
				},
				$elm$core$Set$toList(
					$author$project$Compiler$TypeInference$findAllRefs_definition(def))));
	};
	var orderedDefinitions = A3($author$project$RefHierarchy$reorder, $elm$core$Tuple$first, findAllIndexes, indexedDefs);
	var newStats = _Utils_ap(
		A2(
			$elm$core$List$map,
			A2($elm$core$Basics$composeR, $elm$core$Tuple$second, $author$project$Types$CanonicalAst$Definition),
			orderedDefinitions),
		nonDefs);
	return _Utils_Tuple2(definitions, newStats);
};
var $author$project$Compiler$TypeInference$typeContainsFunctions = function (ty) {
	typeContainsFunctions:
	while (true) {
		switch (ty.$) {
			case 'TypeConstant':
				return false;
			case 'TypeVariable':
				var name = ty.b;
				return false;
			case 'TypeFunction':
				var from = ty.b;
				var fromIsMutable = ty.c;
				var to = ty.d;
				return true;
			case 'TypeAlias':
				var path = ty.b;
				var t = ty.c;
				var $temp$ty = t;
				ty = $temp$ty;
				continue typeContainsFunctions;
			default:
				var extensible = ty.b;
				var attrs = ty.c;
				return A2(
					$elm$core$List$any,
					$author$project$Compiler$TypeInference$typeContainsFunctions,
					$elm$core$Dict$values(attrs));
		}
	}
};
var $author$project$Compiler$TypeInference$unifyWithAttrPath = F5(
	function (ctx, attrPath, typeAtPathEnd, valueType, subs) {
		if (!attrPath.b) {
			return A4($author$project$Compiler$TypeInference$unify, ctx, typeAtPathEnd, valueType, subs);
		} else {
			var head = attrPath.a;
			var tail = attrPath.b;
			return A2(
				$author$project$Generator$do,
				$author$project$Compiler$TypeInference$newName,
				function (n1) {
					return A2(
						$author$project$Generator$do,
						$author$project$Compiler$TypeInference$newType($author$project$Compiler$TypeInference$todoPos),
						function (t1) {
							var rType = A3(
								$author$project$Types$CanonicalAst$TypeRecord,
								$author$project$Compiler$TypeInference$todoPos,
								$elm$core$Maybe$Just(n1),
								A2($elm$core$Dict$singleton, head, t1));
							return A2(
								$author$project$Compiler$TypeInference$do_nr,
								A4($author$project$Compiler$TypeInference$unify, ctx, rType, valueType, subs),
								function (subs1) {
									return A5($author$project$Compiler$TypeInference$unifyWithAttrPath, ctx, tail, typeAtPathEnd, t1, subs1);
								});
						});
				});
		}
	});
var $author$project$Compiler$TypeInference$inspectArgument = F4(
	function (env, arg, ty, subs) {
		if (arg.$ === 'ArgumentMutable') {
			var name = arg.a.name;
			var attrPath = arg.a.attrPath;
			var _v31 = A2($elm$core$Dict$get, name, env);
			if (_v31.$ === 'Nothing') {
				return $author$project$Generator$wrap(
					$author$project$Types$Error$errorTodo('undeclared mutable variable: ' + name));
			} else {
				var schema = _v31.a;
				var _v32 = schema.mutable;
				if (_v32.$ === 'Nothing') {
					return A2(
						$author$project$Compiler$TypeInference$map_nr,
						function (s) {
							return _Utils_Tuple2(
								A3(
									$elm$core$Dict$insert,
									name,
									_Utils_update(
										schema,
										{
											mutable: $elm$core$Maybe$Just(true)
										}),
									env),
								s);
						},
						A5(
							$author$project$Compiler$TypeInference$unifyWithAttrPath,
							{pos: $author$project$Compiler$TypeInference$todoPos, why: 'ArgumentMutable'},
							attrPath,
							ty,
							schema.type_,
							subs));
				} else {
					if (_v32.a) {
						return A2(
							$author$project$Compiler$TypeInference$map_nr,
							function (s) {
								return _Utils_Tuple2(env, s);
							},
							A5(
								$author$project$Compiler$TypeInference$unifyWithAttrPath,
								{pos: $author$project$Compiler$TypeInference$todoPos, why: 'ArgumentMutable'},
								attrPath,
								ty,
								schema.type_,
								subs));
					} else {
						return $author$project$Generator$wrap(
							$author$project$Types$Error$errorTodo(name + ' can\'t be mutable'));
					}
				}
			}
		} else {
			var expr = arg.a;
			return A3(
				$author$project$Compiler$TypeInference$inspectExpr,
				expr,
				ty,
				_Utils_Tuple2(env, subs));
		}
	});
var $author$project$Compiler$TypeInference$inspectBlock = F3(
	function (stats, parentEnv, subs) {
		if (_Utils_eq(stats, _List_Nil)) {
			return A2(
				$author$project$Generator$do,
				$author$project$Compiler$TypeInference$newType($author$project$Compiler$TypeInference$todoPos),
				function (nt) {
					return $author$project$Generator$wrap(
						$elm$core$Result$Ok(
							_Utils_Tuple3(nt, parentEnv, subs)));
				});
		} else {
			var _v28 = $author$project$Compiler$TypeInference$reorderStatements(stats);
			var definitions = _v28.a;
			var newStats = _v28.b;
			return A2(
				$author$project$Compiler$TypeInference$do_nr,
				A3($author$project$Compiler$TypeInference$list_foldl_nr, $author$project$Compiler$TypeInference$insertDefinitionRec, definitions, parentEnv),
				function (localEnv) {
					return A2(
						$author$project$Compiler$TypeInference$do_nr,
						A4($author$project$Compiler$TypeInference$inspectStatementRec, newStats, $author$project$Compiler$CoreModule$noneType, localEnv, subs),
						function (typeAndEnvAndSubs) {
							return $author$project$Generator$wrap(
								function () {
									var definedMutables = A2(
										$elm$core$List$filter,
										function ($) {
											return $.mutable;
										},
										definitions);
									var _v29 = typeAndEnvAndSubs;
									var ty = _v29.a;
									var env = _v29.b;
									var nameContainsFunction = function (name) {
										return $author$project$Compiler$TypeInference$typeContainsFunctions(
											A3($author$project$Compiler$TypeInference$dict_get, 'SNH: nameContainsFunction', name, env).type_);
									};
									var defContainsFunctions = function (def) {
										return A2(
											$elm$core$List$any,
											nameContainsFunction,
											$elm$core$Set$toList(
												$author$project$Types$CanonicalAst$patternNames(def.pattern)));
									};
									var mutablesWithFunction = A2($elm$core$List$filter, defContainsFunctions, definedMutables);
									return (!_Utils_eq(mutablesWithFunction, _List_Nil)) ? $author$project$Types$Error$errorTodo(
										'these mutable values contain functions: ' + A2(
											$elm$core$String$join,
											', ',
											$elm$core$List$sort(
												$elm$core$Set$toList(
													A3(
														$elm$core$List$foldl,
														A2(
															$elm$core$Basics$composeR,
															function ($) {
																return $.pattern;
															},
															A2($elm$core$Basics$composeR, $author$project$Types$CanonicalAst$patternNames, $elm$core$Set$union)),
														$elm$core$Set$empty,
														mutablesWithFunction))))) : (((!_Utils_eq(definedMutables, _List_Nil)) && $author$project$Compiler$TypeInference$typeContainsFunctions(ty)) ? $author$project$Types$Error$errorTodo('statement blocks that define mutables can\'t return functions') : $elm$core$Result$Ok(typeAndEnvAndSubs));
								}());
						});
				});
		}
	});
var $author$project$Compiler$TypeInference$inspectExpr = F3(
	function (expr, ty, _v12) {
		var env = _v12.a;
		var subs = _v12.b;
		switch (expr.$) {
			case 'Literal':
				var pos = expr.a;
				var l = expr.b;
				return A2(
					$author$project$Compiler$TypeInference$andEnv,
					env,
					A4(
						$author$project$Compiler$TypeInference$unify,
						{pos: pos, why: 'Literal'},
						ty,
						$author$project$Compiler$TypeInference$literalToType(l),
						subs));
			case 'Variable':
				var pos = expr.a;
				var name = expr.b.name;
				var attrPath = expr.b.attrPath;
				return A2(
					$author$project$Compiler$TypeInference$do_nr,
					A3($author$project$Compiler$TypeInference$envGet, pos, name, env),
					function (nt) {
						var t = A2($author$project$Compiler$TypeInference$refineType, subs, nt);
						return A2(
							$author$project$Compiler$TypeInference$andEnv,
							env,
							A5(
								$author$project$Compiler$TypeInference$unifyWithAttrPath,
								{pos: pos, why: 'variable'},
								attrPath,
								ty,
								t,
								subs));
					});
			case 'Lambda':
				var pos = expr.a;
				var parameter = expr.b;
				var body = expr.c;
				return A2(
					$author$project$Generator$do,
					$author$project$Compiler$TypeInference$newType(pos),
					function (argTy) {
						return A2(
							$author$project$Compiler$TypeInference$do_nr,
							A4(
								$author$project$Compiler$TypeInference$inspectPattern,
								$author$project$Compiler$TypeInference$insertVariableFromLambda,
								parameter,
								argTy,
								_Utils_Tuple2(env, subs)),
							function (_v14) {
								var env1 = _v14.a;
								var subs1 = _v14.b;
								return A2(
									$author$project$Compiler$TypeInference$do_nr,
									A3($author$project$Compiler$TypeInference$inspectBlock, body, env1, subs1),
									function (_v15) {
										var returnType = _v15.a;
										var env2 = _v15.b;
										var subs2 = _v15.c;
										var lambdaTy = $author$project$Compiler$TypeInference$posToVarType(pos);
										var fromIsMutable_res = function () {
											switch (parameter.$) {
												case 'PatternDiscard':
													return $elm$core$Result$Ok(
														$elm$core$Maybe$Just(false));
												case 'PatternAny':
													var name = parameter.b;
													return $elm$core$Result$Ok(
														A3($author$project$Compiler$TypeInference$dict_get, 'SNH inspectExpr CA.Lambda', name, env2).mutable);
												default:
													return $author$project$Types$Error$errorTodo('unpacking mutable arguments is not supported =(');
											}
										}();
										return A2(
											$author$project$Compiler$TypeInference$do_nr,
											$author$project$Generator$wrap(fromIsMutable_res),
											function (fromIsMutable) {
												return A2(
													$author$project$Compiler$TypeInference$do_nr,
													A4(
														$author$project$Compiler$TypeInference$unify,
														{pos: pos, why: 'Lambda'},
														ty,
														A4($author$project$Types$CanonicalAst$TypeFunction, pos, argTy, fromIsMutable, lambdaTy),
														subs2),
													function (subs3) {
														return A2(
															$author$project$Compiler$TypeInference$andEnv,
															env,
															A4(
																$author$project$Compiler$TypeInference$unify,
																{pos: pos, why: 'Lambda return'},
																lambdaTy,
																returnType,
																subs3));
													});
											});
									});
							});
					});
			case 'Call':
				var pos = expr.a;
				var reference = expr.b;
				var argument = expr.c;
				return A2(
					$author$project$Generator$do,
					$author$project$Compiler$TypeInference$newType(pos),
					function (argumentTy) {
						return A2(
							$author$project$Compiler$TypeInference$do_nr,
							A4($author$project$Compiler$TypeInference$inspectArgument, env, argument, argumentTy, subs),
							function (_v17) {
								var env1 = _v17.a;
								var subs1 = _v17.b;
								var fromIsMutable = function () {
									if (argument.$ === 'ArgumentMutable') {
										return true;
									} else {
										return false;
									}
								}();
								var funTy = A4(
									$author$project$Types$CanonicalAst$TypeFunction,
									pos,
									argumentTy,
									$elm$core$Maybe$Just(fromIsMutable),
									ty);
								return A3(
									$author$project$Compiler$TypeInference$inspectExpr,
									reference,
									A2($author$project$Compiler$TypeInference$refineType, subs1, funTy),
									_Utils_Tuple2(
										A2($author$project$Compiler$TypeInference$refineEnv, subs1, env1),
										subs1));
							});
					});
			case 'Record':
				var pos = expr.a;
				var _extends = expr.b;
				var attrs = expr.c;
				return A2(
					$author$project$Compiler$TypeInference$do_nr,
					A3(
						$author$project$Compiler$TypeInference$inspectRecordAttributes,
						$author$project$Compiler$TypeInference$inspectExpr,
						attrs,
						_Utils_Tuple2(env, subs)),
					function (_v19) {
						var attrTypes = _v19.a;
						var _v20 = _v19.b;
						var env1 = _v20.a;
						var subs1 = _v20.b;
						return A2(
							$author$project$Compiler$TypeInference$do_nr,
							A4($author$project$Compiler$TypeInference$inspectMaybeExtensible, env1, _extends, ty, subs1),
							function (_v21) {
								var extensible = _v21.a;
								var _v22 = _v21.b;
								var env2 = _v22.a;
								var subs2 = _v22.b;
								var refinedAttrTypes = A2(
									$elm$core$Dict$map,
									F2(
										function (attrName, attrType) {
											return A2($author$project$Compiler$TypeInference$refineType, subs2, attrType);
										}),
									attrTypes);
								return A2(
									$author$project$Compiler$TypeInference$andEnv,
									env2,
									A4(
										$author$project$Compiler$TypeInference$unify,
										{pos: pos, why: 'Record'},
										ty,
										A3($author$project$Types$CanonicalAst$TypeRecord, pos, extensible, refinedAttrTypes),
										subs2));
							});
					});
			case 'If':
				var pos = expr.a;
				var ar = expr.b;
				return A2(
					$author$project$Compiler$TypeInference$do_nr,
					A3($author$project$Compiler$TypeInference$inspectBlock, ar.condition, env, subs),
					function (_v23) {
						var conditionType = _v23.a;
						var env1 = _v23.b;
						var subs1 = _v23.c;
						return A2(
							$author$project$Compiler$TypeInference$do_nr,
							A4(
								$author$project$Compiler$TypeInference$unify,
								{pos: pos, why: 'if condition'},
								conditionType,
								$author$project$Compiler$CoreModule$boolType,
								subs1),
							function (subs2) {
								return A2(
									$author$project$Compiler$TypeInference$do_nr,
									A3($author$project$Compiler$TypeInference$inspectBlock, ar._true, env1, subs2),
									function (_v24) {
										var inferredTrue = _v24.a;
										var subs3 = _v24.c;
										return A2(
											$author$project$Compiler$TypeInference$do_nr,
											A3($author$project$Compiler$TypeInference$inspectBlock, ar._false, env1, subs3),
											function (_v25) {
												var inferredFalse = _v25.a;
												var subs4 = _v25.c;
												return A2(
													$author$project$Compiler$TypeInference$do_nr,
													A4(
														$author$project$Compiler$TypeInference$unify,
														{pos: pos, why: 'true and false'},
														inferredTrue,
														inferredFalse,
														subs4),
													function (subs5) {
														return A2(
															$author$project$Compiler$TypeInference$do_nr,
															A4(
																$author$project$Compiler$TypeInference$unify,
																{pos: pos, why: 'if branch'},
																A2($author$project$Compiler$TypeInference$refineType, subs5, inferredTrue),
																ty,
																subs5),
															function (subs6) {
																return $author$project$Generator$wrap(
																	$elm$core$Result$Ok(
																		_Utils_Tuple2(
																			A2($author$project$Compiler$TypeInference$refineEnv, subs6, env1),
																			subs6)));
															});
													});
											});
									});
							});
					});
			default:
				var pos = expr.a;
				var value = expr.b;
				var tries = expr.c;
				var rawPatternTy = $author$project$Compiler$TypeInference$posToVarType(pos);
				return A2(
					$author$project$Generator$do,
					$author$project$Compiler$TypeInference$newType(pos),
					function (blockType) {
						return A2(
							$author$project$Compiler$TypeInference$do_nr,
							A3(
								$author$project$Compiler$TypeInference$inspectExpr,
								value,
								rawPatternTy,
								_Utils_Tuple2(env, subs)),
							function (_v26) {
								var env1 = _v26.a;
								var subs1 = _v26.b;
								var refPatternTy = A2($author$project$Compiler$TypeInference$refineType, subs1, rawPatternTy);
								var env2 = A2($author$project$Compiler$TypeInference$refineEnv, subs1, env1);
								return A2(
									$author$project$Compiler$TypeInference$do_nr,
									A3(
										$author$project$Compiler$TypeInference$list_foldl_nr,
										$author$project$Compiler$TypeInference$inspectPatternBlock(env2),
										tries,
										_Utils_Tuple3(refPatternTy, blockType, subs1)),
									function (_v27) {
										var subs2 = _v27.c;
										return A2(
											$author$project$Compiler$TypeInference$do_nr,
											A4(
												$author$project$Compiler$TypeInference$unify,
												{pos: pos, why: 'try'},
												blockType,
												ty,
												subs2),
											function (subs3) {
												return $author$project$Generator$wrap(
													$elm$core$Result$Ok(
														_Utils_Tuple2(
															A2($author$project$Compiler$TypeInference$refineEnv, subs3, env2),
															subs3)));
											});
									});
							});
					});
		}
	});
var $author$project$Compiler$TypeInference$inspectMaybeExtensible = F4(
	function (env, maybeUpdateTarget, ty, subs) {
		if (maybeUpdateTarget.$ === 'Nothing') {
			return $author$project$Generator$wrap(
				$elm$core$Result$Ok(
					_Utils_Tuple2(
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(env, subs))));
		} else {
			var updateTarget = maybeUpdateTarget.a;
			return A2(
				$author$project$Generator$do,
				$author$project$Compiler$TypeInference$newName,
				function (n) {
					return A2(
						$author$project$Compiler$TypeInference$map_nr,
						function (eas) {
							return _Utils_Tuple2(
								$elm$core$Maybe$Just(n),
								eas);
						},
						A3(
							$author$project$Compiler$TypeInference$inspectExpr,
							A2($author$project$Types$CanonicalAst$Variable, $author$project$Compiler$TypeInference$todoPos, updateTarget),
							ty,
							_Utils_Tuple2(env, subs)));
				});
		}
	});
var $author$project$Compiler$TypeInference$inspectPatternBlock = F3(
	function (env, _v7, _v8) {
		var pattern = _v7.a;
		var block = _v7.b;
		var patternType = _v8.a;
		var expectedBlockType = _v8.b;
		var subs = _v8.c;
		return A2(
			$author$project$Compiler$TypeInference$do_nr,
			A4(
				$author$project$Compiler$TypeInference$inspectPattern,
				$author$project$Compiler$TypeInference$insertVariableFromLambda,
				pattern,
				patternType,
				_Utils_Tuple2(env, subs)),
			function (_v9) {
				var env1 = _v9.a;
				var subs1 = _v9.b;
				return A2(
					$author$project$Compiler$TypeInference$do_nr,
					A3($author$project$Compiler$TypeInference$inspectBlock, block, env1, subs1),
					function (_v10) {
						var inferredBlockType = _v10.a;
						var subs2 = _v10.c;
						return A2(
							$author$project$Compiler$TypeInference$do_nr,
							A4(
								$author$project$Compiler$TypeInference$unify,
								{pos: $author$project$Compiler$TypeInference$todoPos, why: 'pa block'},
								expectedBlockType,
								inferredBlockType,
								subs2),
							function (subs3) {
								return $author$project$Generator$wrap(
									$elm$core$Result$Ok(
										_Utils_Tuple3(
											A2($author$project$Compiler$TypeInference$refineType, subs3, patternType),
											A2($author$project$Compiler$TypeInference$refineType, subs3, inferredBlockType),
											subs3)));
							});
					});
			});
	});
var $author$project$Compiler$TypeInference$inspectStatement = F3(
	function (statement, env, subs) {
		if (statement.$ === 'Evaluation') {
			var expr = statement.a;
			return A2(
				$author$project$Generator$do,
				$author$project$Compiler$TypeInference$newType($author$project$Compiler$TypeInference$todoPos),
				function (nt) {
					return A2(
						$author$project$Compiler$TypeInference$do_nr,
						A3(
							$author$project$Compiler$TypeInference$inspectExpr,
							expr,
							nt,
							_Utils_Tuple2(env, subs)),
						function (_v3) {
							var env1 = _v3.a;
							var subs1 = _v3.b;
							var refinedNt = A2($author$project$Compiler$TypeInference$refineType, subs1, nt);
							return $author$project$Generator$wrap(
								$elm$core$Result$Ok(
									_Utils_Tuple3(refinedNt, env1, subs1)));
						});
				});
		} else {
			var pattern = statement.a.pattern;
			var mutable = statement.a.mutable;
			var body = statement.a.body;
			var maybeAnnotation = statement.a.maybeAnnotation;
			var insert = A2($author$project$Compiler$TypeInference$insertVariableFromDefinition, mutable, maybeAnnotation);
			return A2(
				$author$project$Compiler$TypeInference$do_nr,
				A3($author$project$Compiler$TypeInference$inspectBlock, body, env, subs),
				function (_v4) {
					var bodyType = _v4.a;
					var subs1 = _v4.c;
					return A2(
						$author$project$Compiler$TypeInference$do_nr,
						A4(
							$author$project$Compiler$TypeInference$inspectPattern,
							insert,
							pattern,
							bodyType,
							_Utils_Tuple2(env, subs1)),
						function (_v5) {
							var env1 = _v5.a;
							var subs2 = _v5.b;
							var refinedType = A2($author$project$Compiler$TypeInference$refineType, subs2, bodyType);
							var names = $author$project$Types$CanonicalAst$patternNames(pattern);
							var forall = mutable ? $elm$core$Set$empty : A3(
								$author$project$Compiler$TypeInference$generalize,
								names,
								A2($author$project$Compiler$TypeInference$refineEnv, subs2, env),
								refinedType);
							var _v6 = A2(
								$elm$core$Maybe$map,
								function (ann) {
									return A2($author$project$Compiler$TypeInference$annotationTooGeneral, ann, forall);
								},
								maybeAnnotation);
							if ((_v6.$ === 'Just') && (_v6.a.$ === 'Just')) {
								var error = _v6.a.a;
								return $author$project$Generator$wrap(
									$author$project$Types$Error$errorTodo(error));
							} else {
								return $author$project$Generator$wrap(
									$elm$core$Result$Ok(
										_Utils_Tuple3(
											$author$project$Compiler$CoreModule$noneType,
											A2($author$project$Compiler$TypeInference$refineEnv, subs2, env1),
											subs2)));
							}
						});
				});
		}
	});
var $author$project$Compiler$TypeInference$inspectStatementRec = F4(
	function (stats, returnType, env, subs) {
		if (!stats.b) {
			return $author$project$Generator$wrap(
				$elm$core$Result$Ok(
					_Utils_Tuple3(returnType, env, subs)));
		} else {
			var stat = stats.a;
			var statsTail = stats.b;
			return A2(
				$author$project$Compiler$TypeInference$do_nr,
				A3($author$project$Compiler$TypeInference$inspectStatement, stat, env, subs),
				function (_v1) {
					var ty = _v1.a;
					var env1 = _v1.b;
					var subs1 = _v1.c;
					return A4($author$project$Compiler$TypeInference$inspectStatementRec, statsTail, ty, env1, subs1);
				});
		}
	});
var $author$project$Generator$run = F2(
	function (s, _v0) {
		var a = _v0.a;
		return a(s);
	});
var $author$project$Compiler$TypeInference$inspectModule = F2(
	function (prelude, mod) {
		return A2(
			$author$project$Lib$result_do,
			A3(
				$author$project$Lib$dict_foldRes,
				function (k) {
					return $author$project$Compiler$TypeInference$addConstructors;
				},
				mod,
				prelude),
			function (env) {
				var asValue = function (rootDef) {
					if (rootDef.$ === 'Value') {
						var v = rootDef.a;
						return $elm$core$Maybe$Just(v);
					} else {
						return $elm$core$Maybe$Nothing;
					}
				};
				var statements = A2(
					$elm$core$List$map,
					$author$project$Types$CanonicalAst$Definition,
					A2(
						$elm$core$List$filterMap,
						asValue,
						$elm$core$Dict$values(mod)));
				var gen = A2(
					$author$project$Compiler$TypeInference$do_nr,
					A3($author$project$Compiler$TypeInference$inspectBlock, statements, env, $elm$core$Dict$empty),
					function (_v0) {
						var shouldBeNone = _v0.a;
						var env1 = _v0.b;
						var subs = _v0.c;
						return $author$project$Generator$wrap(
							$elm$core$Result$Ok(
								_Utils_Tuple3(
									mod,
									A2($author$project$Compiler$TypeInference$refineEnv, subs, env1),
									subs)));
					});
				return A2($author$project$Generator$run, 0, gen).a;
			});
	});
var $elm$html$Html$li = _VirtualDom_node('li');
var $author$project$Compiler$CanonicalToJs$nativeDefinitions = '\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(clone);\n\n if (typeof(src) === \'object\') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\nconst sp_divide = (right) => (left) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\nconst sp_todo = (message) => {\n  throw new Error("TODO: " + message);\n}\n\nconst sp_log = (message) => (thing) => {\n  console.log(message, thing);\n  return thing;\n}\n\n\nconst text_fromInt = (n) => \'\' + n;\n    ';
var $elm$html$Html$pre = _VirtualDom_node('pre');
var $author$project$Types$CanonicalAst$PatternAny = F2(
	function (a, b) {
		return {$: 'PatternAny', a: a, b: b};
	});
var $author$project$Prelude$pos = {c: '', e: -1, n: 'prelude', s: -1};
var $author$project$Prelude$nativeBinop = function (ar) {
	return _Utils_Tuple2(
		ar.symbol,
		$author$project$Types$CanonicalAst$Value(
			{
				body: _List_Nil,
				maybeAnnotation: $elm$core$Maybe$Just(
					A4(
						$author$project$Types$CanonicalAst$TypeFunction,
						$author$project$Prelude$pos,
						ar.left,
						$elm$core$Maybe$Just(false),
						A4(
							$author$project$Types$CanonicalAst$TypeFunction,
							$author$project$Prelude$pos,
							ar.right,
							$elm$core$Maybe$Just(ar.mutates),
							ar._return))),
				mutable: false,
				pattern: A2($author$project$Types$CanonicalAst$PatternAny, $author$project$Prelude$pos, ar.symbol)
			}));
};
var $author$project$Prelude$add = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$numberType, mutates: false, _return: $author$project$Compiler$CoreModule$numberType, right: $author$project$Compiler$CoreModule$numberType, symbol: '+'});
var $author$project$Compiler$CoreModule$listCons = {
	args: _List_fromArray(
		[
			A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Compiler$CoreModule$p, 'item'),
			A3(
			$author$project$Types$CanonicalAst$TypeConstant,
			$author$project$Compiler$CoreModule$p,
			$author$project$Compiler$CoreModule$root('List'),
			_List_fromArray(
				[
					A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Compiler$CoreModule$p, 'item')
				]))
		]),
	name: $author$project$Compiler$CoreModule$root('Cons')
};
var $author$project$Compiler$CoreModule$listNil = {
	args: _List_Nil,
	name: $author$project$Compiler$CoreModule$root('Nil')
};
var $author$project$Compiler$CoreModule$list = {
	args: _List_fromArray(
		['item']),
	constructors: $elm$core$Dict$fromList(
		A2(
			$elm$core$List$map,
			function (c) {
				return _Utils_Tuple2(c.name, c.args);
			},
			_List_fromArray(
				[$author$project$Compiler$CoreModule$listNil, $author$project$Compiler$CoreModule$listCons]))),
	name: $author$project$Compiler$CoreModule$root('List')
};
var $author$project$Compiler$CoreModule$coreModule = function () {
	var u = function (uDef) {
		return _Utils_Tuple2(
			uDef.name,
			$author$project$Types$CanonicalAst$Union(uDef));
	};
	return $elm$core$Dict$fromList(
		_List_fromArray(
			[
				u($author$project$Compiler$CoreModule$none),
				u($author$project$Compiler$CoreModule$bool),
				u($author$project$Compiler$CoreModule$list),
				u($author$project$Compiler$CoreModule$text),
				u($author$project$Compiler$CoreModule$number),
				u($author$project$Compiler$CoreModule$char)
			]));
}();
var $author$project$Prelude$debugLog = _Utils_Tuple2(
	'SPCore/Debug.log',
	$author$project$Types$CanonicalAst$Value(
		{
			body: _List_Nil,
			maybeAnnotation: $elm$core$Maybe$Just(
				A4(
					$author$project$Types$CanonicalAst$TypeFunction,
					$author$project$Prelude$pos,
					$author$project$Compiler$CoreModule$textType,
					$elm$core$Maybe$Just(false),
					A4(
						$author$project$Types$CanonicalAst$TypeFunction,
						$author$project$Prelude$pos,
						A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Prelude$pos, 'a'),
						$elm$core$Maybe$Just(false),
						A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Prelude$pos, 'a')))),
			mutable: false,
			pattern: A2($author$project$Types$CanonicalAst$PatternAny, $author$project$Prelude$pos, 'SPCore/Debug.log')
		}));
var $author$project$Prelude$debugTodo = _Utils_Tuple2(
	'SPCore/Debug.todo',
	$author$project$Types$CanonicalAst$Value(
		{
			body: _List_Nil,
			maybeAnnotation: $elm$core$Maybe$Just(
				A4(
					$author$project$Types$CanonicalAst$TypeFunction,
					$author$project$Prelude$pos,
					$author$project$Compiler$CoreModule$textType,
					$elm$core$Maybe$Just(false),
					A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Prelude$pos, 'a'))),
			mutable: false,
			pattern: A2($author$project$Types$CanonicalAst$PatternAny, $author$project$Prelude$pos, 'SPCore/Debug.todo')
		}));
var $author$project$Prelude$divide = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$numberType, mutates: false, _return: $author$project$Compiler$CoreModule$numberType, right: $author$project$Compiler$CoreModule$numberType, symbol: '/'});
var $author$project$Prelude$greaterThan = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$numberType, mutates: false, _return: $author$project$Compiler$CoreModule$boolType, right: $author$project$Compiler$CoreModule$numberType, symbol: '>'});
var $author$project$Prelude$lesserThan = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$numberType, mutates: false, _return: $author$project$Compiler$CoreModule$boolType, right: $author$project$Compiler$CoreModule$numberType, symbol: '<'});
var $author$project$Prelude$multiply = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$numberType, mutates: false, _return: $author$project$Compiler$CoreModule$numberType, right: $author$project$Compiler$CoreModule$numberType, symbol: '*'});
var $author$project$Prelude$mutableAdd = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$numberType, mutates: true, _return: $author$project$Compiler$CoreModule$noneType, right: $author$project$Compiler$CoreModule$numberType, symbol: '+='});
var $author$project$Prelude$mutableAssign = $author$project$Prelude$nativeBinop(
	{
		left: A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Prelude$pos, 'a'),
		mutates: true,
		_return: $author$project$Compiler$CoreModule$noneType,
		right: A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Prelude$pos, 'a'),
		symbol: ':='
	});
var $author$project$Prelude$function = F2(
	function (from, to) {
		return A4($author$project$Types$CanonicalAst$TypeFunction, $author$project$Prelude$pos, from, $elm$core$Maybe$Nothing, to);
	});
var $author$project$Prelude$tyVar = function (n) {
	return A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Prelude$pos, n);
};
var $author$project$Prelude$sendLeft = $author$project$Prelude$nativeBinop(
	{
		left: A2(
			$author$project$Prelude$function,
			$author$project$Prelude$tyVar('a'),
			$author$project$Prelude$tyVar('b')),
		mutates: false,
		_return: $author$project$Prelude$tyVar('b'),
		right: $author$project$Prelude$tyVar('a'),
		symbol: '<<'
	});
var $author$project$Prelude$sendRight = $author$project$Prelude$nativeBinop(
	{
		left: $author$project$Prelude$tyVar('a'),
		mutates: false,
		_return: $author$project$Prelude$tyVar('b'),
		right: A2(
			$author$project$Prelude$function,
			$author$project$Prelude$tyVar('a'),
			$author$project$Prelude$tyVar('b')),
		symbol: '>>'
	});
var $author$project$Prelude$stringConcat = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$textType, mutates: false, _return: $author$project$Compiler$CoreModule$textType, right: $author$project$Compiler$CoreModule$textType, symbol: '..'});
var $author$project$Prelude$subtract = $author$project$Prelude$nativeBinop(
	{left: $author$project$Compiler$CoreModule$numberType, mutates: false, _return: $author$project$Compiler$CoreModule$numberType, right: $author$project$Compiler$CoreModule$numberType, symbol: '-'});
var $author$project$Prelude$prelude = A3(
	$elm$core$List$foldl,
	function (_v0) {
		var n = _v0.a;
		var v = _v0.b;
		return A2($elm$core$Dict$insert, n, v);
	},
	$author$project$Compiler$CoreModule$coreModule,
	_List_fromArray(
		[$author$project$Prelude$mutableAssign, $author$project$Prelude$add, $author$project$Prelude$subtract, $author$project$Prelude$multiply, $author$project$Prelude$divide, $author$project$Prelude$mutableAdd, $author$project$Prelude$lesserThan, $author$project$Prelude$greaterThan, $author$project$Prelude$stringConcat, $author$project$Prelude$sendRight, $author$project$Prelude$sendLeft, $author$project$Prelude$debugTodo, $author$project$Prelude$debugLog]));
var $author$project$Types$Error$flatten = F2(
	function (e, accum) {
		if (e.$ === 'Simple') {
			var ar = e.a;
			return A2($elm$core$List$cons, ar, accum);
		} else {
			var ls = e.a;
			return A3($elm$core$List$foldl, $author$project$Types$Error$flatten, accum, ls);
		}
	});
var $elm$core$String$cons = _String_cons;
var $elm$core$String$fromChar = function (_char) {
	return A2($elm$core$String$cons, _char, '');
};
var $elm$core$String$padLeft = F3(
	function (n, _char, string) {
		return _Utils_ap(
			A2(
				$elm$core$String$repeat,
				n - $elm$core$String$length(string),
				$elm$core$String$fromChar(_char)),
			string);
	});
var $author$project$Types$Error$contentDivToString = function (div) {
	switch (div.$) {
		case 'Text':
			var s = div.a;
			return s;
		case 'CodeBlock':
			var s = div.a;
			return '\n```\n' + (s + '\n```\n');
		default:
			var start = div.a;
			var ls = div.b;
			var pad = $elm$core$String$length(
				$elm$core$String$fromInt(
					start + $elm$core$List$length(ls)));
			var fmtLine = F2(
				function (index, line) {
					return A3(
						$elm$core$String$padLeft,
						pad,
						_Utils_chr(' '),
						$elm$core$String$fromInt(index + start)) + (' | ' + line);
				});
			return function (s) {
				return s + '\n';
			}(
				A2(
					$elm$core$String$join,
					'\n',
					A2($elm$core$List$indexedMap, fmtLine, ls)));
	}
};
var $author$project$Types$Error$toString = function (eArgs) {
	var hr = '== ERROR!!! ==================================';
	var file = (eArgs.file !== '') ? _List_fromArray(
		['# ' + eArgs.file, '']) : _List_Nil;
	var content = A2(
		$elm$core$List$map,
		$elm$core$Basics$append('  '),
		A2(
			$elm$core$List$concatMap,
			A2(
				$elm$core$Basics$composeR,
				$author$project$Types$Error$contentDivToString,
				$elm$core$String$split('\n')),
			eArgs.content));
	return A2(
		$elm$core$String$join,
		'\n',
		A2(
			$elm$core$List$cons,
			hr,
			_Utils_ap(file, content)));
};
var $author$project$Compiler$TestHelpers$resErrorToString = $elm$core$Result$mapError(
	function (e) {
		return A2(
			$elm$core$String$join,
			'\n\n',
			A2(
				$elm$core$List$map,
				$author$project$Types$Error$toString,
				A2($author$project$Types$Error$flatten, e, _List_Nil)));
	});
var $elm$core$Maybe$isJust = function (maybe) {
	if (maybe.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $elm_explorations$markdown$Markdown$eval = _Markdown_eval;
var $author$project$Compiler$CanonicalToJs$getValueDefName = function (def) {
	return A2(
		$elm$core$Maybe$withDefault,
		'BLARGH',
		$elm$core$List$head(
			$elm$core$Set$toList(
				$author$project$Types$CanonicalAst$patternNames(def.pattern))));
};
var $author$project$Types$CanonicalAst$FoldExpr = function (a) {
	return {$: 'FoldExpr', a: a};
};
var $author$project$Types$CanonicalAst$Literal = F2(
	function (a, b) {
		return {$: 'Literal', a: a, b: b};
	});
var $author$project$Types$CanonicalAst$FoldPattern = function (a) {
	return {$: 'FoldPattern', a: a};
};
var $author$project$Types$CanonicalAst$PatternConstructor = F3(
	function (a, b, c) {
		return {$: 'PatternConstructor', a: a, b: b, c: c};
	});
var $author$project$Types$CanonicalAst$PatternDiscard = function (a) {
	return {$: 'PatternDiscard', a: a};
};
var $author$project$Types$CanonicalAst$PatternLiteral = F2(
	function (a, b) {
		return {$: 'PatternLiteral', a: a, b: b};
	});
var $author$project$Types$CanonicalAst$extensionFold_pattern = F2(
	function (fFold, _v0) {
		var pattern = _v0.a;
		var acc = _v0.b;
		var f = A2($elm$core$Basics$composeR, $author$project$Types$CanonicalAst$FoldPattern, fFold);
		switch (pattern.$) {
			case 'PatternDiscard':
				var a_pos = pattern.a;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_pos) {
						return $author$project$Types$CanonicalAst$PatternDiscard(b_pos);
					},
					A2(
						f,
						pattern,
						_Utils_Tuple2(a_pos, acc)));
			case 'PatternAny':
				var a_pos = pattern.a;
				var name = pattern.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_pos) {
						return A2($author$project$Types$CanonicalAst$PatternAny, b_pos, name);
					},
					A2(
						f,
						pattern,
						_Utils_Tuple2(a_pos, acc)));
			case 'PatternLiteral':
				var a_pos = pattern.a;
				var value = pattern.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_pos) {
						return A2($author$project$Types$CanonicalAst$PatternLiteral, b_pos, value);
					},
					A2(
						f,
						pattern,
						_Utils_Tuple2(a_pos, acc)));
			case 'PatternConstructor':
				var a_pos = pattern.a;
				var name = pattern.b;
				var a_args = pattern.c;
				var fold = F2(
					function (a_arg, _v4) {
						var b_args = _v4.a;
						var accX = _v4.b;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (b_arg) {
								return A2($elm$core$List$cons, b_arg, b_args);
							},
							A2(
								$author$project$Types$CanonicalAst$extensionFold_pattern,
								fFold,
								_Utils_Tuple2(a_arg, accX)));
					});
				var _v2 = A2(
					f,
					pattern,
					_Utils_Tuple2(a_pos, acc));
				var b_pos = _v2.a;
				var acc1 = _v2.b;
				var _v3 = A3(
					$elm$core$List$foldr,
					fold,
					_Utils_Tuple2(_List_Nil, acc1),
					a_args);
				var b_as = _v3.a;
				var acc2 = _v3.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$PatternConstructor, b_pos, name, b_as),
					acc2);
			default:
				var a_pos = pattern.a;
				var attrs = pattern.b;
				return _Debug_todo(
					'Types.CanonicalAst',
					{
						start: {line: 603, column: 13},
						end: {line: 603, column: 23}
					})('');
		}
	});
var $author$project$Types$CanonicalAst$FoldType = function (a) {
	return {$: 'FoldType', a: a};
};
var $author$project$Types$CanonicalAst$extensionFold_type = F2(
	function (f, _v0) {
		var ty = _v0.a;
		var acc0 = _v0.b;
		var fty = f(
			$author$project$Types$CanonicalAst$FoldType(ty));
		switch (ty.$) {
			case 'TypeConstant':
				var a_pos = ty.a;
				var name = ty.b;
				var a_args = ty.c;
				var fold = F2(
					function (a_arg, _v4) {
						var args = _v4.a;
						var accX = _v4.b;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (b_arg) {
								return A2($elm$core$List$cons, b_arg, args);
							},
							A2(
								$author$project$Types$CanonicalAst$extensionFold_type,
								f,
								_Utils_Tuple2(a_arg, accX)));
					});
				var _v2 = fty(
					_Utils_Tuple2(a_pos, acc0));
				var b_pos = _v2.a;
				var acc1 = _v2.b;
				var _v3 = A3(
					$elm$core$List$foldr,
					fold,
					_Utils_Tuple2(_List_Nil, acc1),
					a_args);
				var b_args = _v3.a;
				var acc2 = _v3.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$TypeConstant, b_pos, name, b_args),
					acc2);
			case 'TypeVariable':
				var a_pos = ty.a;
				var name = ty.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_pos) {
						return A2($author$project$Types$CanonicalAst$TypeVariable, b_pos, name);
					},
					fty(
						_Utils_Tuple2(a_pos, acc0)));
			case 'TypeFunction':
				var a_pos = ty.a;
				var a_from = ty.b;
				var fromIsMut = ty.c;
				var a_to = ty.d;
				var _v5 = fty(
					_Utils_Tuple2(a_pos, acc0));
				var b_pos = _v5.a;
				var acc1 = _v5.b;
				var _v6 = A2(
					$author$project$Types$CanonicalAst$extensionFold_type,
					f,
					_Utils_Tuple2(a_from, acc1));
				var b_from = _v6.a;
				var acc2 = _v6.b;
				var _v7 = A2(
					$author$project$Types$CanonicalAst$extensionFold_type,
					f,
					_Utils_Tuple2(a_to, acc2));
				var b_to = _v7.a;
				var acc3 = _v7.b;
				return _Utils_Tuple2(
					A4($author$project$Types$CanonicalAst$TypeFunction, b_pos, b_from, fromIsMut, b_to),
					acc3);
			case 'TypeRecord':
				var a_pos = ty.a;
				var ext = ty.b;
				var a_attrs = ty.c;
				var fold = F3(
					function (attr_name, a_ty, _v10) {
						var attrs = _v10.a;
						var accX = _v10.b;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (b_arg) {
								return A3($elm$core$Dict$insert, attr_name, b_arg, attrs);
							},
							A2(
								$author$project$Types$CanonicalAst$extensionFold_type,
								f,
								_Utils_Tuple2(a_ty, accX)));
					});
				var _v8 = fty(
					_Utils_Tuple2(a_pos, acc0));
				var b_pos = _v8.a;
				var acc1 = _v8.b;
				var _v9 = A3(
					$elm$core$Dict$foldl,
					fold,
					_Utils_Tuple2($elm$core$Dict$empty, acc1),
					a_attrs);
				var b_attrs = _v9.a;
				var acc2 = _v9.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$TypeRecord, b_pos, ext, b_attrs),
					acc2);
			default:
				var a_pos = ty.a;
				var name = ty.b;
				var a_ty = ty.c;
				var _v11 = fty(
					_Utils_Tuple2(a_pos, acc0));
				var b_pos = _v11.a;
				var acc1 = _v11.b;
				var _v12 = A2(
					$author$project$Types$CanonicalAst$extensionFold_type,
					f,
					_Utils_Tuple2(a_ty, acc1));
				var b_ty = _v12.a;
				var acc2 = _v12.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$TypeAlias, b_pos, name, b_ty),
					acc2);
		}
	});
var $author$project$Types$CanonicalAst$extensionFold_argument = F2(
	function (f, _v31) {
		var arg = _v31.a;
		var acc = _v31.b;
		if (arg.$ === 'ArgumentExpression') {
			var expr = arg.a;
			return A2(
				$elm$core$Tuple$mapFirst,
				$author$project$Types$CanonicalAst$ArgumentExpression,
				A2(
					$author$project$Types$CanonicalAst$extensionFold_expression,
					f,
					_Utils_Tuple2(expr, acc)));
		} else {
			var ar = arg.a;
			return _Utils_Tuple2(arg, acc);
		}
	});
var $author$project$Types$CanonicalAst$extensionFold_block = F2(
	function (f, _v29) {
		var block = _v29.a;
		var acc = _v29.b;
		var fold = F2(
			function (a_stat, _v30) {
				var b_stats = _v30.a;
				var accX = _v30.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_stat) {
						return A2($elm$core$List$cons, b_stat, b_stats);
					},
					A2(
						$author$project$Types$CanonicalAst$extensionFold_statement,
						f,
						_Utils_Tuple2(a_stat, accX)));
			});
		return A3(
			$elm$core$List$foldr,
			fold,
			_Utils_Tuple2(_List_Nil, acc),
			block);
	});
var $author$project$Types$CanonicalAst$extensionFold_expression = F2(
	function (fFold, _v7) {
		var expr = _v7.a;
		var acc = _v7.b;
		var f = A2($elm$core$Basics$composeR, $author$project$Types$CanonicalAst$FoldExpr, fFold);
		switch (expr.$) {
			case 'Literal':
				var a_pos = expr.a;
				var ar = expr.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_pos) {
						return A2($author$project$Types$CanonicalAst$Literal, b_pos, ar);
					},
					A2(
						f,
						expr,
						_Utils_Tuple2(a_pos, acc)));
			case 'Variable':
				var a_pos = expr.a;
				var args = expr.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_pos) {
						return A2($author$project$Types$CanonicalAst$Variable, b_pos, args);
					},
					A2(
						f,
						expr,
						_Utils_Tuple2(a_pos, acc)));
			case 'Lambda':
				var a_pos = expr.a;
				var a_pattern = expr.b;
				var a_body = expr.c;
				var _v9 = A2(
					f,
					expr,
					_Utils_Tuple2(a_pos, acc));
				var b_pos = _v9.a;
				var acc1 = _v9.b;
				var _v10 = A2(
					$author$project$Types$CanonicalAst$extensionFold_block,
					fFold,
					_Utils_Tuple2(a_body, acc1));
				var b_body = _v10.a;
				var acc2 = _v10.b;
				var _v11 = A2(
					$author$project$Types$CanonicalAst$extensionFold_pattern,
					fFold,
					_Utils_Tuple2(a_pattern, acc2));
				var b_pattern = _v11.a;
				var acc3 = _v11.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$Lambda, b_pos, b_pattern, b_body),
					acc3);
			case 'Record':
				var a_pos = expr.a;
				var a_ext = expr.b;
				var a_attrs = expr.c;
				var fold = F3(
					function (name, a_expr, _v14) {
						var attrs = _v14.a;
						var aX = _v14.b;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (b_expr) {
								return A3($elm$core$Dict$insert, name, b_expr, attrs);
							},
							A2(
								$author$project$Types$CanonicalAst$extensionFold_expression,
								fFold,
								_Utils_Tuple2(a_expr, aX)));
					});
				var _v12 = A2(
					f,
					expr,
					_Utils_Tuple2(a_pos, acc));
				var b_pos = _v12.a;
				var acc1 = _v12.b;
				var _v13 = A3(
					$elm$core$Dict$foldl,
					fold,
					_Utils_Tuple2($elm$core$Dict$empty, acc1),
					a_attrs);
				var b_attrs = _v13.a;
				var acc2 = _v13.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$Record, b_pos, a_ext, b_attrs),
					acc2);
			case 'Call':
				var a_pos = expr.a;
				var a_ref = expr.b;
				var a_arg = expr.c;
				var _v15 = A2(
					f,
					expr,
					_Utils_Tuple2(a_pos, acc));
				var b_pos = _v15.a;
				var acc1 = _v15.b;
				var _v16 = A2(
					$author$project$Types$CanonicalAst$extensionFold_expression,
					fFold,
					_Utils_Tuple2(a_ref, acc1));
				var b_ref = _v16.a;
				var acc2 = _v16.b;
				var _v17 = A2(
					$author$project$Types$CanonicalAst$extensionFold_argument,
					fFold,
					_Utils_Tuple2(a_arg, acc2));
				var b_arg = _v17.a;
				var acc3 = _v17.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$Call, b_pos, b_ref, b_arg),
					acc3);
			case 'If':
				var a_pos = expr.a;
				var ar = expr.b;
				var _v18 = A2(
					f,
					expr,
					_Utils_Tuple2(a_pos, acc));
				var b_pos = _v18.a;
				var acc1 = _v18.b;
				var _v19 = A2(
					$author$project$Types$CanonicalAst$extensionFold_block,
					fFold,
					_Utils_Tuple2(ar.condition, acc1));
				var b_cond = _v19.a;
				var acc2 = _v19.b;
				var _v20 = A2(
					$author$project$Types$CanonicalAst$extensionFold_block,
					fFold,
					_Utils_Tuple2(ar._true, acc2));
				var b_true = _v20.a;
				var acc3 = _v20.b;
				var _v21 = A2(
					$author$project$Types$CanonicalAst$extensionFold_block,
					fFold,
					_Utils_Tuple2(ar._false, acc3));
				var b_false = _v21.a;
				var acc4 = _v21.b;
				return _Utils_Tuple2(
					A2(
						$author$project$Types$CanonicalAst$If,
						b_pos,
						{condition: b_cond, _false: b_false, _true: b_true}),
					acc4);
			default:
				var a_pos = expr.a;
				var a_value = expr.b;
				var a_tries = expr.c;
				var fold = F2(
					function (_v27, _v28) {
						var a_pattern = _v27.a;
						var a_block = _v27.b;
						var pasAndBlocks = _v28.a;
						var accX0 = _v28.b;
						var _v25 = A2(
							$author$project$Types$CanonicalAst$extensionFold_block,
							fFold,
							_Utils_Tuple2(a_block, accX0));
						var b_block = _v25.a;
						var accX1 = _v25.b;
						var _v26 = A2(
							$author$project$Types$CanonicalAst$extensionFold_pattern,
							fFold,
							_Utils_Tuple2(a_pattern, accX1));
						var b_pattern = _v26.a;
						var accX2 = _v26.b;
						return _Utils_Tuple2(
							A2(
								$elm$core$List$cons,
								_Utils_Tuple2(b_pattern, b_block),
								pasAndBlocks),
							accX2);
					});
				var _v22 = A2(
					f,
					expr,
					_Utils_Tuple2(a_pos, acc));
				var b_pos = _v22.a;
				var acc1 = _v22.b;
				var _v23 = A2(
					$author$project$Types$CanonicalAst$extensionFold_expression,
					fFold,
					_Utils_Tuple2(a_value, acc1));
				var b_value = _v23.a;
				var acc2 = _v23.b;
				var _v24 = A3(
					$elm$core$List$foldr,
					fold,
					_Utils_Tuple2(_List_Nil, acc2),
					a_tries);
				var b_patterns = _v24.a;
				var acc3 = _v24.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$Try, b_pos, b_value, b_patterns),
					acc3);
		}
	});
var $author$project$Types$CanonicalAst$extensionFold_statement = F2(
	function (f, _v5) {
		var stat = _v5.a;
		var acc = _v5.b;
		if (stat.$ === 'Definition') {
			var ar = stat.a;
			return A2(
				$elm$core$Tuple$mapFirst,
				$author$project$Types$CanonicalAst$Definition,
				A2(
					$author$project$Types$CanonicalAst$extensionFold_valueDef,
					f,
					_Utils_Tuple2(ar, acc)));
		} else {
			var expr = stat.a;
			return A2(
				$elm$core$Tuple$mapFirst,
				$author$project$Types$CanonicalAst$Evaluation,
				A2(
					$author$project$Types$CanonicalAst$extensionFold_expression,
					f,
					_Utils_Tuple2(expr, acc)));
		}
	});
var $author$project$Types$CanonicalAst$extensionFold_valueDef = F2(
	function (f, _v0) {
		var def = _v0.a;
		var acc0 = _v0.b;
		var _v1 = A2(
			$author$project$Types$CanonicalAst$extensionFold_block,
			f,
			_Utils_Tuple2(def.body, acc0));
		var b_body = _v1.a;
		var acc1 = _v1.b;
		var _v2 = function () {
			var _v3 = def.maybeAnnotation;
			if (_v3.$ === 'Nothing') {
				return _Utils_Tuple2(def.maybeAnnotation, acc1);
			} else {
				var ty = _v3.a;
				return A2(
					$elm$core$Tuple$mapFirst,
					$elm$core$Maybe$Just,
					A2(
						$author$project$Types$CanonicalAst$extensionFold_type,
						f,
						_Utils_Tuple2(ty, acc1)));
			}
		}();
		var b_ann = _v2.a;
		var acc2 = _v2.b;
		var _v4 = A2(
			$author$project$Types$CanonicalAst$extensionFold_pattern,
			f,
			_Utils_Tuple2(def.pattern, acc2));
		var b_pattern = _v4.a;
		var acc3 = _v4.b;
		return _Utils_Tuple2(
			{body: b_body, maybeAnnotation: b_ann, mutable: def.mutable, pattern: b_pattern},
			acc3);
	});
var $author$project$Compiler$CanonicalToJs$getValueRefs = function (def) {
	var fn = F2(
		function (fold, _v2) {
			var ext = _v2.a;
			var set = _v2.b;
			if ((fold.$ === 'FoldExpr') && (fold.a.$ === 'Variable')) {
				var _v1 = fold.a;
				var args = _v1.b;
				return _Utils_Tuple2(
					ext,
					args.isRoot ? A2($elm$core$Set$insert, args.name, set) : set);
			} else {
				return _Utils_Tuple2(ext, set);
			}
		});
	return A2(
		$author$project$Types$CanonicalAst$extensionFold_valueDef,
		fn,
		_Utils_Tuple2(def, $elm$core$Set$empty)).b;
};
var $author$project$Types$CanonicalAst$ArgumentMutable = function (a) {
	return {$: 'ArgumentMutable', a: a};
};
var $author$project$Types$JavascriptAst$Define = F2(
	function (a, b) {
		return {$: 'Define', a: a, b: b};
	});
var $elm$core$Basics$composeL = F3(
	function (g, f, x) {
		return g(
			f(x));
	});
var $author$project$Types$CanonicalAst$posDummy = {c: '', e: -1, n: '', s: -1};
var $author$project$Types$JavascriptAst$Binop = F3(
	function (a, b, c) {
		return {$: 'Binop', a: a, b: b, c: c};
	});
var $author$project$Types$JavascriptAst$BlockLambda = F2(
	function (a, b) {
		return {$: 'BlockLambda', a: a, b: b};
	});
var $author$project$Types$JavascriptAst$Call = F2(
	function (a, b) {
		return {$: 'Call', a: a, b: b};
	});
var $author$project$Types$JavascriptAst$Conditional = F3(
	function (a, b, c) {
		return {$: 'Conditional', a: a, b: b, c: c};
	});
var $author$project$Types$JavascriptAst$Eval = function (a) {
	return {$: 'Eval', a: a};
};
var $author$project$Types$JavascriptAst$If = F2(
	function (a, b) {
		return {$: 'If', a: a, b: b};
	});
var $author$project$Types$JavascriptAst$Literal = function (a) {
	return {$: 'Literal', a: a};
};
var $author$project$Types$JavascriptAst$Mutop = F4(
	function (a, b, c, d) {
		return {$: 'Mutop', a: a, b: b, c: c, d: d};
	});
var $author$project$Types$JavascriptAst$Record = function (a) {
	return {$: 'Record', a: a};
};
var $author$project$Types$JavascriptAst$Return = function (a) {
	return {$: 'Return', a: a};
};
var $author$project$Types$JavascriptAst$SimpleLambda = F2(
	function (a, b) {
		return {$: 'SimpleLambda', a: a, b: b};
	});
var $author$project$Types$JavascriptAst$Var = function (a) {
	return {$: 'Var', a: a};
};
var $author$project$Types$JavascriptAst$AccessWithDot = F2(
	function (a, b) {
		return {$: 'AccessWithDot', a: a, b: b};
	});
var $author$project$Compiler$CanonicalToJs$accessAttrs = F2(
	function (attrPath, e) {
		return A3($elm$core$List$foldl, $author$project$Types$JavascriptAst$AccessWithDot, e, attrPath);
	});
var $author$project$Compiler$CanonicalToJs$accessAttrsButTheLast = F3(
	function (attrHead, attrTail, e) {
		var fold = F2(
			function (attr, _v0) {
				var expr = _v0.a;
				var last = _v0.b;
				return _Utils_Tuple2(
					A2($author$project$Types$JavascriptAst$AccessWithDot, last, expr),
					attr);
			});
		return A3(
			$elm$core$List$foldl,
			fold,
			_Utils_Tuple2(e, attrHead),
			attrTail);
	});
var $author$project$Compiler$CanonicalToJs$binopChain = F3(
	function (_default, op, es) {
		if (!es.b) {
			return _default;
		} else {
			var head = es.a;
			var tail = es.b;
			return A3(
				$elm$core$List$foldl,
				$author$project$Types$JavascriptAst$Binop(op),
				head,
				tail);
		}
	});
var $author$project$Compiler$CanonicalToJs$nativeBinops = A3(
	$elm$core$Dict$insert,
	'<',
	{fnName: 'lesserThan', jsSymb: '<', mutates: false},
	A3(
		$elm$core$Dict$insert,
		'>',
		{fnName: 'greaterThan', jsSymb: '>', mutates: false},
		A3(
			$elm$core$Dict$insert,
			'..',
			{fnName: 'strcon', jsSymb: '+', mutates: false},
			A3(
				$elm$core$Dict$insert,
				'+=',
				{fnName: 'mutadd', jsSymb: '+=', mutates: true},
				A3(
					$elm$core$Dict$insert,
					':=',
					{fnName: 'mutass', jsSymb: '=', mutates: true},
					A3(
						$elm$core$Dict$insert,
						'-',
						{fnName: 'sub', jsSymb: '-', mutates: false},
						A3(
							$elm$core$Dict$insert,
							'*',
							{fnName: 'mul', jsSymb: '*', mutates: false},
							A3(
								$elm$core$Dict$insert,
								'+',
								{fnName: 'add', jsSymb: '+', mutates: false},
								$elm$core$Dict$empty))))))));
var $elm$core$Basics$always = F2(
	function (a, _v0) {
		return a;
	});
var $author$project$Compiler$CanonicalToJs$nativeNonOps = A3(
	$elm$core$Dict$insert,
	'/',
	'sp_divide',
	A3(
		$elm$core$Dict$insert,
		'SPCore/Text.fromInt',
		'text_fromInt',
		A3(
			$elm$core$Dict$insert,
			'SPCore/Debug.todo',
			'sp_todo',
			A3(
				$elm$core$Dict$insert,
				'SPCore/Debug.log',
				'sp_log',
				A3(
					$elm$core$Dict$insert,
					$author$project$Compiler$CoreModule$noneValue,
					'null',
					A3(
						$elm$core$Dict$insert,
						$author$project$Compiler$CoreModule$falseValue,
						'false',
						A3(
							$elm$core$Dict$insert,
							$author$project$Compiler$CoreModule$trueValue,
							'true',
							A2(
								$elm$core$Dict$map,
								$elm$core$Basics$always(
									function ($) {
										return $.fnName;
									}),
								$author$project$Compiler$CanonicalToJs$nativeBinops))))))));
var $elm$core$String$replace = F3(
	function (before, after, string) {
		return A2(
			$elm$core$String$join,
			after,
			A2($elm$core$String$split, before, string));
	});
var $author$project$Compiler$CanonicalToJs$translatePath = function (s) {
	var _v0 = A2($elm$core$Dict$get, s, $author$project$Compiler$CanonicalToJs$nativeNonOps);
	if (_v0.$ === 'Just') {
		var nv = _v0.a;
		return nv;
	} else {
		return '$' + A3(
			$elm$core$String$replace,
			'/',
			'$',
			A3($elm$core$String$replace, '.', '$', s));
	}
};
var $author$project$Compiler$CanonicalToJs$none = $author$project$Compiler$CanonicalToJs$translatePath($author$project$Compiler$CoreModule$noneValue);
var $author$project$Types$JavascriptAst$AccessWithBrackets = F2(
	function (a, b) {
		return {$: 'AccessWithBrackets', a: a, b: b};
	});
var $author$project$Compiler$CanonicalToJs$accessWithBracketsInt = function (index) {
	return $author$project$Types$JavascriptAst$AccessWithBrackets(
		$author$project$Types$JavascriptAst$Var(
			$elm$core$String$fromInt(index)));
};
var $author$project$Compiler$CanonicalToJs$accessConstructorArg = $author$project$Compiler$CanonicalToJs$accessWithBracketsInt;
var $author$project$Compiler$CanonicalToJs$assignPattern = F3(
	function (pattern, exprAccum, accum) {
		switch (pattern.$) {
			case 'PatternDiscard':
				return accum;
			case 'PatternAny':
				var name = pattern.b;
				return (name === '_') ? accum : A2(
					$elm$core$List$cons,
					A2(
						$author$project$Types$JavascriptAst$Define,
						$author$project$Compiler$CanonicalToJs$translatePath(name),
						exprAccum),
					accum);
			case 'PatternLiteral':
				var literal = pattern.b;
				return accum;
			case 'PatternConstructor':
				var path = pattern.b;
				var pas = pattern.c;
				var foldEveryArgument = function (_v1) {
					var index = _v1.a;
					var pa = _v1.b;
					return A2(
						$author$project$Compiler$CanonicalToJs$assignPattern,
						pa,
						A2($author$project$Compiler$CanonicalToJs$accessConstructorArg, index + 1, exprAccum));
				};
				return A3(
					$elm$core$List$foldl,
					foldEveryArgument,
					accum,
					A2($elm$core$List$indexedMap, $elm$core$Tuple$pair, pas));
			default:
				var attrs = pattern.b;
				var foldEveryAttr = F2(
					function (name, pa) {
						return A2(
							$author$project$Compiler$CanonicalToJs$assignPattern,
							pa,
							A2($author$project$Types$JavascriptAst$AccessWithDot, name, exprAccum));
					});
				return A3($elm$core$Dict$foldl, foldEveryAttr, accum, attrs);
		}
	});
var $author$project$Compiler$CanonicalToJs$patternDefinitions = F2(
	function (mainName, pattern) {
		if (pattern.$ === 'PatternAny') {
			var pos = pattern.a;
			return _List_Nil;
		} else {
			return A3(
				$author$project$Compiler$CanonicalToJs$assignPattern,
				pattern,
				$author$project$Types$JavascriptAst$Var(mainName),
				_List_Nil);
		}
	});
var $author$project$Compiler$CanonicalToJs$pickMainName = function (pattern) {
	return A2(
		$elm$core$Maybe$map,
		A2(
			$elm$core$Basics$composeR,
			A2($elm$core$String$replace, '/', '$'),
			A2($elm$core$String$replace, '.', '$')),
		function () {
			if (pattern.$ === 'PatternAny') {
				var name = pattern.b;
				return $elm$core$Maybe$Just('$' + name);
			} else {
				return A2(
					$elm$core$Maybe$map,
					$elm$core$Basics$append('$$'),
					$elm$core$List$head(
						$elm$core$Set$toList(
							$author$project$Types$CanonicalAst$patternNames(pattern))));
			}
		}());
};
var $author$project$Compiler$CanonicalToJs$quoteAndEscape = function (s) {
	return '\"' + (s + '\"');
};
var $author$project$Compiler$CanonicalToJs$translateLiteral = function (value) {
	switch (value.$) {
		case 'Text':
			var t = value.a;
			return $author$project$Compiler$CanonicalToJs$quoteAndEscape(t);
		case 'Number':
			var n = value.a;
			return n;
		default:
			var c = value.a;
			return '\"' + ($elm$core$String$fromChar(c) + '\"');
	}
};
var $author$project$Compiler$CanonicalToJs$testPattern = F3(
	function (pattern, valueToTest, accum) {
		switch (pattern.$) {
			case 'PatternDiscard':
				return accum;
			case 'PatternAny':
				var name = pattern.b;
				return accum;
			case 'PatternLiteral':
				var lit = pattern.b;
				return A2(
					$elm$core$List$cons,
					A3(
						$author$project$Types$JavascriptAst$Binop,
						'===',
						$author$project$Types$JavascriptAst$Literal(
							$author$project$Compiler$CanonicalToJs$translateLiteral(lit)),
						valueToTest),
					accum);
			case 'PatternConstructor':
				var path = pattern.b;
				var pas = pattern.c;
				var head = A3(
					$author$project$Types$JavascriptAst$Binop,
					'===',
					$author$project$Types$JavascriptAst$Literal(
						$author$project$Compiler$CanonicalToJs$quoteAndEscape(path)),
					A2($author$project$Compiler$CanonicalToJs$accessWithBracketsInt, 0, valueToTest));
				var foldArg = F2(
					function (argPattern, _v1) {
						var index = _v1.a;
						var acc = _v1.b;
						return _Utils_Tuple2(
							index + 1,
							A3(
								$author$project$Compiler$CanonicalToJs$testPattern,
								argPattern,
								A2($author$project$Compiler$CanonicalToJs$accessWithBracketsInt, index, valueToTest),
								acc));
					});
				return A3(
					$elm$core$List$foldl,
					foldArg,
					_Utils_Tuple2(
						1,
						A2($elm$core$List$cons, head, accum)),
					pas).b;
			default:
				var attrs = pattern.b;
				var foldAttr = F2(
					function (name, pa) {
						return A2(
							$author$project$Compiler$CanonicalToJs$testPattern,
							pa,
							A2($author$project$Types$JavascriptAst$AccessWithDot, name, valueToTest));
					});
				return A3($elm$core$Dict$foldl, foldAttr, accum, attrs);
		}
	});
var $author$project$Compiler$CanonicalToJs$clone = function (expr) {
	return A2(
		$author$project$Types$JavascriptAst$Call,
		$author$project$Types$JavascriptAst$Var('sp_clone'),
		_List_fromArray(
			[expr]));
};
var $author$project$Compiler$CanonicalToJs$unwrapMutable = function (x) {
	var ja_x = $author$project$Types$JavascriptAst$Var(x);
	return A2(
		$author$project$Types$JavascriptAst$AccessWithBrackets,
		A2($author$project$Types$JavascriptAst$AccessWithDot, 'attr', ja_x),
		A2($author$project$Types$JavascriptAst$AccessWithDot, 'obj', ja_x));
};
var $author$project$Compiler$CanonicalToJs$translateVar = F2(
	function (env, _v0) {
		var name = _v0.name;
		var attrPath = _v0.attrPath;
		var jname = $author$project$Compiler$CanonicalToJs$translatePath(name);
		return A2($elm$core$Set$member, jname, env) ? $author$project$Compiler$CanonicalToJs$clone(
			A2(
				$author$project$Compiler$CanonicalToJs$accessAttrs,
				attrPath,
				$author$project$Compiler$CanonicalToJs$unwrapMutable(jname))) : A2(
			$author$project$Compiler$CanonicalToJs$accessAttrs,
			attrPath,
			$author$project$Types$JavascriptAst$Var(jname));
	});
var $author$project$Compiler$CanonicalToJs$tryName = '$$try';
var $author$project$Compiler$CanonicalToJs$wrapMutable = F2(
	function (mutable, expr) {
		return mutable ? $author$project$Types$JavascriptAst$Record(
			A3(
				$elm$core$Dict$insert,
				'obj',
				$author$project$Types$JavascriptAst$Record(
					A2($elm$core$Dict$singleton, '$', expr)),
				A3(
					$elm$core$Dict$insert,
					'attr',
					$author$project$Types$JavascriptAst$Literal(
						$author$project$Compiler$CanonicalToJs$quoteAndEscape('$')),
					$elm$core$Dict$empty))) : expr;
	});
var $author$project$Compiler$CanonicalToJs$maybeNativeBinop = F3(
	function (env, reference, argument) {
		if ((reference.$ === 'Call') && (reference.b.$ === 'Variable')) {
			var _v20 = reference.b;
			var name = _v20.b.name;
			var rightArg = reference.c;
			var _v21 = A2($elm$core$Dict$get, name, $author$project$Compiler$CanonicalToJs$nativeBinops);
			if (_v21.$ === 'Nothing') {
				return $elm$core$Maybe$Nothing;
			} else {
				var jsSymb = _v21.a.jsSymb;
				var mutates = _v21.a.mutates;
				var cons = mutates ? A2($author$project$Types$JavascriptAst$Mutop, jsSymb, $author$project$Compiler$CanonicalToJs$none) : $author$project$Types$JavascriptAst$Binop(jsSymb);
				return $elm$core$Maybe$Just(
					A2(
						cons,
						A3(
							$author$project$Compiler$CanonicalToJs$translateArg,
							{nativeBinop: true},
							env,
							argument),
						A3(
							$author$project$Compiler$CanonicalToJs$translateArg,
							{nativeBinop: true},
							env,
							rightArg)));
			}
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Compiler$CanonicalToJs$translateArg = F3(
	function (_v15, env, arg) {
		var nativeBinop = _v15.nativeBinop;
		if (arg.$ === 'ArgumentExpression') {
			var e = arg.a;
			return A2($author$project$Compiler$CanonicalToJs$translateExpr, env, e);
		} else {
			var name = arg.a.name;
			var attrPath = arg.a.attrPath;
			if (nativeBinop) {
				return A2(
					$author$project$Compiler$CanonicalToJs$accessAttrs,
					attrPath,
					$author$project$Compiler$CanonicalToJs$unwrapMutable(
						$author$project$Compiler$CanonicalToJs$translatePath(name)));
			} else {
				if (!attrPath.b) {
					return $author$project$Types$JavascriptAst$Var(
						$author$project$Compiler$CanonicalToJs$translatePath(name));
				} else {
					var head = attrPath.a;
					var tail = attrPath.b;
					return function (_v18) {
						var wrappedExpr = _v18.a;
						var lastAttrName = _v18.b;
						return $author$project$Types$JavascriptAst$Record(
							A3(
								$elm$core$Dict$insert,
								'attr',
								$author$project$Types$JavascriptAst$Literal(
									$author$project$Compiler$CanonicalToJs$quoteAndEscape(lastAttrName)),
								A3($elm$core$Dict$insert, 'obj', wrappedExpr, $elm$core$Dict$empty)));
					}(
						A3(
							$author$project$Compiler$CanonicalToJs$accessAttrsButTheLast,
							head,
							tail,
							$author$project$Compiler$CanonicalToJs$unwrapMutable(
								$author$project$Compiler$CanonicalToJs$translatePath(name))));
				}
			}
		}
	});
var $author$project$Compiler$CanonicalToJs$translateBodyToEither = F3(
	function (env, extra, caBody) {
		var fold = F2(
			function (caStat, _v14) {
				var faStats = _v14.a;
				var e = _v14.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					A2($elm$core$List$foldl, $elm$core$List$cons, faStats),
					A2($author$project$Compiler$CanonicalToJs$translateStatement, e, caStat));
			});
		var _v11 = A3(
			$elm$core$List$foldl,
			fold,
			_Utils_Tuple2(extra, env),
			caBody);
		var reversedStats = _v11.a;
		var env1 = _v11.b;
		if (!reversedStats.b) {
			return $author$project$Lib$Left(
				$author$project$Types$JavascriptAst$Var('null'));
		} else {
			if ((reversedStats.a.$ === 'Eval') && (!reversedStats.b.b)) {
				var single = reversedStats.a.a;
				return $author$project$Lib$Left(single);
			} else {
				var oldLast = reversedStats.a;
				var rest = reversedStats.b;
				return $author$project$Lib$Right(
					$elm$core$List$reverse(
						function () {
							if (oldLast.$ === 'Eval') {
								var expr = oldLast.a;
								return A2(
									$elm$core$List$cons,
									$author$project$Types$JavascriptAst$Return(expr),
									rest);
							} else {
								return A2(
									$elm$core$List$cons,
									$author$project$Types$JavascriptAst$Return(
										$author$project$Types$JavascriptAst$Var($author$project$Compiler$CanonicalToJs$none)),
									A2($elm$core$List$cons, oldLast, rest));
							}
						}()));
			}
		}
	});
var $author$project$Compiler$CanonicalToJs$translateBodyToExpr = F2(
	function (env, caBody) {
		var _v10 = A3($author$project$Compiler$CanonicalToJs$translateBodyToEither, env, _List_Nil, caBody);
		if (_v10.$ === 'Left') {
			var e = _v10.a;
			return e;
		} else {
			var block = _v10.a;
			return A2(
				$author$project$Types$JavascriptAst$Call,
				A2($author$project$Types$JavascriptAst$BlockLambda, _List_Nil, block),
				_List_Nil);
		}
	});
var $author$project$Compiler$CanonicalToJs$translateExpr = F2(
	function (env, expression) {
		switch (expression.$) {
			case 'Literal':
				var lit = expression.b;
				return $author$project$Types$JavascriptAst$Literal(
					$author$project$Compiler$CanonicalToJs$translateLiteral(lit));
			case 'Variable':
				var ar = expression.b;
				return A2($author$project$Compiler$CanonicalToJs$translateVar, env, ar);
			case 'Lambda':
				var parameter = expression.b;
				var body = expression.c;
				var _v3 = function () {
					var _v4 = $author$project$Compiler$CanonicalToJs$pickMainName(parameter);
					if (_v4.$ === 'Nothing') {
						return _Utils_Tuple2(_List_Nil, _List_Nil);
					} else {
						var mainName = _v4.a;
						return _Utils_Tuple2(
							_List_fromArray(
								[mainName]),
							A2($author$project$Compiler$CanonicalToJs$patternDefinitions, mainName, parameter));
					}
				}();
				var args = _v3.a;
				var extraJaStatements = _v3.b;
				var _v5 = A3($author$project$Compiler$CanonicalToJs$translateBodyToEither, env, extraJaStatements, body);
				if (_v5.$ === 'Left') {
					var expr = _v5.a;
					return A2($author$project$Types$JavascriptAst$SimpleLambda, args, expr);
				} else {
					var block = _v5.a;
					return A2($author$project$Types$JavascriptAst$BlockLambda, args, block);
				}
			case 'Record':
				var _extends = expression.b;
				var attrs = expression.c;
				var obj = $author$project$Types$JavascriptAst$Record(
					A2(
						$elm$core$Dict$map,
						function (k) {
							return $author$project$Compiler$CanonicalToJs$translateExpr(env);
						},
						attrs));
				if (_extends.$ === 'Nothing') {
					return obj;
				} else {
					var extend = _extends.a;
					return A2(
						$author$project$Types$JavascriptAst$Call,
						$author$project$Types$JavascriptAst$Var('Object.assign'),
						_List_fromArray(
							[
								$author$project$Types$JavascriptAst$Record($elm$core$Dict$empty),
								A2($author$project$Compiler$CanonicalToJs$translateVar, env, extend),
								obj
							]));
				}
			case 'Call':
				var ref = expression.b;
				var arg = expression.c;
				var _v7 = A3($author$project$Compiler$CanonicalToJs$maybeNativeBinop, env, ref, arg);
				if (_v7.$ === 'Just') {
					var jaExpr = _v7.a;
					return jaExpr;
				} else {
					return A2(
						$author$project$Types$JavascriptAst$Call,
						A2($author$project$Compiler$CanonicalToJs$translateExpr, env, ref),
						_List_fromArray(
							[
								A3(
								$author$project$Compiler$CanonicalToJs$translateArg,
								{nativeBinop: false},
								env,
								arg)
							]));
				}
			case 'If':
				var ar = expression.b;
				return A3(
					$author$project$Types$JavascriptAst$Conditional,
					A2($author$project$Compiler$CanonicalToJs$translateBodyToExpr, env, ar.condition),
					A2($author$project$Compiler$CanonicalToJs$translateBodyToExpr, env, ar._true),
					A2($author$project$Compiler$CanonicalToJs$translateBodyToExpr, env, ar._false));
			default:
				var pos = expression.a;
				var value = expression.b;
				var tries = expression.c;
				var init = $author$project$Types$JavascriptAst$Var($author$project$Compiler$CanonicalToJs$tryName);
				var testPa = function (_v9) {
					var pattern = _v9.a;
					var block = _v9.b;
					var extraStats = A2($author$project$Compiler$CanonicalToJs$patternDefinitions, $author$project$Compiler$CanonicalToJs$tryName, pattern);
					var whenConditionMatches = function () {
						var _v8 = A3($author$project$Compiler$CanonicalToJs$translateBodyToEither, env, extraStats, block);
						if (_v8.$ === 'Left') {
							var e = _v8.a;
							return _Utils_ap(
								extraStats,
								_List_fromArray(
									[
										$author$project$Types$JavascriptAst$Return(e)
									]));
						} else {
							var bl = _v8.a;
							return _Utils_ap(
								bl,
								_List_fromArray(
									[
										$author$project$Types$JavascriptAst$Return(
										$author$project$Types$JavascriptAst$Literal('null'))
									]));
						}
					}();
					var condition = A3(
						$author$project$Compiler$CanonicalToJs$binopChain,
						$author$project$Types$JavascriptAst$Literal('true'),
						'&&',
						A3($author$project$Compiler$CanonicalToJs$testPattern, pattern, init, _List_Nil));
					return A2($author$project$Types$JavascriptAst$If, condition, whenConditionMatches);
				};
				var head = A2(
					$author$project$Types$JavascriptAst$Define,
					$author$project$Compiler$CanonicalToJs$tryName,
					A2($author$project$Compiler$CanonicalToJs$translateExpr, env, value));
				var allStatements = A2(
					$elm$core$List$cons,
					head,
					A2($elm$core$List$map, testPa, tries));
				return A2(
					$author$project$Types$JavascriptAst$Call,
					A2($author$project$Types$JavascriptAst$BlockLambda, _List_Nil, allStatements),
					_List_Nil);
		}
	});
var $author$project$Compiler$CanonicalToJs$translateStatement = F2(
	function (env, s) {
		if (s.$ === 'Definition') {
			var def = s.a;
			return A2($author$project$Compiler$CanonicalToJs$translateValueDef, env, def);
		} else {
			var expr = s.a;
			return _Utils_Tuple2(
				_List_fromArray(
					[
						$author$project$Types$JavascriptAst$Eval(
						A2($author$project$Compiler$CanonicalToJs$translateExpr, env, expr))
					]),
				env);
		}
	});
var $author$project$Compiler$CanonicalToJs$translateValueDef = F2(
	function (env, caDef) {
		if (_Utils_eq(caDef.body, _List_Nil)) {
			return _Utils_Tuple2(_List_Nil, env);
		} else {
			var _v0 = $author$project$Compiler$CanonicalToJs$pickMainName(caDef.pattern);
			if (_v0.$ === 'Nothing') {
				return _Utils_Tuple2(
					_List_fromArray(
						[
							$author$project$Types$JavascriptAst$Eval(
							A2($author$project$Compiler$CanonicalToJs$translateBodyToExpr, env, caDef.body))
						]),
					env);
			} else {
				var mainName = _v0.a;
				return _Utils_Tuple2(
					A2(
						$elm$core$List$cons,
						A2(
							$author$project$Types$JavascriptAst$Define,
							mainName,
							A2(
								$author$project$Compiler$CanonicalToJs$wrapMutable,
								caDef.mutable,
								A2($author$project$Compiler$CanonicalToJs$translateBodyToExpr, env, caDef.body))),
						A2($author$project$Compiler$CanonicalToJs$patternDefinitions, mainName, caDef.pattern)),
					caDef.mutable ? A2($elm$core$Set$insert, mainName, env) : env);
			}
		}
	});
var $author$project$Compiler$CanonicalToJs$nativeBinopToFunction = F3(
	function (spName, _v0, acc) {
		var jsSymb = _v0.jsSymb;
		var mutates = _v0.mutates;
		var fnName = _v0.fnName;
		var d = $author$project$Types$CanonicalAst$posDummy;
		return A2(
			$elm$core$List$cons,
			A2(
				$author$project$Types$JavascriptAst$Define,
				fnName,
				A2(
					$author$project$Compiler$CanonicalToJs$translateBodyToExpr,
					$elm$core$Set$empty,
					_List_fromArray(
						[
							$author$project$Types$CanonicalAst$Evaluation(
							A3(
								$author$project$Types$CanonicalAst$Lambda,
								d,
								A2($author$project$Types$CanonicalAst$PatternAny, d, 'a'),
								_List_fromArray(
									[
										$author$project$Types$CanonicalAst$Evaluation(
										A3(
											$author$project$Types$CanonicalAst$Lambda,
											d,
											A2($author$project$Types$CanonicalAst$PatternAny, d, 'b'),
											_List_fromArray(
												[
													$author$project$Types$CanonicalAst$Evaluation(
													A3(
														$author$project$Types$CanonicalAst$Call,
														d,
														A3(
															$author$project$Types$CanonicalAst$Call,
															d,
															A2(
																$author$project$Types$CanonicalAst$Variable,
																d,
																{attrPath: _List_Nil, isRoot: true, name: spName}),
															$author$project$Types$CanonicalAst$ArgumentExpression(
																A2(
																	$author$project$Types$CanonicalAst$Variable,
																	d,
																	{attrPath: _List_Nil, isRoot: false, name: 'a'}))),
														(mutates ? $author$project$Types$CanonicalAst$ArgumentMutable : A2(
															$elm$core$Basics$composeL,
															$author$project$Types$CanonicalAst$ArgumentExpression,
															$author$project$Types$CanonicalAst$Variable(d)))(
															{attrPath: _List_Nil, isRoot: false, name: 'b'})))
												])))
									])))
						]))),
			acc);
	});
var $author$project$Compiler$CanonicalToJs$nativeBinopsAsFns = A3($elm$core$Dict$foldl, $author$project$Compiler$CanonicalToJs$nativeBinopToFunction, _List_Nil, $author$project$Compiler$CanonicalToJs$nativeBinops);
var $elm$core$List$partition = F2(
	function (pred, list) {
		var step = F2(
			function (x, _v0) {
				var trues = _v0.a;
				var falses = _v0.b;
				return pred(x) ? _Utils_Tuple2(
					A2($elm$core$List$cons, x, trues),
					falses) : _Utils_Tuple2(
					trues,
					A2($elm$core$List$cons, x, falses));
			});
		return A3(
			$elm$core$List$foldr,
			step,
			_Utils_Tuple2(_List_Nil, _List_Nil),
			list);
	});
var $elm$core$Basics$not = _Basics_not;
var $author$project$Types$JavascriptAst$Array = function (a) {
	return {$: 'Array', a: a};
};
var $author$project$Compiler$CanonicalToJs$constructorArgumentName = function (i) {
	return '$' + $elm$core$String$fromInt(i);
};
var $author$project$Compiler$CanonicalToJs$translateUnionConstructor = function (_v0) {
	var consName = _v0.a;
	var consArgs = _v0.b;
	var name = $author$project$Compiler$CanonicalToJs$quoteAndEscape(consName);
	var n = $elm$core$List$length(consArgs);
	var range = A2($elm$core$List$range, 1, n);
	var storedArgs = A2(
		$elm$core$List$map,
		A2($elm$core$Basics$composeR, $author$project$Compiler$CanonicalToJs$constructorArgumentName, $author$project$Types$JavascriptAst$Var),
		range);
	var expr = $author$project$Types$JavascriptAst$Array(
		A2(
			$elm$core$List$cons,
			$author$project$Types$JavascriptAst$Literal(name),
			storedArgs));
	var lambdas = A3(
		$elm$core$List$foldr,
		function (i) {
			return $author$project$Types$JavascriptAst$SimpleLambda(
				_List_fromArray(
					[
						$author$project$Compiler$CanonicalToJs$constructorArgumentName(i)
					]));
		},
		expr,
		range);
	return A2(
		$author$project$Types$JavascriptAst$Define,
		$author$project$Compiler$CanonicalToJs$translatePath(consName),
		lambdas);
};
var $author$project$Compiler$CanonicalToJs$translateUnion = function (def) {
	return A2(
		$elm$core$List$map,
		$author$project$Compiler$CanonicalToJs$translateUnionConstructor,
		A2(
			$elm$core$List$filter,
			function (_v0) {
				var name = _v0.a;
				var args = _v0.b;
				return !A2($elm$core$Dict$member, name, $author$project$Compiler$CanonicalToJs$nativeNonOps);
			},
			$elm$core$Dict$toList(def.constructors)));
};
var $author$project$Compiler$CanonicalToJs$translateAll = function (ca) {
	var isFunctionBlock = function (def) {
		var _v2 = def.body;
		if (((_v2.b && (_v2.a.$ === 'Evaluation')) && (_v2.a.a.$ === 'Lambda')) && (!_v2.b.b)) {
			var _v3 = _v2.a.a;
			return true;
		} else {
			return false;
		}
	};
	var _v0 = $author$project$Types$CanonicalAst$split(ca);
	var aliases = _v0.a;
	var unions = _v0.b;
	var values = _v0.c;
	var cons = A2(
		$elm$core$List$concatMap,
		$author$project$Compiler$CanonicalToJs$translateUnion,
		A2(
			$elm$core$List$sortBy,
			function ($) {
				return $.name;
			},
			$elm$core$Dict$values(unions)));
	var _v1 = A2(
		$elm$core$List$partition,
		isFunctionBlock,
		$elm$core$Dict$values(values));
	var fns = _v1.a;
	var nonFns = _v1.b;
	var reorderedNonFuns = A3($author$project$RefHierarchy$reorder, $author$project$Compiler$CanonicalToJs$getValueDefName, $author$project$Compiler$CanonicalToJs$getValueRefs, nonFns);
	var vals = A2(
		$elm$core$List$concatMap,
		A2(
			$elm$core$Basics$composeR,
			$author$project$Compiler$CanonicalToJs$translateValueDef($elm$core$Set$empty),
			$elm$core$Tuple$first),
		_Utils_ap(fns, reorderedNonFuns));
	return _Utils_ap(
		$author$project$Compiler$CanonicalToJs$nativeBinopsAsFns,
		_Utils_ap(cons, vals));
};
var $author$project$Compiler$JsToString_Test$runProgram = F2(
	function (variable, mod) {
		var evalToResult = F2(
			function (stats, s) {
				return A2($elm$core$String$startsWith, 'eval()', s) ? $elm$core$Result$Err(
					A2(
						$elm$core$String$join,
						'\n\n',
						A2(
							$elm$core$List$cons,
							s,
							A2($elm$core$List$cons, '', stats)))) : $elm$core$Result$Ok(s);
			});
		var endStatements = _List_fromArray(
			[
				$author$project$Compiler$CanonicalToJs$translatePath(variable) + ';'
			]);
		return function (stats) {
			return A2(
				evalToResult,
				stats,
				$elm_explorations$markdown$Markdown$eval(
					A2(
						$elm$core$String$join,
						'\n\n',
						A2(
							$elm$core$List$cons,
							$author$project$Compiler$CanonicalToJs$nativeDefinitions,
							_Utils_ap(stats, endStatements)))));
		}(
			A2(
				$elm$core$List$map,
				$author$project$Compiler$JsToString$emitStatement(0),
				$author$project$Compiler$CanonicalToJs$translateAll(mod)));
	});
var $author$project$Types$Token$BlockStart = {$: 'BlockStart'};
var $author$project$Types$Token$NewSiblingLine = {$: 'NewSiblingLine'};
var $author$project$Parser$Failure = function (a) {
	return {$: 'Failure', a: a};
};
var $author$project$Parser$Success = F2(
	function (a, b) {
		return {$: 'Success', a: a, b: b};
	});
var $author$project$Parser$consumeOne = F3(
	function (getNext, path, readState) {
		var _v0 = getNext(readState);
		if (_v0.$ === 'Nothing') {
			return $author$project$Parser$Failure(readState);
		} else {
			var _v1 = _v0.a;
			var token = _v1.a;
			var nextState = _v1.b;
			return A2($author$project$Parser$Success, nextState, token);
		}
	});
var $author$project$Parser$Abort = F2(
	function (a, b) {
		return {$: 'Abort', a: a, b: b};
	});
var $author$project$Parser$doWithDefault = F3(
	function (fallbackParser, firstParser, chainedParser) {
		return F3(
			function (getNext, path, readState) {
				var _v0 = A3(firstParser, getNext, path, readState);
				switch (_v0.$) {
					case 'Abort':
						var rs = _v0.a;
						var reason = _v0.b;
						return A2($author$project$Parser$Abort, rs, reason);
					case 'Failure':
						return A3(fallbackParser, getNext, path, readState);
					default:
						var nextReadState = _v0.a;
						var a = _v0.b;
						return A4(chainedParser, a, getNext, path, nextReadState);
				}
			});
	});
var $author$project$Parser$fail = F3(
	function (getNext, path, readState) {
		return $author$project$Parser$Failure(readState);
	});
var $author$project$Parser$succeed = function (a) {
	return F3(
		function (getNext, path, readState) {
			return A2($author$project$Parser$Success, readState, a);
		});
};
var $author$project$Parser$without = function (p) {
	return A3(
		$author$project$Parser$doWithDefault,
		$author$project$Parser$succeed(_Utils_Tuple0),
		p,
		function (_v0) {
			return $author$project$Parser$fail;
		});
};
var $author$project$Parser$end = $author$project$Parser$without($author$project$Parser$consumeOne);
var $author$project$Parser$do = $author$project$Parser$doWithDefault($author$project$Parser$fail);
var $author$project$Compiler$TokensToFormattableAst$oneToken = $author$project$Parser$consumeOne;
var $author$project$Compiler$TokensToFormattableAst$kind = function (targetKind) {
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$oneToken,
		function (token) {
			return _Utils_eq(targetKind, token.kind) ? $author$project$Parser$succeed(token) : $author$project$Parser$fail;
		});
};
var $author$project$Parser$oneOf = function (ps) {
	if (!ps.b) {
		return $author$project$Parser$fail;
	} else {
		var p = ps.a;
		var p_tail = ps.b;
		return A3(
			$author$project$Parser$doWithDefault,
			$author$project$Parser$oneOf(p_tail),
			p,
			$author$project$Parser$succeed);
	}
};
var $author$project$Compiler$TokensToFormattableAst$discardFirst = F2(
	function (a, b) {
		return A2(
			$author$project$Parser$do,
			a,
			function (_v0) {
				return b;
			});
	});
var $author$project$Parser$tuple2 = F2(
	function (pa, pb) {
		return A2(
			$author$project$Parser$do,
			pa,
			function (a) {
				return A2(
					$author$project$Parser$do,
					pb,
					function (b) {
						return $author$project$Parser$succeed(
							_Utils_Tuple2(a, b));
					});
			});
	});
var $author$project$Parser$zeroOrMore = function (p) {
	return A3(
		$author$project$Parser$doWithDefault,
		$author$project$Parser$succeed(_List_Nil),
		p,
		function (head) {
			return A2(
				$author$project$Parser$do,
				$author$project$Parser$zeroOrMore(p),
				function (tail) {
					return $author$project$Parser$succeed(
						A2($elm$core$List$cons, head, tail));
				});
		});
};
var $author$project$Compiler$TokensToFormattableAst$oomSeparatedBy = F2(
	function (sep, pa) {
		return A2(
			$author$project$Parser$tuple2,
			pa,
			$author$project$Parser$zeroOrMore(
				A2($author$project$Compiler$TokensToFormattableAst$discardFirst, sep, pa)));
	});
var $author$project$Types$Token$Addittive = {$: 'Addittive'};
var $author$project$Types$Token$As = {$: 'As'};
var $author$project$Types$Token$BlockEnd = {$: 'BlockEnd'};
var $author$project$Types$Token$Comparison = {$: 'Comparison'};
var $author$project$Types$FormattableAst$Definition = function (a) {
	return {$: 'Definition', a: a};
};
var $author$project$Types$Token$Defop = function (a) {
	return {$: 'Defop', a: a};
};
var $author$project$Types$Token$Else = {$: 'Else'};
var $author$project$Types$FormattableAst$Evaluation = function (a) {
	return {$: 'Evaluation', a: a};
};
var $author$project$Types$Token$Exponential = {$: 'Exponential'};
var $author$project$Types$Token$Fn = {$: 'Fn'};
var $author$project$Types$FormattableAst$If = F2(
	function (a, b) {
		return {$: 'If', a: a, b: b};
	});
var $author$project$Types$Token$If = {$: 'If'};
var $author$project$Types$FormattableAst$Lambda = F3(
	function (a, b, c) {
		return {$: 'Lambda', a: a, b: b, c: c};
	});
var $author$project$Types$FormattableAst$List = F2(
	function (a, b) {
		return {$: 'List', a: a, b: b};
	});
var $author$project$Types$Token$Multiplicative = {$: 'Multiplicative'};
var $author$project$Types$Token$Mutop = {$: 'Mutop'};
var $author$project$Types$Token$Pipe = {$: 'Pipe'};
var $author$project$Types$FormattableAst$Record = F2(
	function (a, b) {
		return {$: 'Record', a: a, b: b};
	});
var $author$project$Types$Token$Then = {$: 'Then'};
var $author$project$Types$FormattableAst$Try = F2(
	function (a, b) {
		return {$: 'Try', a: a, b: b};
	});
var $author$project$Types$Token$Try = {$: 'Try'};
var $author$project$Types$Token$Tuple = {$: 'Tuple'};
var $author$project$Parser$abort = function (error) {
	return F3(
		function (getNext, path, readState) {
			return A2($author$project$Parser$Abort, readState, error);
		});
};
var $author$project$Types$FormattableAst$Variable = F3(
	function (a, b, c) {
		return {$: 'Variable', a: a, b: b, c: c};
	});
var $author$project$Compiler$TokensToFormattableAst$binopInsideParens = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$oneToken,
	function (token) {
		var _v0 = token.kind;
		if (_v0.$ === 'Binop') {
			var g = _v0.a;
			var s = _v0.b;
			return $author$project$Parser$succeed(
				A3(
					$author$project$Types$FormattableAst$Variable,
					_Utils_Tuple2(token.start, token.end),
					{isBinop: true},
					s));
		} else {
			return $author$project$Parser$fail;
		}
	});
var $author$project$Types$FormattableAst$Binop = F3(
	function (a, b, c) {
		return {$: 'Binop', a: a, b: b, c: c};
	});
var $author$project$Compiler$TokensToFormattableAst$binaryOperators = function (group) {
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$oneToken,
		function (token) {
			var _v0 = token.kind;
			if (_v0.$ === 'Binop') {
				var g = _v0.a;
				var s = _v0.b;
				return _Utils_eq(g, group) ? $author$project$Parser$succeed(s) : $author$project$Parser$fail;
			} else {
				return $author$project$Parser$fail;
			}
		});
};
var $author$project$Parser$here = F3(
	function (getNext, path, readState) {
		return A2($author$project$Parser$Success, readState, readState);
	});
var $author$project$Compiler$TokensToFormattableAst$here = A2(
	$author$project$Parser$do,
	$author$project$Parser$here,
	function (tokens) {
		return $author$project$Parser$succeed(
			function () {
				if (tokens.b) {
					var next = tokens.a;
					var rest = tokens.b;
					return next.start;
				} else {
					return 0;
				}
			}());
	});
var $author$project$Parser$surroundWith = F3(
	function (left, right, parser) {
		return A2(
			$author$project$Parser$do,
			left,
			function (_v0) {
				return A2(
					$author$project$Parser$do,
					parser,
					function (p) {
						return A2(
							$author$project$Parser$do,
							right,
							function (_v1) {
								return $author$project$Parser$succeed(p);
							});
					});
			});
	});
var $author$project$Compiler$TokensToFormattableAst$surroundStrict = F2(
	function (left, right) {
		return A2(
			$author$project$Parser$surroundWith,
			$author$project$Compiler$TokensToFormattableAst$kind(left),
			$author$project$Compiler$TokensToFormattableAst$kind(right));
	});
var $author$project$Compiler$TokensToFormattableAst$block = A2($author$project$Compiler$TokensToFormattableAst$surroundStrict, $author$project$Types$Token$BlockStart, $author$project$Types$Token$BlockEnd);
var $author$project$Compiler$TokensToFormattableAst$sib = $author$project$Compiler$TokensToFormattableAst$discardFirst(
	$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine));
var $author$project$Compiler$TokensToFormattableAst$sepListAtItem = F2(
	function (sep, item) {
		return A2(
			$author$project$Parser$do,
			item,
			function (item0) {
				return A2(
					$author$project$Parser$do,
					$author$project$Parser$oneOf(
						_List_fromArray(
							[
								$author$project$Compiler$TokensToFormattableAst$block(
								A2($author$project$Compiler$TokensToFormattableAst$sepListAtSep, sep, item)),
								$author$project$Compiler$TokensToFormattableAst$sib(
								A2($author$project$Compiler$TokensToFormattableAst$sepListAtSep, sep, item)),
								A2($author$project$Compiler$TokensToFormattableAst$sepListAtSep, sep, item),
								$author$project$Parser$succeed(_List_Nil)
							])),
					function (sepsAndItems) {
						return $author$project$Parser$succeed(
							_Utils_Tuple2(item0, sepsAndItems));
					});
			});
	});
var $author$project$Compiler$TokensToFormattableAst$sepListAtSep = F2(
	function (sep, item) {
		return A2(
			$author$project$Parser$do,
			sep,
			function (sep0) {
				return A2(
					$author$project$Parser$do,
					$author$project$Parser$oneOf(
						_List_fromArray(
							[
								$author$project$Compiler$TokensToFormattableAst$block(
								A2($author$project$Compiler$TokensToFormattableAst$sepListAtItem, sep, item)),
								$author$project$Compiler$TokensToFormattableAst$sib(
								A2($author$project$Compiler$TokensToFormattableAst$sepListAtItem, sep, item)),
								A2($author$project$Compiler$TokensToFormattableAst$sepListAtItem, sep, item)
							])),
					function (_v0) {
						var item0 = _v0.a;
						var tail = _v0.b;
						return $author$project$Parser$succeed(
							A2(
								$elm$core$List$cons,
								_Utils_Tuple2(sep0, item0),
								tail));
					});
			});
	});
var $author$project$Compiler$TokensToFormattableAst$sepList = $author$project$Compiler$TokensToFormattableAst$sepListAtItem;
var $author$project$Compiler$TokensToFormattableAst$binopsOr = F2(
	function (group, higher) {
		return A2(
			$author$project$Parser$do,
			$author$project$Compiler$TokensToFormattableAst$here,
			function (start) {
				return A2(
					$author$project$Parser$do,
					A2(
						$author$project$Compiler$TokensToFormattableAst$sepList,
						$author$project$Compiler$TokensToFormattableAst$binaryOperators(group),
						higher),
					function (_v0) {
						var head = _v0.a;
						var sepTail = _v0.b;
						return A2(
							$author$project$Parser$do,
							$author$project$Compiler$TokensToFormattableAst$here,
							function (end) {
								return _Utils_eq(sepTail, _List_Nil) ? $author$project$Parser$succeed(head) : $author$project$Parser$succeed(
									A3(
										$author$project$Types$FormattableAst$Binop,
										_Utils_Tuple2(start, end),
										group,
										_Utils_Tuple2(head, sepTail)));
							});
					});
			});
	});
var $author$project$Parser$breakCircularDefinition = function (a) {
	return A2(
		$author$project$Parser$do,
		$author$project$Parser$succeed(_Utils_Tuple0),
		a);
};
var $author$project$Compiler$TokensToFormattableAst$defop = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$oneToken,
	function (token) {
		var _v0 = token.kind;
		if (_v0.$ === 'Defop') {
			var arg = _v0.a;
			return $author$project$Parser$succeed(arg);
		} else {
			return $author$project$Parser$fail;
		}
	});
var $author$project$Compiler$TokensToFormattableAst$errorCantUseMutableAssignmentHere = F3(
	function (moduleName, code, state) {
		return A2(
			$author$project$Types$Error$makeError,
			moduleName,
			_List_fromArray(
				[
					$author$project$Types$Error$text('errorCantUseMutableAssignmentHere')
				]));
	});
var $author$project$Parser$expression = F2(
	function (term, ops) {
		expression:
		while (true) {
			if (!ops.b) {
				return term;
			} else {
				var op = ops.a;
				var rest = ops.b;
				var $temp$term = op(term),
					$temp$ops = rest;
				term = $temp$term;
				ops = $temp$ops;
				continue expression;
			}
		}
	});
var $author$project$Types$FormattableAst$FunctionCall = F3(
	function (a, b, c) {
		return {$: 'FunctionCall', a: a, b: b, c: c};
	});
var $author$project$Compiler$TokensToFormattableAst$functionApplicationOr = function (higher) {
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$here,
		function (start) {
			return A2(
				$author$project$Parser$do,
				higher,
				function (e) {
					return A2(
						$author$project$Parser$do,
						$author$project$Parser$zeroOrMore(higher),
						function (args) {
							return A2(
								$author$project$Parser$do,
								$author$project$Compiler$TokensToFormattableAst$here,
								function (end) {
									return _Utils_eq(args, _List_Nil) ? $author$project$Parser$succeed(e) : $author$project$Parser$succeed(
										A3(
											$author$project$Types$FormattableAst$FunctionCall,
											_Utils_Tuple2(start, end),
											e,
											args));
								});
						});
				});
		});
};
var $author$project$Types$FormattableAst$PatternList = F2(
	function (a, b) {
		return {$: 'PatternList', a: a, b: b};
	});
var $author$project$Types$FormattableAst$PatternRecord = F2(
	function (a, b) {
		return {$: 'PatternRecord', a: a, b: b};
	});
var $author$project$Types$Token$Closed = {$: 'Closed'};
var $author$project$Types$Token$Open = {$: 'Open'};
var $author$project$Types$Token$SquareBracket = function (a) {
	return {$: 'SquareBracket', a: a};
};
var $author$project$Parser$maybe = function (p) {
	return A3(
		$author$project$Parser$doWithDefault,
		$author$project$Parser$succeed($elm$core$Maybe$Nothing),
		p,
		A2($elm$core$Basics$composeR, $elm$core$Maybe$Just, $author$project$Parser$succeed));
};
var $author$project$Types$Token$Comma = {$: 'Comma'};
var $author$project$Compiler$TokensToFormattableAst$rawList = function (item) {
	var sibsep = A2(
		$author$project$Parser$do,
		$author$project$Parser$maybe(
			$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine)),
		function (_v0) {
			return $author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$Comma);
		});
	return A2(
		$author$project$Compiler$TokensToFormattableAst$discardFirst,
		$author$project$Parser$maybe(sibsep),
		A2($author$project$Compiler$TokensToFormattableAst$oomSeparatedBy, sibsep, item));
};
var $author$project$Compiler$TokensToFormattableAst$discardSecond = F2(
	function (a, b) {
		return A2(
			$author$project$Parser$do,
			a,
			function (aa) {
				return A2(
					$author$project$Parser$do,
					b,
					function (_v0) {
						return $author$project$Parser$succeed(aa);
					});
			});
	});
var $author$project$Compiler$TokensToFormattableAst$inlineOrIndented = function (p) {
	return $author$project$Parser$oneOf(
		_List_fromArray(
			[
				A3($author$project$Compiler$TokensToFormattableAst$surroundStrict, $author$project$Types$Token$BlockStart, $author$project$Types$Token$BlockEnd, p),
				A2(
				$author$project$Compiler$TokensToFormattableAst$discardFirst,
				$author$project$Parser$maybe(
					$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine)),
				p)
			]));
};
var $author$project$Compiler$TokensToFormattableAst$surroundMultiline = F3(
	function (left, right, content) {
		return A2(
			$author$project$Compiler$TokensToFormattableAst$discardFirst,
			$author$project$Compiler$TokensToFormattableAst$kind(left),
			$author$project$Compiler$TokensToFormattableAst$inlineOrIndented(
				A2(
					$author$project$Compiler$TokensToFormattableAst$discardSecond,
					content,
					$author$project$Compiler$TokensToFormattableAst$inlineOrIndented(
						$author$project$Compiler$TokensToFormattableAst$kind(right)))));
	});
var $author$project$Compiler$TokensToFormattableAst$list = F2(
	function (constructor, main) {
		return A2(
			$author$project$Parser$do,
			$author$project$Compiler$TokensToFormattableAst$here,
			function (start) {
				return A2(
					$author$project$Parser$do,
					A3(
						$author$project$Compiler$TokensToFormattableAst$surroundMultiline,
						$author$project$Types$Token$SquareBracket($author$project$Types$Token$Open),
						$author$project$Types$Token$SquareBracket($author$project$Types$Token$Closed),
						$author$project$Parser$maybe(
							$author$project$Compiler$TokensToFormattableAst$rawList(main))),
					function (maybeLs) {
						return A2(
							$author$project$Parser$do,
							$author$project$Compiler$TokensToFormattableAst$here,
							function (end) {
								return $author$project$Parser$succeed(
									A2(
										constructor,
										_Utils_Tuple2(start, end),
										function () {
											if (maybeLs.$ === 'Just') {
												var _v1 = maybeLs.a;
												var h = _v1.a;
												var t = _v1.b;
												return A2($elm$core$List$cons, h, t);
											} else {
												return _List_Nil;
											}
										}()));
							});
					});
			});
	});
var $author$project$Types$Token$RoundParen = function (a) {
	return {$: 'RoundParen', a: a};
};
var $author$project$Compiler$TokensToFormattableAst$parens = function (main) {
	return A3(
		$author$project$Compiler$TokensToFormattableAst$surroundStrict,
		$author$project$Types$Token$RoundParen($author$project$Types$Token$Open),
		$author$project$Types$Token$RoundParen($author$project$Types$Token$Closed),
		main);
};
var $author$project$Types$Literal$Number = function (a) {
	return {$: 'Number', a: a};
};
var $author$project$Types$FormattableAst$PatternAny = F2(
	function (a, b) {
		return {$: 'PatternAny', a: a, b: b};
	});
var $author$project$Types$FormattableAst$PatternApplication = F3(
	function (a, b, c) {
		return {$: 'PatternApplication', a: a, b: b, c: c};
	});
var $author$project$Types$FormattableAst$PatternLiteral = F2(
	function (a, b) {
		return {$: 'PatternLiteral', a: a, b: b};
	});
var $author$project$Types$Literal$Text = function (a) {
	return {$: 'Text', a: a};
};
var $author$project$Compiler$TokensToFormattableAst$patternApplication = function (param) {
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$oneToken,
		function (token) {
			var _v0 = token.kind;
			switch (_v0.$) {
				case 'NumberLiteral':
					var s = _v0.a;
					return $author$project$Parser$succeed(
						A2(
							$author$project$Types$FormattableAst$PatternLiteral,
							_Utils_Tuple2(token.start, token.end),
							$author$project$Types$Literal$Number(s)));
				case 'TextLiteral':
					var s = _v0.a;
					return $author$project$Parser$succeed(
						A2(
							$author$project$Types$FormattableAst$PatternLiteral,
							_Utils_Tuple2(token.start, token.end),
							$author$project$Types$Literal$Text(s)));
				case 'Name':
					var mutable = _v0.a.mutable;
					var name = _v0.b;
					return mutable ? $author$project$Parser$fail : A2(
						$author$project$Parser$do,
						$author$project$Parser$zeroOrMore(param),
						function (params) {
							return A2(
								$author$project$Parser$do,
								$author$project$Compiler$TokensToFormattableAst$here,
								function (end) {
									return _Utils_eq(params, _List_Nil) ? $author$project$Parser$succeed(
										A2(
											$author$project$Types$FormattableAst$PatternAny,
											_Utils_Tuple2(token.start, token.end),
											name)) : $author$project$Parser$succeed(
										A3(
											$author$project$Types$FormattableAst$PatternApplication,
											_Utils_Tuple2(token.start, end),
											name,
											params));
								});
						});
				default:
					return $author$project$Parser$fail;
			}
		});
};
var $author$project$Types$Token$CurlyBrace = function (a) {
	return {$: 'CurlyBrace', a: a};
};
var $author$project$Types$Token$With = {$: 'With'};
var $author$project$Compiler$TokensToFormattableAst$nonMutName = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$oneToken,
	function (token) {
		var _v0 = token.kind;
		if (_v0.$ === 'Name') {
			var mutable = _v0.a.mutable;
			var s = _v0.b;
			return mutable ? $author$project$Parser$fail : $author$project$Parser$succeed(s);
		} else {
			return $author$project$Parser$fail;
		}
	});
var $author$project$OneOrMore$toList = function (_v0) {
	var h = _v0.a;
	var ts = _v0.b;
	return A2($elm$core$List$cons, h, ts);
};
var $author$project$Compiler$TokensToFormattableAst$record = F3(
	function (assign, constructor, main) {
		var updateTarget = A2(
			$author$project$Parser$do,
			main,
			function (h) {
				return A2(
					$author$project$Parser$do,
					$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$With),
					function (_v1) {
						return $author$project$Parser$succeed(h);
					});
			});
		var attrAssignment = A2(
			$author$project$Compiler$TokensToFormattableAst$discardFirst,
			$author$project$Compiler$TokensToFormattableAst$kind(
				assign(
					{mutable: false})),
			main);
		var attr = A2(
			$author$project$Parser$do,
			$author$project$Compiler$TokensToFormattableAst$nonMutName,
			function (name) {
				return A2(
					$author$project$Parser$do,
					$author$project$Parser$maybe(attrAssignment),
					function (maybeAssignment) {
						return $author$project$Parser$succeed(
							_Utils_Tuple2(name, maybeAssignment));
					});
			});
		var content = function (start) {
			return A2(
				$author$project$Parser$do,
				$author$project$Parser$maybe(updateTarget),
				function (maybeUpdateTarget) {
					return A2(
						$author$project$Parser$do,
						$author$project$Compiler$TokensToFormattableAst$rawList(attr),
						function (attrs) {
							return A2(
								$author$project$Parser$do,
								$author$project$Compiler$TokensToFormattableAst$here,
								function (end) {
									return $author$project$Parser$succeed(
										A2(
											constructor,
											_Utils_Tuple2(start, end),
											{
												attrs: $author$project$OneOrMore$toList(attrs),
												_extends: maybeUpdateTarget
											}));
								});
						});
				});
		};
		return A2(
			$author$project$Parser$do,
			$author$project$Compiler$TokensToFormattableAst$here,
			function (s) {
				return A2(
					$author$project$Parser$do,
					A3(
						$author$project$Compiler$TokensToFormattableAst$surroundMultiline,
						$author$project$Types$Token$CurlyBrace($author$project$Types$Token$Open),
						$author$project$Types$Token$CurlyBrace($author$project$Types$Token$Closed),
						$author$project$Parser$maybe(
							content(s))),
					function (maybeRecord) {
						return A2(
							$author$project$Parser$do,
							$author$project$Compiler$TokensToFormattableAst$here,
							function (e) {
								if (maybeRecord.$ === 'Just') {
									var re = maybeRecord.a;
									return $author$project$Parser$succeed(re);
								} else {
									return $author$project$Parser$succeed(
										A2(
											constructor,
											_Utils_Tuple2(s, e),
											{attrs: _List_Nil, _extends: $elm$core$Maybe$Nothing}));
								}
							});
					});
			});
	});
var $author$project$Compiler$TokensToFormattableAst$functionParameter = function (nest) {
	return $author$project$Parser$oneOf(
		_List_fromArray(
			[
				$author$project$Compiler$TokensToFormattableAst$patternApplication($author$project$Parser$fail),
				$author$project$Compiler$TokensToFormattableAst$parens(nest),
				A2($author$project$Compiler$TokensToFormattableAst$list, $author$project$Types$FormattableAst$PatternList, nest),
				A3($author$project$Compiler$TokensToFormattableAst$record, $author$project$Types$Token$Defop, $author$project$Types$FormattableAst$PatternRecord, nest)
			]));
};
var $author$project$Parser$higherOr = F2(
	function (parser, higher) {
		return $author$project$Parser$oneOf(
			_List_fromArray(
				[higher, parser]));
	});
var $author$project$Parser$oneOrMore = function (p) {
	return A2(
		$author$project$Parser$tuple2,
		p,
		$author$project$Parser$zeroOrMore(p));
};
function $author$project$Compiler$TokensToFormattableAst$cyclic$pattern() {
	var nest = $author$project$Parser$breakCircularDefinition(
		function (_v0) {
			return $author$project$Compiler$TokensToFormattableAst$cyclic$pattern();
		});
	return A2(
		$author$project$Parser$expression,
		$author$project$Compiler$TokensToFormattableAst$patternApplication(
			$author$project$Compiler$TokensToFormattableAst$functionParameter(nest)),
		_List_fromArray(
			[
				$author$project$Parser$higherOr(
				$author$project$Compiler$TokensToFormattableAst$parens(nest)),
				$author$project$Parser$higherOr(
				A2($author$project$Compiler$TokensToFormattableAst$list, $author$project$Types$FormattableAst$PatternList, nest)),
				$author$project$Parser$higherOr(
				A3($author$project$Compiler$TokensToFormattableAst$record, $author$project$Types$Token$Defop, $author$project$Types$FormattableAst$PatternRecord, nest))
			]));
}
try {
	var $author$project$Compiler$TokensToFormattableAst$pattern = $author$project$Compiler$TokensToFormattableAst$cyclic$pattern();
	$author$project$Compiler$TokensToFormattableAst$cyclic$pattern = function () {
		return $author$project$Compiler$TokensToFormattableAst$pattern;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.TokensToFormattableAst` are causing infinite recursion:\n\n  \n      pattern\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Types$FormattableAst$Literal = F2(
	function (a, b) {
		return {$: 'Literal', a: a, b: b};
	});
var $author$project$Types$FormattableAst$Mutable = F2(
	function (a, b) {
		return {$: 'Mutable', a: a, b: b};
	});
var $author$project$Compiler$TokensToFormattableAst$term = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$oneToken,
	function (token) {
		var _v0 = token.kind;
		switch (_v0.$) {
			case 'NumberLiteral':
				var s = _v0.a;
				return $author$project$Parser$succeed(
					A2(
						$author$project$Types$FormattableAst$Literal,
						_Utils_Tuple2(token.start, token.end),
						$author$project$Types$Literal$Number(s)));
			case 'TextLiteral':
				var s = _v0.a;
				return $author$project$Parser$succeed(
					A2(
						$author$project$Types$FormattableAst$Literal,
						_Utils_Tuple2(token.start, token.end),
						$author$project$Types$Literal$Text(s)));
			case 'Name':
				var mutable = _v0.a.mutable;
				var s = _v0.b;
				return $author$project$Parser$succeed(
					mutable ? A2(
						$author$project$Types$FormattableAst$Mutable,
						_Utils_Tuple2(token.start, token.end),
						s) : A3(
						$author$project$Types$FormattableAst$Variable,
						_Utils_Tuple2(token.start, token.end),
						{isBinop: false},
						s));
			default:
				return $author$project$Parser$fail;
		}
	});
var $author$project$Types$Token$Name = F2(
	function (a, b) {
		return {$: 'Name', a: a, b: b};
	});
var $author$project$Types$FormattableAst$TypeAlias = function (a) {
	return {$: 'TypeAlias', a: a};
};
var $author$project$Types$Token$HasType = function (a) {
	return {$: 'HasType', a: a};
};
var $author$project$Types$FormattableAst$TypeRecord = F2(
	function (a, b) {
		return {$: 'TypeRecord', a: a, b: b};
	});
var $author$project$Types$FormattableAst$TypePolymorphic = F3(
	function (a, b, c) {
		return {$: 'TypePolymorphic', a: a, b: b, c: c};
	});
var $author$project$Compiler$TokensToFormattableAst$typeApplicationOr = function (higher) {
	return A2(
		$author$project$Parser$do,
		higher,
		function (ty) {
			if (ty.$ === 'TypeName') {
				var _v1 = ty.a;
				var start = _v1.a;
				var end1 = _v1.b;
				var name = ty.b;
				return A2(
					$author$project$Parser$do,
					$author$project$Parser$zeroOrMore(higher),
					function (args) {
						return A2(
							$author$project$Parser$do,
							$author$project$Compiler$TokensToFormattableAst$here,
							function (end2) {
								return _Utils_eq(args, _List_Nil) ? $author$project$Parser$succeed(ty) : $author$project$Parser$succeed(
									A3(
										$author$project$Types$FormattableAst$TypePolymorphic,
										_Utils_Tuple2(start, end2),
										name,
										args));
							});
					});
			} else {
				return $author$project$Parser$succeed(ty);
			}
		});
};
var $author$project$Types$FormattableAst$TypeFunction = F4(
	function (a, b, c, d) {
		return {$: 'TypeFunction', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$TokensToFormattableAst$arrow = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$oneToken,
	function (token) {
		var _v0 = token.kind;
		if (_v0.$ === 'Arrow') {
			var arg = _v0.a;
			return $author$project$Parser$succeed(arg);
		} else {
			return $author$project$Parser$fail;
		}
	});
var $author$project$OneOrMore$reverseRec = F3(
	function (a, ls, accum) {
		reverseRec:
		while (true) {
			if (!ls.b) {
				return _Utils_Tuple2(a, accum);
			} else {
				var head = ls.a;
				var tail = ls.b;
				var $temp$a = head,
					$temp$ls = tail,
					$temp$accum = A2($elm$core$List$cons, a, accum);
				a = $temp$a;
				ls = $temp$ls;
				accum = $temp$accum;
				continue reverseRec;
			}
		}
	});
var $author$project$OneOrMore$reverse = function (_v0) {
	var a = _v0.a;
	var ls = _v0.b;
	return A3($author$project$OneOrMore$reverseRec, a, ls, _List_Nil);
};
var $author$project$Compiler$TokensToFormattableAst$typeFunctionOr = function (higher) {
	var fold = F2(
		function (_v2, _v3) {
			var nextIsMutable = _v2.a;
			var ty = _v2.b;
			var thisIsMutable = _v3.a;
			var accum = _v3.b;
			return _Utils_Tuple2(
				nextIsMutable,
				A4(
					$author$project$Types$FormattableAst$TypeFunction,
					_Utils_Tuple2(-1, -1),
					ty,
					thisIsMutable,
					accum));
		});
	var arrowAndHigher = A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$arrow,
		function (_v1) {
			var mutable = _v1.mutable;
			return A2(
				$author$project$Parser$do,
				higher,
				function (h) {
					return $author$project$Parser$succeed(
						_Utils_Tuple2(mutable, h));
				});
		});
	return A2(
		$author$project$Parser$do,
		higher,
		function (e) {
			return A2(
				$author$project$Parser$do,
				$author$project$Parser$zeroOrMore(arrowAndHigher),
				function (es) {
					var _v0 = $author$project$OneOrMore$reverse(
						_Utils_Tuple2(
							_Utils_Tuple2(false, e),
							es));
					var _return = _v0.a;
					var reversedArgs = _v0.b;
					return $author$project$Parser$succeed(
						A3($elm$core$List$foldl, fold, _return, reversedArgs).b);
				});
		});
};
var $author$project$Compiler$TokensToFormattableAst$typeList = function (main) {
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$here,
		function (start) {
			return A2(
				$author$project$Parser$do,
				A3(
					$author$project$Compiler$TokensToFormattableAst$surroundStrict,
					$author$project$Types$Token$SquareBracket($author$project$Types$Token$Open),
					$author$project$Types$Token$SquareBracket($author$project$Types$Token$Closed),
					main),
				function (t) {
					return A2(
						$author$project$Parser$do,
						$author$project$Compiler$TokensToFormattableAst$here,
						function (end) {
							return $author$project$Parser$succeed(
								A3(
									$author$project$Types$FormattableAst$TypePolymorphic,
									_Utils_Tuple2(start, end),
									'List',
									_List_fromArray(
										[t])));
						});
				});
		});
};
var $author$project$Compiler$TokensToFormattableAst$typeParens = function (main) {
	return A3(
		$author$project$Compiler$TokensToFormattableAst$surroundStrict,
		$author$project$Types$Token$RoundParen($author$project$Types$Token$Open),
		$author$project$Types$Token$RoundParen($author$project$Types$Token$Closed),
		main);
};
var $author$project$Types$FormattableAst$TypeName = F2(
	function (a, b) {
		return {$: 'TypeName', a: a, b: b};
	});
var $author$project$Compiler$TokensToFormattableAst$typeTerm = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$here,
	function (s) {
		return A2(
			$author$project$Parser$do,
			$author$project$Compiler$TokensToFormattableAst$nonMutName,
			function (n) {
				return A2(
					$author$project$Parser$do,
					$author$project$Compiler$TokensToFormattableAst$here,
					function (e) {
						return $author$project$Parser$succeed(
							A2(
								$author$project$Types$FormattableAst$TypeName,
								_Utils_Tuple2(s, e),
								n));
					});
			});
	});
var $author$project$Types$FormattableAst$TypeTuple = F2(
	function (a, b) {
		return {$: 'TypeTuple', a: a, b: b};
	});
var $author$project$Compiler$TokensToFormattableAst$typeTupleOr = function (higher) {
	var group = $author$project$Types$Token$Tuple;
	var binopAndPrev = A2(
		$author$project$Compiler$TokensToFormattableAst$discardFirst,
		$author$project$Compiler$TokensToFormattableAst$binaryOperators(group),
		higher);
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$here,
		function (start) {
			return A2(
				$author$project$Parser$do,
				higher,
				function (head) {
					return A2(
						$author$project$Parser$do,
						$author$project$Parser$zeroOrMore(binopAndPrev),
						function (tail) {
							return A2(
								$author$project$Parser$do,
								$author$project$Compiler$TokensToFormattableAst$here,
								function (end) {
									return _Utils_eq(tail, _List_Nil) ? $author$project$Parser$succeed(head) : $author$project$Parser$succeed(
										A2(
											$author$project$Types$FormattableAst$TypeTuple,
											_Utils_Tuple2(start, end),
											A2($elm$core$List$cons, head, tail)));
								});
						});
				});
		});
};
function $author$project$Compiler$TokensToFormattableAst$cyclic$typeExpr() {
	var nest = $author$project$Parser$breakCircularDefinition(
		function (_v0) {
			return $author$project$Compiler$TokensToFormattableAst$cyclic$typeExpr();
		});
	return A2(
		$author$project$Parser$expression,
		$author$project$Compiler$TokensToFormattableAst$typeTerm,
		_List_fromArray(
			[
				$author$project$Parser$higherOr(
				$author$project$Compiler$TokensToFormattableAst$typeParens(nest)),
				$author$project$Parser$higherOr(
				$author$project$Compiler$TokensToFormattableAst$typeList(nest)),
				$author$project$Parser$higherOr(
				A3($author$project$Compiler$TokensToFormattableAst$record, $author$project$Types$Token$HasType, $author$project$Types$FormattableAst$TypeRecord, nest)),
				$author$project$Compiler$TokensToFormattableAst$typeApplicationOr,
				$author$project$Compiler$TokensToFormattableAst$typeTupleOr,
				$author$project$Compiler$TokensToFormattableAst$typeFunctionOr
			]));
}
try {
	var $author$project$Compiler$TokensToFormattableAst$typeExpr = $author$project$Compiler$TokensToFormattableAst$cyclic$typeExpr();
	$author$project$Compiler$TokensToFormattableAst$cyclic$typeExpr = function () {
		return $author$project$Compiler$TokensToFormattableAst$typeExpr;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.TokensToFormattableAst` are causing infinite recursion:\n\n  \n      typeExpr\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$TokensToFormattableAst$typeAlias = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$kind(
		A2(
			$author$project$Types$Token$Name,
			{mutable: false},
			'alias')),
	function (_v0) {
		return A2(
			$author$project$Parser$do,
			$author$project$Parser$oneOrMore($author$project$Compiler$TokensToFormattableAst$nonMutName),
			function (_v1) {
				var name = _v1.a;
				var args = _v1.b;
				return A2(
					$author$project$Parser$do,
					$author$project$Compiler$TokensToFormattableAst$defop,
					function (_v2) {
						var mutable = _v2.mutable;
						return A2(
							$author$project$Parser$do,
							$author$project$Compiler$TokensToFormattableAst$inlineOrIndented($author$project$Compiler$TokensToFormattableAst$typeExpr),
							function (ty) {
								return mutable ? $author$project$Parser$abort($author$project$Compiler$TokensToFormattableAst$errorCantUseMutableAssignmentHere) : $author$project$Parser$succeed(
									$author$project$Types$FormattableAst$TypeAlias(
										{args: args, name: name, ty: ty}));
							});
					});
			});
	});
var $author$project$Compiler$TokensToFormattableAst$hasType = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$oneToken,
	function (token) {
		var _v0 = token.kind;
		if (_v0.$ === 'HasType') {
			var mutability = _v0.a;
			return $author$project$Parser$succeed(mutability);
		} else {
			return $author$project$Parser$fail;
		}
	});
var $author$project$Compiler$TokensToFormattableAst$typeAnnotation = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$nonMutName,
	function (name) {
		return A2(
			$author$project$Parser$do,
			$author$project$Compiler$TokensToFormattableAst$hasType,
			function (_v0) {
				var mutable = _v0.mutable;
				return A2(
					$author$project$Parser$do,
					$author$project$Compiler$TokensToFormattableAst$typeExpr,
					function (ty) {
						return A2(
							$author$project$Parser$do,
							$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine),
							function (_v1) {
								return $author$project$Parser$succeed(
									{mutable: mutable, name: name, ty: ty});
							});
					});
			});
	});
var $author$project$Types$FormattableAst$UnionDef = function (a) {
	return {$: 'UnionDef', a: a};
};
var $author$project$Compiler$TokensToFormattableAst$unionDef = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$kind(
		A2(
			$author$project$Types$Token$Name,
			{mutable: false},
			'union')),
	function (_v0) {
		return A2(
			$author$project$Parser$do,
			$author$project$Parser$oneOrMore($author$project$Compiler$TokensToFormattableAst$nonMutName),
			function (_v1) {
				var name = _v1.a;
				var args = _v1.b;
				return A2(
					$author$project$Parser$do,
					$author$project$Compiler$TokensToFormattableAst$defop,
					function (_v2) {
						var mutable = _v2.mutable;
						return A2(
							$author$project$Parser$do,
							$author$project$Compiler$TokensToFormattableAst$inlineOrIndented(
								$author$project$Compiler$TokensToFormattableAst$rawList($author$project$Compiler$TokensToFormattableAst$typeExpr)),
							function (cons) {
								return mutable ? $author$project$Parser$abort($author$project$Compiler$TokensToFormattableAst$errorCantUseMutableAssignmentHere) : $author$project$Parser$succeed(
									$author$project$Types$FormattableAst$UnionDef(
										{
											args: args,
											constructors: $author$project$OneOrMore$toList(cons),
											name: name
										}));
							});
					});
			});
	});
var $author$project$Types$FormattableAst$Unop = F3(
	function (a, b, c) {
		return {$: 'Unop', a: a, b: b, c: c};
	});
var $author$project$Compiler$TokensToFormattableAst$unaryOperator = A2(
	$author$project$Parser$do,
	$author$project$Compiler$TokensToFormattableAst$oneToken,
	function (token) {
		var _v0 = token.kind;
		if (_v0.$ === 'Unop') {
			var s = _v0.a;
			return $author$project$Parser$succeed(
				_Utils_Tuple2(s, token));
		} else {
			return $author$project$Parser$fail;
		}
	});
var $author$project$Compiler$TokensToFormattableAst$unopsOr = function (higher) {
	return A2(
		$author$project$Parser$do,
		$author$project$Parser$maybe($author$project$Compiler$TokensToFormattableAst$unaryOperator),
		function (maybeUnary) {
			return A2(
				$author$project$Parser$do,
				higher,
				function (right) {
					return A2(
						$author$project$Parser$do,
						$author$project$Compiler$TokensToFormattableAst$here,
						function (end) {
							if (maybeUnary.$ === 'Just') {
								var _v1 = maybeUnary.a;
								var op = _v1.a;
								var token = _v1.b;
								return $author$project$Parser$succeed(
									A3(
										$author$project$Types$FormattableAst$Unop,
										_Utils_Tuple2(token.start, end),
										op,
										right));
							} else {
								return $author$project$Parser$succeed(right);
							}
						});
				});
		});
};
function $author$project$Compiler$TokensToFormattableAst$cyclic$definition() {
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$here,
		function (start) {
			return A2(
				$author$project$Parser$do,
				$author$project$Parser$maybe($author$project$Compiler$TokensToFormattableAst$typeAnnotation),
				function (maybeAnnotation) {
					return A2(
						$author$project$Parser$do,
						$author$project$Compiler$TokensToFormattableAst$pattern,
						function (p) {
							return A2(
								$author$project$Parser$do,
								$author$project$Compiler$TokensToFormattableAst$defop,
								function (_v11) {
									var mutable = _v11.mutable;
									return A2(
										$author$project$Parser$do,
										$author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock(),
										function (sb) {
											return A2(
												$author$project$Parser$do,
												$author$project$Compiler$TokensToFormattableAst$here,
												function (end) {
													return $author$project$Parser$succeed(
														$author$project$Types$FormattableAst$Definition(
															{
																body: $author$project$OneOrMore$toList(sb),
																maybeAnnotation: maybeAnnotation,
																mutable: mutable,
																pattern: p,
																pos: _Utils_Tuple2(start, end)
															}));
												});
										});
								});
						});
				});
		});
}
function $author$project$Compiler$TokensToFormattableAst$cyclic$expr() {
	var nest = $author$project$Parser$breakCircularDefinition(
		function (_v10) {
			return $author$project$Compiler$TokensToFormattableAst$cyclic$expr();
		});
	return A2(
		$author$project$Parser$expression,
		$author$project$Compiler$TokensToFormattableAst$term,
		_List_fromArray(
			[
				$author$project$Parser$higherOr(
				$author$project$Compiler$TokensToFormattableAst$parens(
					$author$project$Parser$oneOf(
						_List_fromArray(
							[$author$project$Compiler$TokensToFormattableAst$binopInsideParens, nest])))),
				$author$project$Parser$higherOr(
				A2($author$project$Compiler$TokensToFormattableAst$list, $author$project$Types$FormattableAst$List, nest)),
				$author$project$Parser$higherOr(
				A3($author$project$Compiler$TokensToFormattableAst$record, $author$project$Types$Token$Defop, $author$project$Types$FormattableAst$Record, nest)),
				$author$project$Parser$higherOr(
				$author$project$Compiler$TokensToFormattableAst$cyclic$lambda()),
				$author$project$Compiler$TokensToFormattableAst$functionApplicationOr,
				$author$project$Compiler$TokensToFormattableAst$unopsOr,
				$author$project$Compiler$TokensToFormattableAst$binopsOr($author$project$Types$Token$Exponential),
				$author$project$Compiler$TokensToFormattableAst$binopsOr($author$project$Types$Token$Multiplicative),
				$author$project$Compiler$TokensToFormattableAst$binopsOr($author$project$Types$Token$Addittive),
				$author$project$Compiler$TokensToFormattableAst$binopsOr($author$project$Types$Token$Comparison),
				$author$project$Compiler$TokensToFormattableAst$binopsOr($author$project$Types$Token$Tuple),
				$author$project$Compiler$TokensToFormattableAst$binopsOr($author$project$Types$Token$Pipe),
				$author$project$Compiler$TokensToFormattableAst$binopsOr($author$project$Types$Token$Mutop),
				$author$project$Parser$higherOr(
				$author$project$Compiler$TokensToFormattableAst$cyclic$if_()),
				$author$project$Parser$higherOr(
				$author$project$Compiler$TokensToFormattableAst$cyclic$try())
			]));
}
function $author$project$Compiler$TokensToFormattableAst$cyclic$if_() {
	var maybeNewLine = function (k) {
		return A2(
			$author$project$Compiler$TokensToFormattableAst$discardFirst,
			$author$project$Parser$maybe(
				$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine)),
			$author$project$Compiler$TokensToFormattableAst$kind(k));
	};
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$If),
		function (ifToken) {
			return A2(
				$author$project$Parser$do,
				$author$project$Compiler$TokensToFormattableAst$cyclic$expr(),
				function (condition) {
					return A2(
						$author$project$Parser$do,
						maybeNewLine($author$project$Types$Token$Then),
						function (_v8) {
							return A2(
								$author$project$Parser$do,
								$author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock(),
								function (_true) {
									return A2(
										$author$project$Parser$do,
										maybeNewLine($author$project$Types$Token$Else),
										function (_v9) {
											return A2(
												$author$project$Parser$do,
												$author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock(),
												function (_false) {
													return A2(
														$author$project$Parser$do,
														$author$project$Compiler$TokensToFormattableAst$here,
														function (end) {
															return $author$project$Parser$succeed(
																A2(
																	$author$project$Types$FormattableAst$If,
																	_Utils_Tuple2(ifToken.start, end),
																	{
																		condition: condition,
																		_false: $author$project$OneOrMore$toList(_false),
																		isOneLine: false,
																		_true: $author$project$OneOrMore$toList(_true)
																	}));
														});
												});
										});
								});
						});
				});
		});
}
function $author$project$Compiler$TokensToFormattableAst$cyclic$lambda() {
	var def = A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$Fn),
		function (fn) {
			return A2(
				$author$project$Parser$do,
				$author$project$Parser$oneOrMore(
					$author$project$Compiler$TokensToFormattableAst$functionParameter($author$project$Compiler$TokensToFormattableAst$pattern)),
				function (params) {
					return A2(
						$author$project$Parser$do,
						$author$project$Compiler$TokensToFormattableAst$defop,
						function (_v7) {
							var mutable = _v7.mutable;
							return mutable ? $author$project$Parser$abort($author$project$Compiler$TokensToFormattableAst$errorCantUseMutableAssignmentHere) : $author$project$Parser$succeed(
								_Utils_Tuple2(fn, params));
						});
				});
		});
	var body = $author$project$Parser$oneOf(
		_List_fromArray(
			[
				$author$project$Parser$oneOrMore(
				A2(
					$author$project$Compiler$TokensToFormattableAst$discardFirst,
					$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine),
					$author$project$Compiler$TokensToFormattableAst$cyclic$statement())),
				$author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock()
			]));
	return A2(
		$author$project$Parser$do,
		def,
		function (_v6) {
			var fn = _v6.a;
			var params = _v6.b;
			return A2(
				$author$project$Parser$do,
				body,
				function (b) {
					return $author$project$Parser$succeed(
						A3(
							$author$project$Types$FormattableAst$Lambda,
							_Utils_Tuple2(fn.start, fn.end),
							$author$project$OneOrMore$toList(params),
							$author$project$OneOrMore$toList(b)));
				});
		});
}
function $author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock() {
	return $author$project$Parser$oneOf(
		_List_fromArray(
			[
				A2(
				$author$project$Parser$do,
				$author$project$Parser$breakCircularDefinition(
					function (_v5) {
						return $author$project$Compiler$TokensToFormattableAst$cyclic$expr();
					}),
				function (e) {
					return $author$project$Parser$succeed(
						_Utils_Tuple2(
							$author$project$Types$FormattableAst$Evaluation(e),
							_List_Nil));
				}),
				A3(
				$author$project$Parser$surroundWith,
				$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$BlockStart),
				$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$BlockEnd),
				A2(
					$author$project$Compiler$TokensToFormattableAst$oomSeparatedBy,
					$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine),
					$author$project$Compiler$TokensToFormattableAst$cyclic$statement()))
			]));
}
function $author$project$Compiler$TokensToFormattableAst$cyclic$statement() {
	return $author$project$Parser$breakCircularDefinition(
		function (_v4) {
			return $author$project$Parser$oneOf(
				_List_fromArray(
					[
						$author$project$Compiler$TokensToFormattableAst$typeAlias,
						$author$project$Compiler$TokensToFormattableAst$unionDef,
						$author$project$Compiler$TokensToFormattableAst$cyclic$definition(),
						A2(
						$author$project$Parser$do,
						$author$project$Compiler$TokensToFormattableAst$cyclic$expr(),
						A2($elm$core$Basics$composeR, $author$project$Types$FormattableAst$Evaluation, $author$project$Parser$succeed))
					]));
		});
}
function $author$project$Compiler$TokensToFormattableAst$cyclic$try() {
	var maybeNewLine = $author$project$Compiler$TokensToFormattableAst$discardFirst(
		$author$project$Parser$maybe(
			$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine)));
	var maybeNewLineKind = function (k) {
		return maybeNewLine(
			$author$project$Compiler$TokensToFormattableAst$kind(k));
	};
	var patternAndAccept = A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$pattern,
		function (p) {
			return A2(
				$author$project$Parser$do,
				maybeNewLineKind($author$project$Types$Token$Then),
				function (_v3) {
					return A2(
						$author$project$Parser$do,
						$author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock(),
						function (accept) {
							return $author$project$Parser$succeed(
								_Utils_Tuple2(
									p,
									$author$project$OneOrMore$toList(accept)));
						});
				});
		});
	var _default = A2(
		$author$project$Parser$do,
		maybeNewLineKind($author$project$Types$Token$Else),
		function (_v2) {
			return A2(
				$author$project$Parser$do,
				$author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock(),
				function (oom) {
					return $author$project$Parser$succeed(oom);
				});
		});
	var multi = A3(
		$author$project$Parser$surroundWith,
		$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$BlockStart),
		$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$BlockEnd),
		A2(
			$author$project$Parser$do,
			$author$project$Parser$zeroOrMore(
				maybeNewLine(patternAndAccept)),
			function (pnas) {
				return A2(
					$author$project$Parser$do,
					$author$project$Parser$maybe(_default),
					function (mdef) {
						return $author$project$Parser$succeed(
							_Utils_Tuple2(pnas, mdef));
					});
			}));
	var single = A2(
		$author$project$Parser$do,
		patternAndAccept,
		function (pna) {
			return A2(
				$author$project$Parser$do,
				_default,
				function (def) {
					return $author$project$Parser$succeed(
						_Utils_Tuple2(
							_List_fromArray(
								[pna]),
							$elm$core$Maybe$Just(def)));
				});
		});
	return A2(
		$author$project$Parser$do,
		$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$Try),
		function (tryToken) {
			return A2(
				$author$project$Parser$do,
				$author$project$Compiler$TokensToFormattableAst$cyclic$expr(),
				function (value) {
					return A2(
						$author$project$Parser$do,
						maybeNewLineKind($author$project$Types$Token$As),
						function (_v0) {
							return A2(
								$author$project$Parser$do,
								$author$project$Parser$oneOf(
									_List_fromArray(
										[single, multi])),
								function (_v1) {
									var patterns = _v1.a;
									var maybeElse = _v1.b;
									return A2(
										$author$project$Parser$do,
										$author$project$Compiler$TokensToFormattableAst$here,
										function (end) {
											return $author$project$Parser$succeed(
												A2(
													$author$project$Types$FormattableAst$Try,
													_Utils_Tuple2(tryToken.start, end),
													{
														isOneLine: false,
														maybeElse: A2($elm$core$Maybe$map, $author$project$OneOrMore$toList, maybeElse),
														patterns: patterns,
														value: value
													}));
										});
								});
						});
				});
		});
}
try {
	var $author$project$Compiler$TokensToFormattableAst$definition = $author$project$Compiler$TokensToFormattableAst$cyclic$definition();
	$author$project$Compiler$TokensToFormattableAst$cyclic$definition = function () {
		return $author$project$Compiler$TokensToFormattableAst$definition;
	};
	var $author$project$Compiler$TokensToFormattableAst$expr = $author$project$Compiler$TokensToFormattableAst$cyclic$expr();
	$author$project$Compiler$TokensToFormattableAst$cyclic$expr = function () {
		return $author$project$Compiler$TokensToFormattableAst$expr;
	};
	var $author$project$Compiler$TokensToFormattableAst$if_ = $author$project$Compiler$TokensToFormattableAst$cyclic$if_();
	$author$project$Compiler$TokensToFormattableAst$cyclic$if_ = function () {
		return $author$project$Compiler$TokensToFormattableAst$if_;
	};
	var $author$project$Compiler$TokensToFormattableAst$lambda = $author$project$Compiler$TokensToFormattableAst$cyclic$lambda();
	$author$project$Compiler$TokensToFormattableAst$cyclic$lambda = function () {
		return $author$project$Compiler$TokensToFormattableAst$lambda;
	};
	var $author$project$Compiler$TokensToFormattableAst$inlineStatementOrBlock = $author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock();
	$author$project$Compiler$TokensToFormattableAst$cyclic$inlineStatementOrBlock = function () {
		return $author$project$Compiler$TokensToFormattableAst$inlineStatementOrBlock;
	};
	var $author$project$Compiler$TokensToFormattableAst$statement = $author$project$Compiler$TokensToFormattableAst$cyclic$statement();
	$author$project$Compiler$TokensToFormattableAst$cyclic$statement = function () {
		return $author$project$Compiler$TokensToFormattableAst$statement;
	};
	var $author$project$Compiler$TokensToFormattableAst$try = $author$project$Compiler$TokensToFormattableAst$cyclic$try();
	$author$project$Compiler$TokensToFormattableAst$cyclic$try = function () {
		return $author$project$Compiler$TokensToFormattableAst$try;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.TokensToFormattableAst` are causing infinite recursion:\n\n  \n      definition\n       \n      expr\n       \n      if_\n       \n      lambda\n       \n      inlineStatementOrBlock\n       \n      statement\n       \n      try\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$TokensToFormattableAst$module_ = function () {
	var statements = A2(
		$author$project$Compiler$TokensToFormattableAst$oomSeparatedBy,
		$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine),
		$author$project$Compiler$TokensToFormattableAst$statement);
	var start = $author$project$Parser$oneOf(
		_List_fromArray(
			[
				$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$BlockStart),
				$author$project$Compiler$TokensToFormattableAst$kind($author$project$Types$Token$NewSiblingLine)
			]));
	var end = $author$project$Parser$end;
	return A3($author$project$Parser$surroundWith, start, end, statements);
}();
var $author$project$Compiler$TokensToFormattableAst$errorOptionsExhausted = F3(
	function (moduleName, code, nonConsumedTokens) {
		if (!nonConsumedTokens.b) {
			return A2(
				$author$project$Types$Error$makeError,
				moduleName,
				_List_fromArray(
					[
						$author$project$Types$Error$text('I got to the end of file and I can\'t make sense of it. =(')
					]));
		} else {
			var token = nonConsumedTokens.a;
			return A2(
				$author$project$Types$Error$makeError,
				moduleName,
				_List_fromArray(
					[
						$author$project$Types$Error$text('I got stuck parsing at this point:'),
						A3($author$project$Types$Error$showLines, code, 2, token.start)
					]));
		}
	});
var $author$project$Compiler$TokensToFormattableAst$outcomeToResult = F4(
	function (moduleName, code, tokens, outcome) {
		switch (outcome.$) {
			case 'Success':
				var readState = outcome.a;
				var output = outcome.b;
				return $elm$core$Result$Ok(output);
			case 'Abort':
				var readState = outcome.a;
				var makeError = outcome.b;
				return $elm$core$Result$Err(
					A3(makeError, moduleName, code, readState));
			default:
				var readState = outcome.a;
				return $elm$core$Result$Err(
					A3($author$project$Compiler$TokensToFormattableAst$errorOptionsExhausted, moduleName, code, readState));
		}
	});
var $author$project$Parser$parse = F3(
	function (parser, getNext, readState) {
		return A3(parser, getNext, _List_Nil, readState);
	});
var $author$project$Types$Token$Comment = {$: 'Comment'};
var $author$project$Compiler$TokensToFormattableAst$unconsIgnoreComments = function (ls) {
	unconsIgnoreComments:
	while (true) {
		if (ls.b) {
			var head = ls.a;
			var tail = ls.b;
			if (_Utils_eq(head.kind, $author$project$Types$Token$Comment)) {
				var $temp$ls = tail;
				ls = $temp$ls;
				continue unconsIgnoreComments;
			} else {
				return $elm$core$Maybe$Just(
					_Utils_Tuple2(head, tail));
			}
		} else {
			return $elm$core$Maybe$Nothing;
		}
	}
};
var $author$project$Compiler$TokensToFormattableAst$parse = F3(
	function (moduleName, code, tokens) {
		return A2(
			$elm$core$Result$map,
			$author$project$OneOrMore$toList,
			A4(
				$author$project$Compiler$TokensToFormattableAst$outcomeToResult,
				moduleName,
				code,
				tokens,
				A3($author$project$Parser$parse, $author$project$Compiler$TokensToFormattableAst$module_, $author$project$Compiler$TokensToFormattableAst$unconsIgnoreComments, tokens)));
	});
var $elm$core$String$fromList = _String_fromList;
var $author$project$Compiler$StringToTokens$errorBadIndent = F4(
	function (lastIndent, newIndent, endPos, state) {
		return A2(
			$author$project$Types$Error$makeRes,
			'TODO',
			_List_fromArray(
				[
					A3(
					$author$project$Types$Error$showLines,
					$elm$core$String$fromList(state.code),
					2,
					endPos),
					$author$project$Types$Error$text(
					'last indent was at row ' + $elm$core$String$fromInt(lastIndent)),
					$author$project$Types$Error$text(
					'but this new indent is at row ' + $elm$core$String$fromInt(newIndent))
				]));
	});
var $author$project$Compiler$StringToTokens$addIndentTokensRec = F5(
	function (endPos, newIndent, isFirstRecursion, state, stack) {
		addIndentTokensRec:
		while (true) {
			var makeToken = function (kind) {
				return {end: endPos, kind: kind, start: endPos - newIndent};
			};
			var _v0 = function () {
				if (!stack.b) {
					return _Utils_Tuple2(0, _List_Nil);
				} else {
					var head = stack.a;
					var tail = stack.b;
					return _Utils_Tuple2(head, tail);
				}
			}();
			var lastIndent = _v0.a;
			var poppedStack = _v0.b;
			if (_Utils_eq(newIndent, lastIndent)) {
				return $elm$core$Result$Ok(
					_Utils_update(
						state,
						{
							accum: A2(
								$elm$core$List$cons,
								makeToken($author$project$Types$Token$NewSiblingLine),
								state.accum),
							indentStack: stack
						}));
			} else {
				if (_Utils_cmp(newIndent, lastIndent) > 0) {
					return isFirstRecursion ? $elm$core$Result$Ok(
						_Utils_update(
							state,
							{
								accum: A2(
									$elm$core$List$cons,
									makeToken($author$project$Types$Token$BlockStart),
									state.accum),
								indentStack: A2($elm$core$List$cons, newIndent, state.indentStack)
							})) : A4($author$project$Compiler$StringToTokens$errorBadIndent, lastIndent, newIndent, endPos, state);
				} else {
					var $temp$endPos = endPos,
						$temp$newIndent = newIndent,
						$temp$isFirstRecursion = false,
						$temp$state = _Utils_update(
						state,
						{
							accum: A2(
								$elm$core$List$cons,
								makeToken($author$project$Types$Token$BlockEnd),
								state.accum)
						}),
						$temp$stack = poppedStack;
					endPos = $temp$endPos;
					newIndent = $temp$newIndent;
					isFirstRecursion = $temp$isFirstRecursion;
					state = $temp$state;
					stack = $temp$stack;
					continue addIndentTokensRec;
				}
			}
		}
	});
var $author$project$Compiler$StringToTokens$addIndentTokens = F2(
	function (endPos, state) {
		var _v0 = state.maybeIndentToAdd;
		if (_v0.$ === 'Nothing') {
			return $elm$core$Result$Ok(state);
		} else {
			var newIndent = _v0.a;
			return A5(
				$author$project$Compiler$StringToTokens$addIndentTokensRec,
				endPos,
				newIndent,
				true,
				_Utils_update(
					state,
					{maybeIndentToAdd: $elm$core$Maybe$Nothing}),
				state.indentStack);
		}
	});
var $author$project$Compiler$StringToTokens$chainIf = F3(
	function (predicate, fn, result) {
		return A2(
			$elm$core$Result$andThen,
			function (state) {
				return predicate ? fn(state) : $elm$core$Result$Ok(state);
			},
			result);
	});
var $author$project$Compiler$StringToTokens$errorInvalidToken = F3(
	function (start, codeBlock, state) {
		var token = A2(
			$elm$core$String$join,
			'',
			A2(
				$elm$core$List$take,
				1,
				A2($elm$core$String$split, ' ', codeBlock)));
		return A2(
			$author$project$Types$Error$makeError,
			'TODO',
			_List_fromArray(
				[
					$author$project$Types$Error$text('Not sure what `' + (token + '` means'))
				]));
	});
var $elm$regex$Regex$Match = F4(
	function (match, index, number, submatches) {
		return {index: index, match: match, number: number, submatches: submatches};
	});
var $elm$regex$Regex$find = _Regex_findAtMost(_Regex_infinity);
var $author$project$Compiler$StringToTokens$mapFind = F2(
	function (f, ls) {
		mapFind:
		while (true) {
			if (!ls.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var head = ls.a;
				var tail = ls.b;
				var _v1 = f(head);
				if (_v1.$ === 'Just') {
					var b = _v1.a;
					return $elm$core$Maybe$Just(b);
				} else {
					var $temp$f = f,
						$temp$ls = tail;
					f = $temp$f;
					ls = $temp$ls;
					continue mapFind;
				}
			}
		}
	});
var $author$project$Types$Token$Arrow = function (a) {
	return {$: 'Arrow', a: a};
};
var $author$project$Types$Token$Binop = F2(
	function (a, b) {
		return {$: 'Binop', a: a, b: b};
	});
var $author$project$Types$Token$Logical = {$: 'Logical'};
var $author$project$Types$Token$NumberLiteral = function (a) {
	return {$: 'NumberLiteral', a: a};
};
var $author$project$Types$Token$Unop = function (a) {
	return {$: 'Unop', a: a};
};
var $elm$core$String$dropRight = F2(
	function (n, string) {
		return (n < 1) ? string : A3($elm$core$String$slice, 0, -n, string);
	});
var $author$project$Compiler$StringToTokens$errorUnknownOperator = F2(
	function (pos, state) {
		return A2(
			$author$project$Types$Error$makeError,
			'TODO',
			_List_fromArray(
				[
					$author$project$Types$Error$text('Unknown operator')
				]));
	});
var $elm$regex$Regex$fromStringWith = _Regex_fromStringWith;
var $elm$regex$Regex$fromString = function (string) {
	return A2(
		$elm$regex$Regex$fromStringWith,
		{caseInsensitive: false, multiline: false},
		string);
};
var $elm$core$String$trimLeft = _String_trimLeft;
var $author$project$Compiler$StringToTokens$recognisedTokens = function () {
	var reOrDie = function (reString) {
		var _v4 = $elm$regex$Regex$fromString(reString);
		if (_v4.$ === 'Nothing') {
			return _Debug_todo(
				'Compiler.StringToTokens',
				{
					start: {line: 208, column: 21},
					end: {line: 208, column: 31}
				})('invalid regex!?');
		} else {
			var re = _v4.a;
			return re;
		}
	};
	var recordEntryToTuple = function (record) {
		return _Utils_Tuple2(
			reOrDie(record.regex),
			function (match) {
				return A2(
					$elm$core$Result$map,
					function (kind) {
						return _Utils_Tuple2(
							kind,
							record.consumed(match));
					},
					record.constructor(match));
			});
	};
	var parenRegex = F2(
		function (s, kind) {
			return {
				constructor: function (match) {
					return $elm$core$Result$Ok(kind);
				},
				consumed: $elm$core$String$length,
				regex: '^[ ]*\\' + s
			};
		});
	return A2(
		$elm$core$List$map,
		recordEntryToTuple,
		_List_fromArray(
			[
				{
				constructor: A2(
					$elm$core$Basics$composeR,
					$elm$core$String$trimLeft,
					A2($elm$core$Basics$composeR, $author$project$Types$Token$NumberLiteral, $elm$core$Result$Ok)),
				consumed: $elm$core$String$length,
				regex: '^[ ]*[0-9]+[.]?[0-9_]*'
			},
				{
				constructor: function (m) {
					var match = $elm$core$String$trimLeft(m);
					return $elm$core$Result$Ok(
						function () {
							switch (match) {
								case '..':
									return A2($author$project$Types$Token$Binop, $author$project$Types$Token$Addittive, match);
								case 'fn':
									return $author$project$Types$Token$Fn;
								case 'if':
									return $author$project$Types$Token$If;
								case 'try':
									return $author$project$Types$Token$Try;
								case 'as':
									return $author$project$Types$Token$As;
								case 'then':
									return $author$project$Types$Token$Then;
								case 'else':
									return $author$project$Types$Token$Else;
								case 'with':
									return $author$project$Types$Token$With;
								case 'and':
									return A2($author$project$Types$Token$Binop, $author$project$Types$Token$Logical, match);
								case 'or':
									return A2($author$project$Types$Token$Binop, $author$project$Types$Token$Logical, match);
								case 'not':
									return $author$project$Types$Token$Unop(match);
								default:
									var _v1 = $elm$core$String$uncons(match);
									if (_v1.$ === 'Nothing') {
										return _Debug_todo(
											'Compiler.StringToTokens',
											{
												start: {line: 280, column: 41},
												end: {line: 280, column: 51}
											})('not happening');
									} else {
										var _v2 = _v1.a;
										var head = _v2.a;
										var tail = _v2.b;
										return _Utils_eq(
											head,
											_Utils_chr('@')) ? A2(
											$author$project$Types$Token$Name,
											{mutable: true},
											tail) : A2(
											$author$project$Types$Token$Name,
											{mutable: false},
											match);
									}
							}
						}());
				},
				consumed: $elm$core$String$length,
				regex: '^[ ]*[@]?[a-zA-Z._][a-zA-Z./_0-9]*'
			},
				A2(
				parenRegex,
				'(',
				$author$project$Types$Token$RoundParen($author$project$Types$Token$Open)),
				A2(
				parenRegex,
				')',
				$author$project$Types$Token$RoundParen($author$project$Types$Token$Closed)),
				A2(
				parenRegex,
				'[',
				$author$project$Types$Token$SquareBracket($author$project$Types$Token$Open)),
				A2(
				parenRegex,
				']',
				$author$project$Types$Token$SquareBracket($author$project$Types$Token$Closed)),
				A2(
				parenRegex,
				'{',
				$author$project$Types$Token$CurlyBrace($author$project$Types$Token$Open)),
				A2(
				parenRegex,
				'}',
				$author$project$Types$Token$CurlyBrace($author$project$Types$Token$Closed)),
				A2(parenRegex, ',', $author$project$Types$Token$Comma),
				{
				constructor: A2(
					$elm$core$Basics$composeR,
					$elm$core$String$trimLeft,
					A2(
						$elm$core$Basics$composeR,
						$elm$core$String$dropRight(1),
						A2($elm$core$Basics$composeR, $author$project$Types$Token$Unop, $elm$core$Result$Ok))),
				consumed: function (match) {
					return $elm$core$String$length(match) - 1;
				},
				regex: '^[ ]+[+-][^ >=]'
			},
				{
				constructor: function (m) {
					var match = $elm$core$String$trimLeft(m);
					switch (match) {
						case '->':
							return $elm$core$Result$Ok(
								$author$project$Types$Token$Arrow(
									{mutable: false}));
						case '@>':
							return $elm$core$Result$Ok(
								$author$project$Types$Token$Arrow(
									{mutable: true}));
						case ':':
							return $elm$core$Result$Ok(
								$author$project$Types$Token$HasType(
									{mutable: false}));
						case '@:':
							return $elm$core$Result$Ok(
								$author$project$Types$Token$HasType(
									{mutable: true}));
						case '^':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Exponential, match));
						case '*':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Multiplicative, match));
						case '/':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Multiplicative, match));
						case '+':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Addittive, match));
						case '-':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Addittive, match));
						case '>':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Comparison, match));
						case '<':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Comparison, match));
						case '>=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Comparison, match));
						case '<=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Comparison, match));
						case '==':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Comparison, match));
						case '=/=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Comparison, match));
						case '&':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Tuple, match));
						case ':>':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Pipe, match));
						case '<:':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Pipe, match));
						case '>>':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Pipe, match));
						case '<<':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Pipe, match));
						case '=':
							return $elm$core$Result$Ok(
								$author$project$Types$Token$Defop(
									{mutable: false}));
						case '@=':
							return $elm$core$Result$Ok(
								$author$project$Types$Token$Defop(
									{mutable: true}));
						case ':=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Mutop, match));
						case '+=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Mutop, match));
						case '-=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Mutop, match));
						case '/=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Mutop, match));
						case '*=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Mutop, match));
						case '^=':
							return $elm$core$Result$Ok(
								A2($author$project$Types$Token$Binop, $author$project$Types$Token$Mutop, match));
						default:
							return $elm$core$Result$Err($author$project$Compiler$StringToTokens$errorUnknownOperator);
					}
				},
				consumed: $elm$core$String$length,
				regex: '^[ ]*[=+\\-*/:><!&^|@]+'
			}
			]));
}();
var $author$project$Compiler$StringToTokens$contentLineToTokensRec = F3(
	function (untrimmedBlock, untrimmedPos, tokenAccu) {
		contentLineToTokensRec:
		while (true) {
			var _v0 = $elm$core$String$trimLeft(untrimmedBlock);
			if (_v0 === '') {
				return $elm$core$Result$Ok(tokenAccu);
			} else {
				var codeBlock = _v0;
				var tryMatch = function (_v6) {
					var regex = _v6.a;
					var constructor = _v6.b;
					var _v5 = A2($elm$regex$Regex$find, regex, untrimmedBlock);
					if (_v5.b) {
						var match = _v5.a;
						var tail = _v5.b;
						return $elm$core$Maybe$Just(
							_Utils_Tuple2(match, constructor));
					} else {
						return $elm$core$Maybe$Nothing;
					}
				};
				var spaces = $elm$core$String$length(untrimmedBlock) - $elm$core$String$length(codeBlock);
				var start = untrimmedPos + spaces;
				var _v1 = A2($author$project$Compiler$StringToTokens$mapFind, tryMatch, $author$project$Compiler$StringToTokens$recognisedTokens);
				if (_v1.$ === 'Nothing') {
					return $elm$core$Result$Err(
						A2($author$project$Compiler$StringToTokens$errorInvalidToken, start, codeBlock));
				} else {
					var _v2 = _v1.a;
					var match = _v2.a;
					var constructor = _v2.b;
					var _v3 = constructor(match.match);
					if (_v3.$ === 'Err') {
						var stateToError = _v3.a;
						return $elm$core$Result$Err(
							stateToError(start));
					} else {
						var _v4 = _v3.a;
						var tokenKind = _v4.a;
						var charsConsumed = _v4.b;
						var tokenStart = start + match.index;
						var tokenEnd = (tokenStart + charsConsumed) - spaces;
						var token = {end: tokenEnd, kind: tokenKind, start: tokenStart};
						var newBlock = A2($elm$core$String$dropLeft, charsConsumed, untrimmedBlock);
						var accu = A2($elm$core$List$cons, token, tokenAccu);
						var $temp$untrimmedBlock = newBlock,
							$temp$untrimmedPos = tokenEnd,
							$temp$tokenAccu = accu;
						untrimmedBlock = $temp$untrimmedBlock;
						untrimmedPos = $temp$untrimmedPos;
						tokenAccu = $temp$tokenAccu;
						continue contentLineToTokensRec;
					}
				}
			}
		}
	});
var $author$project$Compiler$StringToTokens$contentLineToTokens = F2(
	function (startPos, state) {
		var contentLine = A3($elm$core$String$slice, startPos, state.pos, state.codeAsString);
		return A2(
			$elm$core$Result$map,
			function (tokens) {
				return _Utils_update(
					state,
					{accum: tokens});
			},
			A2(
				$elm$core$Result$mapError,
				function (stateToError) {
					return stateToError(state);
				},
				A3($author$project$Compiler$StringToTokens$contentLineToTokensRec, ' ' + contentLine, startPos - 1, state.accum)));
	});
var $author$project$Compiler$StringToTokens$errorTab = function (state) {
	return A2(
		$author$project$Types$Error$makeRes,
		'TODO',
		_List_fromArray(
			[
				A3(
				$author$project$Types$Error$showLines,
				$elm$core$String$fromList(state.code),
				2,
				state.pos),
				$author$project$Types$Error$text('Tab support is not yet implemented =*(')
			]));
};
var $author$project$Types$Token$TextLiteral = function (a) {
	return {$: 'TextLiteral', a: a};
};
var $author$project$Compiler$StringToTokens$errorUnterminatedTextLiteral = function (pos) {
	return A2(
		$author$project$Types$Error$makeRes,
		'TODO',
		_List_fromArray(
			[
				$author$project$Types$Error$text('unterminated text literal')
			]));
};
var $author$project$Compiler$StringToTokens$lexHardQuotedString = F2(
	function (startPos, state) {
		var rec = F4(
			function (pos, isEscape, doubleQuotes, code) {
				rec:
				while (true) {
					if (code.b) {
						switch (code.a.valueOf()) {
							case '\\':
								var rest = code.b;
								var $temp$pos = pos + 1,
									$temp$isEscape = !isEscape,
									$temp$doubleQuotes = 0,
									$temp$code = rest;
								pos = $temp$pos;
								isEscape = $temp$isEscape;
								doubleQuotes = $temp$doubleQuotes;
								code = $temp$code;
								continue rec;
							case '\"':
								var rest = code.b;
								var endPos = pos + 1;
								if (isEscape) {
									var $temp$pos = endPos,
										$temp$isEscape = false,
										$temp$doubleQuotes = 0,
										$temp$code = rest;
									pos = $temp$pos;
									isEscape = $temp$isEscape;
									doubleQuotes = $temp$doubleQuotes;
									code = $temp$code;
									continue rec;
								} else {
									if (doubleQuotes < 2) {
										var $temp$pos = endPos,
											$temp$isEscape = false,
											$temp$doubleQuotes = doubleQuotes + 1,
											$temp$code = rest;
										pos = $temp$pos;
										isEscape = $temp$isEscape;
										doubleQuotes = $temp$doubleQuotes;
										code = $temp$code;
										continue rec;
									} else {
										return $elm$core$Result$Ok(
											_Utils_update(
												state,
												{
													accum: A2(
														$elm$core$List$cons,
														{
															end: endPos,
															kind: $author$project$Types$Token$TextLiteral(
																A3($elm$core$String$slice, startPos + 3, endPos - 3, state.codeAsString)),
															start: startPos
														},
														state.accum),
													code: rest,
													pos: endPos
												}));
									}
								}
							default:
								var _char = code.a;
								var rest = code.b;
								var $temp$pos = pos + 1,
									$temp$isEscape = false,
									$temp$doubleQuotes = 0,
									$temp$code = rest;
								pos = $temp$pos;
								isEscape = $temp$isEscape;
								doubleQuotes = $temp$doubleQuotes;
								code = $temp$code;
								continue rec;
						}
					} else {
						return $author$project$Compiler$StringToTokens$errorUnterminatedTextLiteral(pos);
					}
				}
			});
		return A4(rec, state.pos, false, 0, state.code);
	});
var $author$project$Compiler$StringToTokens$readWhile = function (test) {
	var rec = F2(
		function (counter, list) {
			rec:
			while (true) {
				if (!list.b) {
					return _Utils_Tuple2(counter, list);
				} else {
					var head = list.a;
					var tail = list.b;
					if (test(head)) {
						var $temp$counter = counter + 1,
							$temp$list = tail;
						counter = $temp$counter;
						list = $temp$list;
						continue rec;
					} else {
						return _Utils_Tuple2(counter, list);
					}
				}
			}
		});
	return rec(0);
};
var $author$project$Compiler$StringToTokens$lexIndent = function (state) {
	var _v0 = A2(
		$author$project$Compiler$StringToTokens$readWhile,
		function (c) {
			return _Utils_eq(
				c,
				_Utils_chr(' '));
		},
		state.code);
	var newIndent = _v0.a;
	var newCode = _v0.b;
	return _Utils_update(
		state,
		{
			code: newCode,
			maybeIndentToAdd: $elm$core$Maybe$Just(newIndent),
			pos: newIndent + state.pos
		});
};
var $author$project$Compiler$StringToTokens$errorUnterminatedMultilineComment = function (pos) {
	return A2(
		$author$project$Types$Error$makeRes,
		'TODO',
		_List_fromArray(
			[
				$author$project$Types$Error$text('unterminated multiline comment')
			]));
};
var $author$project$Compiler$StringToTokens$lexMultiLineComment = F2(
	function (startPos, state) {
		var rec = F3(
			function (pos, depth, code) {
				rec:
				while (true) {
					_v0$2:
					while (true) {
						if (code.b) {
							if (code.b.b) {
								switch (code.a.valueOf()) {
									case '[':
										if ('#' === code.b.a.valueOf()) {
											var _v1 = code.b;
											var rest = _v1.b;
											var $temp$pos = pos + 1,
												$temp$depth = depth + 1,
												$temp$code = rest;
											pos = $temp$pos;
											depth = $temp$depth;
											code = $temp$code;
											continue rec;
										} else {
											break _v0$2;
										}
									case '#':
										if (']' === code.b.a.valueOf()) {
											var _v2 = code.b;
											var rest = _v2.b;
											var endPos = pos + 2;
											if (depth > 0) {
												var $temp$pos = endPos,
													$temp$depth = depth - 1,
													$temp$code = rest;
												pos = $temp$pos;
												depth = $temp$depth;
												code = $temp$code;
												continue rec;
											} else {
												return $elm$core$Result$Ok(
													_Utils_update(
														state,
														{
															accum: A2(
																$elm$core$List$cons,
																{end: endPos, kind: $author$project$Types$Token$Comment, start: startPos},
																state.accum),
															code: rest,
															pos: endPos
														}));
											}
										} else {
											break _v0$2;
										}
									default:
										break _v0$2;
								}
							} else {
								break _v0$2;
							}
						} else {
							return $author$project$Compiler$StringToTokens$errorUnterminatedMultilineComment(pos);
						}
					}
					var _char = code.a;
					var rest = code.b;
					var $temp$pos = pos + 1,
						$temp$depth = depth,
						$temp$code = rest;
					pos = $temp$pos;
					depth = $temp$depth;
					code = $temp$code;
					continue rec;
				}
			});
		return A3(rec, state.pos, 0, state.code);
	});
var $author$project$Compiler$StringToTokens$lexSingleLineComment = F2(
	function (startPos, state) {
		var _v0 = A2(
			$author$project$Compiler$StringToTokens$readWhile,
			function (c) {
				return !_Utils_eq(
					c,
					_Utils_chr('\n'));
			},
			state.code);
		var length = _v0.a;
		var rest = _v0.b;
		var endPos = state.pos + length;
		return $elm$core$Result$Ok(
			_Utils_update(
				state,
				{
					accum: A2(
						$elm$core$List$cons,
						{end: endPos, kind: $author$project$Types$Token$Comment, start: startPos},
						state.accum),
					code: rest,
					pos: endPos
				}));
	});
var $author$project$Compiler$StringToTokens$errorNewLineInsideSoftQuote = function (pos) {
	return A2(
		$author$project$Types$Error$makeRes,
		'TODO',
		_List_fromArray(
			[
				$author$project$Types$Error$text('single-quoted strings can\'t go on multiple lines, use \\n or a triple-quoted string instead')
			]));
};
var $author$project$Compiler$StringToTokens$lexSoftQuotedString = F2(
	function (startPos, state) {
		var rec = F3(
			function (pos, isEscape, code) {
				rec:
				while (true) {
					if (code.b) {
						switch (code.a.valueOf()) {
							case '\\':
								var rest = code.b;
								var $temp$pos = pos + 1,
									$temp$isEscape = !isEscape,
									$temp$code = rest;
								pos = $temp$pos;
								isEscape = $temp$isEscape;
								code = $temp$code;
								continue rec;
							case '\"':
								var rest = code.b;
								var endPos = pos + 1;
								if (isEscape) {
									var $temp$pos = endPos,
										$temp$isEscape = false,
										$temp$code = rest;
									pos = $temp$pos;
									isEscape = $temp$isEscape;
									code = $temp$code;
									continue rec;
								} else {
									return $elm$core$Result$Ok(
										_Utils_update(
											state,
											{
												accum: A2(
													$elm$core$List$cons,
													{
														end: endPos,
														kind: $author$project$Types$Token$TextLiteral(
															A3($elm$core$String$slice, startPos + 1, endPos - 1, state.codeAsString)),
														start: startPos
													},
													state.accum),
												code: rest,
												pos: endPos
											}));
								}
							case '\n':
								var rest = code.b;
								return $author$project$Compiler$StringToTokens$errorNewLineInsideSoftQuote(pos);
							default:
								var _char = code.a;
								var rest = code.b;
								var $temp$pos = pos + 1,
									$temp$isEscape = false,
									$temp$code = rest;
								pos = $temp$pos;
								isEscape = $temp$isEscape;
								code = $temp$code;
								continue rec;
						}
					} else {
						return $author$project$Compiler$StringToTokens$errorUnterminatedTextLiteral(pos);
					}
				}
			});
		return A3(rec, state.pos, false, state.code);
	});
var $author$project$Compiler$StringToTokens$lexContent = F2(
	function (startPos, state) {
		var runLexer = F4(
			function (contentAhead, lex, posOffset, rest) {
				return A2(
					$elm$core$Result$andThen,
					function (s) {
						return lex(
							_Utils_update(
								s,
								{code: rest, pos: s.pos + posOffset}));
					},
					A3(
						$author$project$Compiler$StringToTokens$chainIf,
						_Utils_cmp(state.pos, startPos) > 0,
						$author$project$Compiler$StringToTokens$contentLineToTokens(startPos),
						A3(
							$author$project$Compiler$StringToTokens$chainIf,
							contentAhead || (_Utils_cmp(state.pos, startPos) > 0),
							$author$project$Compiler$StringToTokens$addIndentTokens(startPos),
							$elm$core$Result$Ok(state))));
			});
		var _v0 = state.code;
		_v0$6:
		while (true) {
			if (_v0.b) {
				switch (_v0.a.valueOf()) {
					case '\"':
						if (((_v0.b.b && ('\"' === _v0.b.a.valueOf())) && _v0.b.b.b) && ('\"' === _v0.b.b.a.valueOf())) {
							var _v1 = _v0.b;
							var _v2 = _v1.b;
							var rest = _v2.b;
							return A4(
								runLexer,
								true,
								$author$project$Compiler$StringToTokens$lexHardQuotedString(state.pos),
								3,
								rest);
						} else {
							var rest = _v0.b;
							return A4(
								runLexer,
								true,
								$author$project$Compiler$StringToTokens$lexSoftQuotedString(state.pos),
								1,
								rest);
						}
					case '#':
						var rest = _v0.b;
						return A4(
							runLexer,
							false,
							$author$project$Compiler$StringToTokens$lexSingleLineComment(state.pos),
							1,
							rest);
					case '[':
						if (_v0.b.b && ('#' === _v0.b.a.valueOf())) {
							var _v3 = _v0.b;
							var rest = _v3.b;
							return A4(
								runLexer,
								false,
								$author$project$Compiler$StringToTokens$lexMultiLineComment(state.pos),
								2,
								rest);
						} else {
							break _v0$6;
						}
					case '\n':
						var rest = _v0.b;
						return A4(
							runLexer,
							false,
							A2($elm$core$Basics$composeR, $author$project$Compiler$StringToTokens$lexIndent, $elm$core$Result$Ok),
							1,
							rest);
					case '\t':
						var rest = _v0.b;
						return $author$project$Compiler$StringToTokens$errorTab(state);
					default:
						break _v0$6;
				}
			} else {
				return A4(runLexer, false, $elm$core$Result$Ok, 0, _List_Nil);
			}
		}
		var _char = _v0.a;
		var rest = _v0.b;
		return A2(
			$author$project$Compiler$StringToTokens$lexContent,
			startPos,
			_Utils_update(
				state,
				{code: rest, pos: 1 + state.pos}));
	});
var $author$project$Compiler$StringToTokens$stateToFinalTokens = function (state) {
	var blockEnd = {end: state.pos, kind: $author$project$Types$Token$BlockEnd, start: state.pos};
	return A3(
		$elm$core$List$foldl,
		F2(
			function (stack, accum) {
				return A2($elm$core$List$cons, blockEnd, accum);
			}),
		state.accum,
		state.indentStack);
};
var $author$project$Compiler$StringToTokens$lexerStep = function (prevState) {
	lexerStep:
	while (true) {
		var _v0 = A2($author$project$Compiler$StringToTokens$lexContent, prevState.pos, prevState);
		if (_v0.$ === 'Err') {
			var a = _v0.a;
			return $elm$core$Result$Err(a);
		} else {
			var nextState = _v0.a;
			if (!_Utils_eq(nextState.code, _List_Nil)) {
				var $temp$prevState = nextState;
				prevState = $temp$prevState;
				continue lexerStep;
			} else {
				return $elm$core$Result$Ok(
					$elm$core$List$reverse(
						$author$project$Compiler$StringToTokens$stateToFinalTokens(nextState)));
			}
		}
	}
};
var $elm$core$String$foldr = _String_foldr;
var $elm$core$String$toList = function (string) {
	return A3($elm$core$String$foldr, $elm$core$List$cons, _List_Nil, string);
};
var $author$project$Compiler$StringToTokens$lexer = function (codeAsString) {
	return $author$project$Compiler$StringToTokens$lexerStep(
		{
			accum: _List_Nil,
			code: A2(
				$elm$core$List$cons,
				_Utils_chr('\n'),
				$elm$core$String$toList(codeAsString)),
			codeAsString: codeAsString,
			indentStack: _List_Nil,
			maybeIndentToAdd: $elm$core$Maybe$Just(0),
			multiCommentDepth: 0,
			pos: -1
		});
};
var $author$project$Compiler$Pipeline$stringToTokens = F2(
	function (moduleName, code) {
		return $author$project$Compiler$StringToTokens$lexer(code);
	});
var $author$project$Compiler$Pipeline$stringToFormattableAst = F2(
	function (moduleName, code) {
		return A2(
			$elm$core$Result$andThen,
			A2($author$project$Compiler$TokensToFormattableAst$parse, moduleName, code),
			A2($author$project$Compiler$Pipeline$stringToTokens, moduleName, code));
	});
var $author$project$Compiler$FormattableToCanonicalAst$do = F2(
	function (a, b) {
		return A2($elm$core$Result$andThen, b, a);
	});
var $author$project$Compiler$FormattableToCanonicalAst$initEnv = function (ro) {
	return {maybeUpdateTarget: $elm$core$Maybe$Nothing, nonRootValues: $elm$core$Set$empty, ro: ro};
};
var $author$project$Compiler$FormattableToCanonicalAst$makeRootName = F2(
	function (modName, defName) {
		return modName + ('.' + defName);
	});
var $author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar = function (s) {
	var _v0 = $elm$core$String$uncons(s);
	if (_v0.$ === 'Nothing') {
		return false;
	} else {
		var _v1 = _v0.a;
		var head = _v1.a;
		var tail = _v1.b;
		return $elm$core$Char$isUpper(head);
	}
};
var $author$project$Compiler$FormattableToCanonicalAst$NotSpecified = {$: 'NotSpecified'};
var $author$project$Compiler$FormattableToCanonicalAst$AlreadyEmbedded = {$: 'AlreadyEmbedded'};
var $author$project$Compiler$FormattableToCanonicalAst$ResolvedTo = function (a) {
	return {$: 'ResolvedTo', a: a};
};
var $author$project$Compiler$FormattableToCanonicalAst$StructuredName_TypeOrCons = function (a) {
	return {$: 'StructuredName_TypeOrCons', a: a};
};
var $author$project$Compiler$FormattableToCanonicalAst$StructuredName_Value = function (a) {
	return {$: 'StructuredName_Value', a: a};
};
var $author$project$Types$Error$inlineCode = function (s) {
	return '`' + (s + '`');
};
var $author$project$Compiler$FormattableToCanonicalAst$errorRecordUpdateShorthandOutsideRecordUpdate = F3(
	function (_v0, rawString, env) {
		var start = _v0.a;
		var end = _v0.b;
		return A2(
			$author$project$Types$Error$makeRes,
			env.ro.currentModule,
			_List_fromArray(
				[
					A3($author$project$Types$Error$showLines, env.ro.code, 2, start),
					$author$project$Types$Error$text(
					$author$project$Types$Error$inlineCode(rawString) + ' looks like a record update shorthand, but we are not inside a record update!')
				]));
	});
var $author$project$Compiler$FormattableToCanonicalAst$stringToStructuredName = F3(
	function (env, pos, rawString) {
		var validateDefName = function (name) {
			return A2($elm$core$String$contains, '/', name) ? $author$project$Types$Error$errorTodo('value names can\'t contain `/`') : ((name === '') ? $author$project$Types$Error$errorTodo('weird double dots?') : $elm$core$Result$Ok(name));
		};
		var validateAttrPath = function (ap) {
			return A2($elm$core$List$any, $author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar, ap) ? $author$project$Types$Error$errorTodo('record attributes names must start with a lowercase letter') : (A2(
				$elm$core$List$any,
				$elm$core$String$contains('/'),
				ap) ? $author$project$Types$Error$errorTodo('`/` can\'t be used inside attribute names') : (A2(
				$elm$core$List$any,
				$elm$core$Basics$eq(''),
				ap) ? $author$project$Types$Error$errorTodo('Weird `..`?') : $elm$core$Result$Ok(ap)));
		};
		var translateModName = function (moduleName) {
			return $elm$core$Result$Ok(
				A2(
					$elm$core$Maybe$withDefault,
					moduleName,
					A2($elm$core$Dict$get, moduleName, env.ro.meta.bynames)));
		};
		var _v0 = A2($elm$core$String$split, '.', rawString);
		if (!_v0.b) {
			return $author$project$Types$Error$errorTodo('name is empty string !? should not happen');
		} else {
			if (_v0.a === '') {
				var tail = _v0.b;
				var _v1 = env.maybeUpdateTarget;
				if (_v1.$ === 'Nothing') {
					return A3($author$project$Compiler$FormattableToCanonicalAst$errorRecordUpdateShorthandOutsideRecordUpdate, pos, rawString, env);
				} else {
					var ref = _v1.a;
					return A2(
						$author$project$Compiler$FormattableToCanonicalAst$do,
						validateAttrPath(tail),
						function (tailPath) {
							return $elm$core$Result$Ok(
								$author$project$Compiler$FormattableToCanonicalAst$StructuredName_Value(
									{
										attrPath: _Utils_ap(ref.attrPath, tailPath),
										mod: $author$project$Compiler$FormattableToCanonicalAst$AlreadyEmbedded,
										name: ref.name
									}));
						});
				}
			} else {
				var first = _v0.a;
				var rest = _v0.b;
				if (!$author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar(first)) {
					return A2(
						$author$project$Compiler$FormattableToCanonicalAst$do,
						validateAttrPath(rest),
						function (attrPath) {
							return A2(
								$author$project$Compiler$FormattableToCanonicalAst$do,
								validateDefName(first),
								function (name) {
									return $elm$core$Result$Ok(
										$author$project$Compiler$FormattableToCanonicalAst$StructuredName_Value(
											{attrPath: attrPath, mod: $author$project$Compiler$FormattableToCanonicalAst$NotSpecified, name: name}));
								});
						});
				} else {
					if (!rest.b) {
						return A2(
							$author$project$Compiler$FormattableToCanonicalAst$do,
							validateDefName(first),
							function (name) {
								return $elm$core$Result$Ok(
									$author$project$Compiler$FormattableToCanonicalAst$StructuredName_TypeOrCons(
										{mod: $author$project$Compiler$FormattableToCanonicalAst$NotSpecified, name: name}));
							});
					} else {
						var second = rest.a;
						var tail = rest.b;
						return $author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar(second) ? ((!_Utils_eq(tail, _List_Nil)) ? $author$project$Types$Error$errorTodo('Type or Constructor can\'t have attributes!') : A2(
							$author$project$Compiler$FormattableToCanonicalAst$do,
							validateDefName(second),
							function (defName) {
								return A2(
									$author$project$Compiler$FormattableToCanonicalAst$do,
									translateModName(first),
									function (modName) {
										return $elm$core$Result$Ok(
											$author$project$Compiler$FormattableToCanonicalAst$StructuredName_TypeOrCons(
												{
													mod: $author$project$Compiler$FormattableToCanonicalAst$ResolvedTo(modName),
													name: defName
												}));
									});
							})) : A2(
							$author$project$Compiler$FormattableToCanonicalAst$do,
							validateDefName(second),
							function (defName) {
								return A2(
									$author$project$Compiler$FormattableToCanonicalAst$do,
									translateModName(first),
									function (modName) {
										return A2(
											$author$project$Compiler$FormattableToCanonicalAst$do,
											validateAttrPath(tail),
											function (attrPath) {
												return $elm$core$Result$Ok(
													$author$project$Compiler$FormattableToCanonicalAst$StructuredName_Value(
														{
															attrPath: attrPath,
															mod: $author$project$Compiler$FormattableToCanonicalAst$ResolvedTo(modName),
															name: defName
														}));
											});
									});
							});
					}
				}
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$errorExperimentingWithNoExtensibleTypes = F2(
	function (ro, _v0) {
		var start = _v0.a;
		var end = _v0.b;
		return A2(
			$author$project$Types$Error$makeRes,
			ro.currentModule,
			_List_fromArray(
				[
					A3($author$project$Types$Error$showLines, ro.code, 2, start),
					$author$project$Types$Error$text('For now extensible types are disabled, I want to see if it\'s good to do without them')
				]));
	});
var $author$project$Compiler$FormattableToCanonicalAst$resolveName = F5(
	function (getter, ro, declaredInsideFunction, mod, name) {
		switch (mod.$) {
			case 'ResolvedTo':
				var modName = mod.a;
				return A2($author$project$Compiler$FormattableToCanonicalAst$makeRootName, modName, name);
			case 'AlreadyEmbedded':
				return name;
			default:
				var _v1 = A2(
					$elm$core$Dict$get,
					name,
					getter(ro.meta));
				if (_v1.$ === 'Just') {
					var global = _v1.a;
					return global;
				} else {
					return declaredInsideFunction ? name : A2($author$project$Compiler$FormattableToCanonicalAst$makeRootName, ro.currentModule, name);
				}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$resolveTypeName = $author$project$Compiler$FormattableToCanonicalAst$resolveName(
	function ($) {
		return $.globalTypes;
	});
var $author$project$Compiler$FormattableToCanonicalAst$todoPos = {c: '', e: -1, n: 'TODO', s: -1};
var $author$project$Compiler$FormattableToCanonicalAst$tp = F2(
	function (ro, _v0) {
		var start = _v0.a;
		var end = _v0.b;
		return {c: ro.code, e: end, n: ro.currentModule, s: start};
	});
var $author$project$Compiler$FormattableToCanonicalAst$addAttributes = F3(
	function (ro, faAttrs, caAttrsAccum) {
		if (!faAttrs.b) {
			return $elm$core$Result$Ok(
				A3($author$project$Types$CanonicalAst$TypeRecord, $author$project$Compiler$FormattableToCanonicalAst$todoPos, $elm$core$Maybe$Nothing, caAttrsAccum));
		} else {
			var _v7 = faAttrs.a;
			var name = _v7.a;
			var maybeFaType = _v7.b;
			var faTail = faAttrs.b;
			var faType = A2(
				$elm$core$Maybe$withDefault,
				A2(
					$author$project$Types$FormattableAst$TypeName,
					_Utils_Tuple2(-1, -1),
					name),
				maybeFaType);
			return A2(
				$author$project$Compiler$FormattableToCanonicalAst$do,
				A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, faType),
				function (caType) {
					return A3(
						$author$project$Compiler$FormattableToCanonicalAst$addAttributes,
						ro,
						faTail,
						A3($elm$core$Dict$insert, name, caType, caAttrsAccum));
				});
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateType = F2(
	function (ro, faType) {
		switch (faType.$) {
			case 'TypeName':
				var p = faType.a;
				var name = faType.b;
				return A2(
					$author$project$Compiler$FormattableToCanonicalAst$translateType,
					ro,
					A3($author$project$Types$FormattableAst$TypePolymorphic, p, name, _List_Nil));
			case 'TypePolymorphic':
				var pos = faType.a;
				var rawName = faType.b;
				var args = faType.c;
				return A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A3(
						$author$project$Compiler$FormattableToCanonicalAst$stringToStructuredName,
						$author$project$Compiler$FormattableToCanonicalAst$initEnv(ro),
						pos,
						rawName),
					function (sname) {
						if (sname.$ === 'StructuredName_Value') {
							var name = sname.a.name;
							var mod = sname.a.mod;
							var attrPath = sname.a.attrPath;
							return (!_Utils_eq(args, _List_Nil)) ? $author$project$Types$Error$errorTodo('rank 2 types are not supported') : ((!_Utils_eq(mod, $author$project$Compiler$FormattableToCanonicalAst$NotSpecified)) ? $author$project$Types$Error$errorTodo('this is not a valid name for a type variable') : ((!_Utils_eq(attrPath, _List_Nil)) ? $author$project$Types$Error$errorTodo('no attribute accessors on types') : $elm$core$Result$Ok(
								A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Compiler$FormattableToCanonicalAst$todoPos, name))));
						} else {
							var name = sname.a.name;
							var mod = sname.a.mod;
							return A2(
								$author$project$Compiler$FormattableToCanonicalAst$do,
								A2(
									$author$project$Lib$list_mapRes,
									$author$project$Compiler$FormattableToCanonicalAst$translateType(ro),
									args),
								function (caArgs) {
									return $elm$core$Result$Ok(
										A3(
											$author$project$Types$CanonicalAst$TypeConstant,
											A2($author$project$Compiler$FormattableToCanonicalAst$tp, ro, pos),
											A4($author$project$Compiler$FormattableToCanonicalAst$resolveTypeName, ro, false, mod, name),
											caArgs));
								});
						}
					});
			case 'TypeFunction':
				var pos = faType.a;
				var fa_from = faType.b;
				var fromIsMut = faType.c;
				var fa_to = faType.d;
				return A3(
					$elm$core$Result$map2,
					F2(
						function (ca_from, ca_to) {
							return A4(
								$author$project$Types$CanonicalAst$TypeFunction,
								A2($author$project$Compiler$FormattableToCanonicalAst$tp, ro, pos),
								ca_from,
								$elm$core$Maybe$Just(fromIsMut),
								ca_to);
						}),
					A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, fa_from),
					A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, fa_to));
			case 'TypeTuple':
				var pos = faType.a;
				var types = faType.b;
				_v2$2:
				while (true) {
					if (types.b && types.b.b) {
						if (!types.b.b.b) {
							var faFirst = types.a;
							var _v3 = types.b;
							var faSecond = _v3.a;
							return A3(
								$elm$core$Result$map2,
								F2(
									function (caFirst, caSecond) {
										return A3(
											$author$project$Types$CanonicalAst$TypeRecord,
											A2($author$project$Compiler$FormattableToCanonicalAst$tp, ro, pos),
											$elm$core$Maybe$Nothing,
											A3(
												$elm$core$Dict$insert,
												'second',
												caSecond,
												A3($elm$core$Dict$insert, 'first', caFirst, $elm$core$Dict$empty)));
									}),
								A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, faFirst),
								A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, faSecond));
						} else {
							if (!types.b.b.b.b) {
								var faFirst = types.a;
								var _v4 = types.b;
								var faSecond = _v4.a;
								var _v5 = _v4.b;
								var faThird = _v5.a;
								return A4(
									$elm$core$Result$map3,
									F3(
										function (caFirst, caSecond, caThird) {
											return A3(
												$author$project$Types$CanonicalAst$TypeRecord,
												A2($author$project$Compiler$FormattableToCanonicalAst$tp, ro, pos),
												$elm$core$Maybe$Nothing,
												A3(
													$elm$core$Dict$insert,
													'third',
													caThird,
													A3(
														$elm$core$Dict$insert,
														'second',
														caSecond,
														A3($elm$core$Dict$insert, 'first', caFirst, $elm$core$Dict$empty))));
										}),
									A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, faFirst),
									A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, faSecond),
									A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, faThird));
							} else {
								break _v2$2;
							}
						}
					} else {
						break _v2$2;
					}
				}
				return $author$project$Types$Error$errorTodo('Tuples can only have size 2 or 3. Use a record.');
			default:
				var p = faType.a;
				var recordArgs = faType.b;
				return (!_Utils_eq(recordArgs._extends, $elm$core$Maybe$Nothing)) ? A2($author$project$Compiler$FormattableToCanonicalAst$errorExperimentingWithNoExtensibleTypes, ro, p) : A3($author$project$Compiler$FormattableToCanonicalAst$addAttributes, ro, recordArgs.attrs, $elm$core$Dict$empty);
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateConstructor = F3(
	function (ro, faType, constructors) {
		translateConstructor:
		while (true) {
			switch (faType.$) {
				case 'TypeName':
					var pos = faType.a;
					var name = faType.b;
					var $temp$ro = ro,
						$temp$faType = A3($author$project$Types$FormattableAst$TypePolymorphic, pos, name, _List_Nil),
						$temp$constructors = constructors;
					ro = $temp$ro;
					faType = $temp$faType;
					constructors = $temp$constructors;
					continue translateConstructor;
				case 'TypePolymorphic':
					var pos = faType.a;
					var fa_name = faType.b;
					var fa_args = faType.c;
					return A2(
						$author$project$Compiler$FormattableToCanonicalAst$do,
						A3(
							$author$project$Compiler$FormattableToCanonicalAst$stringToStructuredName,
							$author$project$Compiler$FormattableToCanonicalAst$initEnv(ro),
							pos,
							fa_name),
						function (sname) {
							if (sname.$ === 'StructuredName_Value') {
								return $author$project$Types$Error$errorTodo('constructor name must start with a uppercase letter');
							} else {
								var consArgs = sname.a;
								if (!_Utils_eq(consArgs.mod, $author$project$Compiler$FormattableToCanonicalAst$NotSpecified)) {
									return $author$project$Types$Error$errorTodo('something\'s wrong with  the cons name');
								} else {
									var name = A2($author$project$Compiler$FormattableToCanonicalAst$makeRootName, ro.currentModule, consArgs.name);
									return A2($elm$core$Dict$member, name, constructors) ? $author$project$Types$Error$errorTodo('constructor ' + (name + ' is duplicate')) : A2(
										$author$project$Compiler$FormattableToCanonicalAst$do,
										A2(
											$author$project$Lib$list_mapRes,
											$author$project$Compiler$FormattableToCanonicalAst$translateType(ro),
											fa_args),
										function (caArgs) {
											return $elm$core$Result$Ok(
												A3($elm$core$Dict$insert, name, caArgs, constructors));
										});
								}
							}
						});
				default:
					return $author$project$Types$Error$errorTodo('either this constructor does not start with a name, either there\'s something off with the operators');
			}
		}
	});
var $author$project$Compiler$CoreModule$cons = A2(
	$author$project$Types$CanonicalAst$Variable,
	$author$project$Compiler$CoreModule$p,
	{attrPath: _List_Nil, isRoot: true, name: $author$project$Compiler$CoreModule$listCons.name});
var $author$project$Types$CanonicalAst$PatternRecord = F2(
	function (a, b) {
		return {$: 'PatternRecord', a: a, b: b};
	});
var $author$project$Types$FormattableAst$patternPos = function (pa) {
	switch (pa.$) {
		case 'PatternAny':
			var p = pa.a;
			return p;
		case 'PatternLiteral':
			var p = pa.a;
			return p;
		case 'PatternApplication':
			var p = pa.a;
			return p;
		case 'PatternList':
			var p = pa.a;
			return p;
		case 'PatternRecord':
			var p = pa.a;
			return p;
		case 'PatternCons':
			var p = pa.a;
			return p;
		default:
			var p = pa.a;
			return p;
	}
};
var $author$project$Compiler$FormattableToCanonicalAst$errorCantDeclareAFunctionHere = F3(
	function (env, _v0, originalPattern) {
		var name = _v0.a;
		var args = _v0.b;
		return A2(
			$author$project$Types$Error$makeRes,
			env.ro.currentModule,
			_List_fromArray(
				[
					A3(
					$author$project$Types$Error$showLines,
					env.ro.code,
					2,
					$author$project$Types$FormattableAst$patternPos(originalPattern).a),
					$author$project$Types$Error$text('it seems like there is a function declaration inside a pattern?')
				]));
	});
var $author$project$Compiler$FormattableToCanonicalAst$resolveValueName = $author$project$Compiler$FormattableToCanonicalAst$resolveName(
	function ($) {
		return $.globalValues;
	});
var $author$project$Compiler$FormattableToCanonicalAst$translatePattern = F2(
	function (env, faPattern) {
		return A2(
			$author$project$Compiler$FormattableToCanonicalAst$do,
			A2($author$project$Compiler$FormattableToCanonicalAst$translatePatternOrFunction, env, faPattern),
			function (either) {
				if (either.$ === 'Left') {
					var caPattern = either.a;
					return $elm$core$Result$Ok(caPattern);
				} else {
					var fn = either.a;
					return A3($author$project$Compiler$FormattableToCanonicalAst$errorCantDeclareAFunctionHere, env, fn, faPattern);
				}
			});
	});
var $author$project$Compiler$FormattableToCanonicalAst$translatePatternOrFunction = F2(
	function (env, fa) {
		translatePatternOrFunction:
		while (true) {
			switch (fa.$) {
				case 'PatternAny':
					var pos = fa.a;
					var s = fa.b;
					var $temp$env = env,
						$temp$fa = A3($author$project$Types$FormattableAst$PatternApplication, pos, s, _List_Nil);
					env = $temp$env;
					fa = $temp$fa;
					continue translatePatternOrFunction;
				case 'PatternLiteral':
					var pos = fa.a;
					var l = fa.b;
					return $elm$core$Result$Ok(
						$author$project$Lib$Left(
							A2(
								$author$project$Types$CanonicalAst$PatternLiteral,
								A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
								l)));
				case 'PatternApplication':
					var pos = fa.a;
					var rawName = fa.b;
					var faArgs = fa.c;
					return A2(
						$author$project$Compiler$FormattableToCanonicalAst$do,
						A3(
							$author$project$Compiler$FormattableToCanonicalAst$stringToStructuredName,
							_Utils_update(
								env,
								{maybeUpdateTarget: $elm$core$Maybe$Nothing}),
							pos,
							rawName),
						function (sname) {
							return A2(
								$author$project$Compiler$FormattableToCanonicalAst$do,
								A2(
									$author$project$Lib$list_mapRes,
									$author$project$Compiler$FormattableToCanonicalAst$translatePattern(env),
									faArgs),
								function (caArgs) {
									if (sname.$ === 'StructuredName_TypeOrCons') {
										var name = sname.a.name;
										var mod = sname.a.mod;
										return $elm$core$Result$Ok(
											$author$project$Lib$Left(
												A3(
													$author$project$Types$CanonicalAst$PatternConstructor,
													A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
													A4($author$project$Compiler$FormattableToCanonicalAst$resolveValueName, env.ro, false, mod, name),
													caArgs)));
									} else {
										var name = sname.a.name;
										var mod = sname.a.mod;
										var attrPath = sname.a.attrPath;
										if (!_Utils_eq(attrPath, _List_Nil)) {
											return $author$project$Types$Error$errorTodo('can\'t use attribute access inside a pattern');
										} else {
											switch (mod.$) {
												case 'AlreadyEmbedded':
													return $author$project$Types$Error$errorTodo('can\'t use attribute shorthands inside a pattern');
												case 'ResolvedTo':
													return $author$project$Types$Error$errorTodo('It looks like you are trying to reference some module value, but I need just a new variable name');
												default:
													return _Utils_eq(caArgs, _List_Nil) ? $elm$core$Result$Ok(
														$author$project$Lib$Left(
															A2(
																$author$project$Types$CanonicalAst$PatternAny,
																A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
																name))) : $elm$core$Result$Ok(
														$author$project$Lib$Right(
															_Utils_Tuple2(name, caArgs)));
											}
										}
									}
								});
						});
				case 'PatternList':
					var pos = fa.a;
					var fas = fa.b;
					var fold = F2(
						function (pattern, last) {
							return A3(
								$author$project$Types$CanonicalAst$PatternConstructor,
								A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
								$author$project$Compiler$CoreModule$listCons.name,
								_List_fromArray(
									[pattern, last]));
						});
					return A2(
						$elm$core$Result$map,
						A2(
							$elm$core$Basics$composeR,
							A2(
								$elm$core$List$foldr,
								fold,
								A3(
									$author$project$Types$CanonicalAst$PatternConstructor,
									A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
									$author$project$Compiler$CoreModule$listNil.name,
									_List_Nil)),
							$author$project$Lib$Left),
						A2(
							$author$project$Lib$list_mapRes,
							$author$project$Compiler$FormattableToCanonicalAst$translatePattern(env),
							fas));
				case 'PatternRecord':
					var pos = fa.a;
					var recordArgs = fa.b;
					if (!_Utils_eq(recordArgs._extends, $elm$core$Maybe$Nothing)) {
						return $author$project$Types$Error$errorTodo('can\'t use `with` inside patterns');
					} else {
						var fold = F2(
							function (_v4, dict) {
								var name = _v4.a;
								var maybePattern = _v4.b;
								if (A2($elm$core$Dict$member, name, dict)) {
									return $author$project$Types$Error$errorTodo('duplicate attribute name in pattern: ' + name);
								} else {
									if (maybePattern.$ === 'Nothing') {
										return $elm$core$Result$Ok(
											A3(
												$elm$core$Dict$insert,
												name,
												A2(
													$author$project$Types$CanonicalAst$PatternAny,
													A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
													name),
												dict));
									} else {
										var faPattern = maybePattern.a;
										return A2(
											$elm$core$Result$map,
											function (caPattern) {
												return A3($elm$core$Dict$insert, name, caPattern, dict);
											},
											A2($author$project$Compiler$FormattableToCanonicalAst$translatePattern, env, faPattern));
									}
								}
							});
						return A2(
							$elm$core$Result$map,
							A2(
								$elm$core$Basics$composeR,
								$author$project$Types$CanonicalAst$PatternRecord(
									A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos)),
								$author$project$Lib$Left),
							A3($author$project$Lib$list_foldlRes, fold, recordArgs.attrs, $elm$core$Dict$empty));
					}
				case 'PatternCons':
					var pos = fa.a;
					var faHead = fa.b;
					var faTail = fa.c;
					return A3(
						$elm$core$Result$map2,
						F2(
							function (caHead, caTail) {
								return $author$project$Lib$Left(
									A3(
										$author$project$Types$CanonicalAst$PatternConstructor,
										A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
										$author$project$Compiler$CoreModule$listCons.name,
										_List_fromArray(
											[caHead, caTail])));
							}),
						A2($author$project$Compiler$FormattableToCanonicalAst$translatePattern, env, faHead),
						A2($author$project$Compiler$FormattableToCanonicalAst$translatePattern, env, faTail));
				default:
					var pos = fa.a;
					var fas = fa.b;
					_v5$2:
					while (true) {
						if (fas.b && fas.b.b) {
							if (!fas.b.b.b) {
								var fa1 = fas.a;
								var _v6 = fas.b;
								var fa2 = _v6.a;
								return A2(
									$author$project$Compiler$FormattableToCanonicalAst$translatePatternOrFunction,
									env,
									A2(
										$author$project$Types$FormattableAst$PatternRecord,
										pos,
										{
											attrs: _List_fromArray(
												[
													_Utils_Tuple2(
													'first',
													$elm$core$Maybe$Just(fa1)),
													_Utils_Tuple2(
													'second',
													$elm$core$Maybe$Just(fa2))
												]),
											_extends: $elm$core$Maybe$Nothing
										}));
							} else {
								if (!fas.b.b.b.b) {
									var fa1 = fas.a;
									var _v7 = fas.b;
									var fa2 = _v7.a;
									var _v8 = _v7.b;
									var fa3 = _v8.a;
									return A2(
										$author$project$Compiler$FormattableToCanonicalAst$translatePatternOrFunction,
										env,
										A2(
											$author$project$Types$FormattableAst$PatternRecord,
											pos,
											{
												attrs: _List_fromArray(
													[
														_Utils_Tuple2(
														'first',
														$elm$core$Maybe$Just(fa1)),
														_Utils_Tuple2(
														'second',
														$elm$core$Maybe$Just(fa2)),
														_Utils_Tuple2(
														'third',
														$elm$core$Maybe$Just(fa3))
													]),
												_extends: $elm$core$Maybe$Nothing
											}));
								} else {
									break _v5$2;
								}
							}
						} else {
							break _v5$2;
						}
					}
					return $author$project$Types$Error$errorTodo('tuples can be only of size 2 or 3');
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$insertDefinedNames = F3(
	function (env, stat, names) {
		if (stat.$ === 'Definition') {
			var fa = stat.a;
			var _v1 = A2($author$project$Compiler$FormattableToCanonicalAst$translatePatternOrFunction, env, fa.pattern);
			if (_v1.$ === 'Err') {
				return names;
			} else {
				if (_v1.a.$ === 'Left') {
					var caPattern = _v1.a.a;
					return A2(
						$elm$core$Set$union,
						names,
						$author$project$Types$CanonicalAst$patternNames(caPattern));
				} else {
					var _v2 = _v1.a.a;
					var fnName = _v2.a;
					var fnArgs = _v2.b;
					return A2($elm$core$Set$insert, fnName, names);
				}
			}
		} else {
			return names;
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$makeBinop = F4(
	function (caPos, left, op, right) {
		var _v0 = _Utils_Tuple3(left, op, right);
		_v0$2:
		while (true) {
			switch (_v0.b) {
				case '>>':
					if (_v0.c.$ === 'ArgumentExpression') {
						var rightExpr = _v0.c.a;
						return A3($author$project$Types$CanonicalAst$Call, caPos, rightExpr, left);
					} else {
						break _v0$2;
					}
				case '<<':
					if (_v0.a.$ === 'ArgumentExpression') {
						var leftExpr = _v0.a.a;
						return A3($author$project$Types$CanonicalAst$Call, caPos, leftExpr, right);
					} else {
						break _v0$2;
					}
				default:
					break _v0$2;
			}
		}
		return A3(
			$author$project$Types$CanonicalAst$Call,
			caPos,
			A3(
				$author$project$Types$CanonicalAst$Call,
				caPos,
				A2(
					$author$project$Types$CanonicalAst$Variable,
					caPos,
					{attrPath: _List_Nil, isRoot: true, name: op}),
				right),
			left);
	});
var $author$project$Compiler$CoreModule$nil = A2(
	$author$project$Types$CanonicalAst$Variable,
	$author$project$Compiler$CoreModule$p,
	{attrPath: _List_Nil, isRoot: true, name: $author$project$Compiler$CoreModule$listNil.name});
var $author$project$Compiler$FormattableToCanonicalAst$notAllSeparators = F2(
	function (f, ls) {
		notAllSeparators:
		while (true) {
			if (!ls.b) {
				return false;
			} else {
				var _v1 = ls.a;
				var sep = _v1.a;
				var item = _v1.b;
				var tail = ls.b;
				if (f(sep)) {
					var $temp$f = f,
						$temp$ls = tail;
					f = $temp$f;
					ls = $temp$ls;
					continue notAllSeparators;
				} else {
					return true;
				}
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$sameDirectionAs = F2(
	function (a, b) {
		if (_Utils_eq(a, b)) {
			return true;
		} else {
			switch (a) {
				case '>':
					return b === '>=';
				case '>=':
					return b === '>';
				case '<':
					return b === '<=';
				case '<=':
					return b === '<';
				default:
					return false;
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateMaybeAnnotation = F2(
	function (ro, fa) {
		var _v0 = fa.maybeAnnotation;
		if (_v0.$ === 'Nothing') {
			return $elm$core$Result$Ok($elm$core$Maybe$Nothing);
		} else {
			var annotation = _v0.a;
			return A2(
				$elm$core$Result$map,
				$elm$core$Maybe$Just,
				A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, annotation.ty));
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$validateFaDefinition = function (fa) {
	var maybeName = function () {
		var _v2 = fa.pattern;
		if (_v2.$ === 'PatternAny') {
			var n = _v2.b;
			return $elm$core$Maybe$Just(n);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	}();
	var _v0 = fa.maybeAnnotation;
	if (_v0.$ === 'Nothing') {
		return $elm$core$Result$Ok(_Utils_Tuple0);
	} else {
		var annotation = _v0.a;
		if (!_Utils_eq(fa.mutable, annotation.mutable)) {
			return $author$project$Types$Error$errorTodo('annotation mutability doesn\'t match definition mutability');
		} else {
			if (maybeName.$ === 'Nothing') {
				return $elm$core$Result$Ok(_Utils_Tuple0);
			} else {
				var name = maybeName.a;
				return (!_Utils_eq(annotation.name, name)) ? $author$project$Types$Error$errorTodo('annotation name doesn\'t match definition name') : $elm$core$Result$Ok(_Utils_Tuple0);
			}
		}
	}
};
var $author$project$Types$CanonicalAst$patternPos = function (pa) {
	switch (pa.$) {
		case 'PatternDiscard':
			var p = pa.a;
			return p;
		case 'PatternAny':
			var p = pa.a;
			var n = pa.b;
			return p;
		case 'PatternLiteral':
			var p = pa.a;
			return p;
		case 'PatternConstructor':
			var p = pa.a;
			var path = pa.b;
			var ps = pa.c;
			return p;
		default:
			var p = pa.a;
			var ps = pa.b;
			return p;
	}
};
var $author$project$Compiler$FormattableToCanonicalAst$wrapLambda = F4(
	function (ro, faWholePos, param, bodyAccum) {
		var paramPos = $author$project$Types$CanonicalAst$patternPos(param);
		var end = faWholePos.b;
		var lambdaPos = _Utils_update(
			paramPos,
			{e: end});
		return _List_fromArray(
			[
				$author$project$Types$CanonicalAst$Evaluation(
				A3($author$project$Types$CanonicalAst$Lambda, lambdaPos, param, bodyAccum))
			]);
	});
var $author$project$Compiler$FormattableToCanonicalAst$makeUpdateTarget = F2(
	function (env, maybeUpdateTarget) {
		var _v27 = A2(
			$elm$core$Maybe$map,
			$author$project$Compiler$FormattableToCanonicalAst$translateExpression(
				_Utils_update(
					env,
					{maybeUpdateTarget: $elm$core$Maybe$Nothing})),
			maybeUpdateTarget);
		if (_v27.$ === 'Nothing') {
			return $elm$core$Result$Ok(
				{maybeName: $elm$core$Maybe$Nothing, wrapper: $elm$core$Basics$identity});
		} else {
			if (_v27.a.$ === 'Err') {
				var e = _v27.a.a;
				return $elm$core$Result$Err(e);
			} else {
				if (_v27.a.a.$ === 'Variable') {
					var _v28 = _v27.a.a;
					var args = _v28.b;
					return $elm$core$Result$Ok(
						{
							maybeName: $elm$core$Maybe$Just(args),
							wrapper: $elm$core$Basics$identity
						});
				} else {
					var expr = _v27.a.a;
					return $author$project$Types$Error$errorTodo('NI { (expr) with ...} not yet implemented =(');
				}
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateArgument = F2(
	function (env, faExpr) {
		if (faExpr.$ === 'Mutable') {
			var pos = faExpr.a;
			var faName = faExpr.b;
			return A2(
				$author$project$Compiler$FormattableToCanonicalAst$do,
				A3(
					$author$project$Compiler$FormattableToCanonicalAst$stringToStructuredName,
					_Utils_update(
						env,
						{maybeUpdateTarget: $elm$core$Maybe$Nothing}),
					pos,
					faName),
				function (sname) {
					if (sname.$ === 'StructuredName_TypeOrCons') {
						return $author$project$Types$Error$errorTodo('constructors can\'t be mutable?');
					} else {
						var name = sname.a.name;
						var mod = sname.a.mod;
						var attrPath = sname.a.attrPath;
						return (_Utils_eq(mod, $author$project$Compiler$FormattableToCanonicalAst$NotSpecified) && A2($elm$core$Set$member, name, env.nonRootValues)) ? $elm$core$Result$Ok(
							$author$project$Types$CanonicalAst$ArgumentMutable(
								{attrPath: attrPath, isRoot: false, name: name})) : $author$project$Types$Error$errorTodo(
							'only values declared inside a function scope can be mutated!' + $elm$core$Debug$toString(
								{
									env: _Utils_update(
										env,
										{maybeUpdateTarget: $elm$core$Maybe$Nothing}),
									rawName: faName,
									sname: sname
								}));
					}
				});
		} else {
			return A2(
				$elm$core$Result$map,
				$author$project$Types$CanonicalAst$ArgumentExpression,
				A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, faExpr));
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateAttrsRec = F3(
	function (env, faAttrs, caAttrsAccum) {
		if (!faAttrs.b) {
			return $elm$core$Result$Ok(caAttrsAccum);
		} else {
			var _v23 = faAttrs.a;
			var attrName = _v23.a;
			var maybeAttrExpression = _v23.b;
			var faTail = faAttrs.b;
			var exprRes = function () {
				if (maybeAttrExpression.$ === 'Just') {
					var faExpr = maybeAttrExpression.a;
					return A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, faExpr);
				} else {
					var declaredInsideFunction = A2($elm$core$Set$member, attrName, env.nonRootValues);
					return $elm$core$Result$Ok(
						A2(
							$author$project$Types$CanonicalAst$Variable,
							$author$project$Compiler$FormattableToCanonicalAst$todoPos,
							{
								attrPath: _List_Nil,
								isRoot: !declaredInsideFunction,
								name: A4($author$project$Compiler$FormattableToCanonicalAst$resolveValueName, env.ro, declaredInsideFunction, $author$project$Compiler$FormattableToCanonicalAst$NotSpecified, attrName)
							}));
				}
			}();
			return A2(
				$author$project$Compiler$FormattableToCanonicalAst$do,
				exprRes,
				function (expr) {
					return A3(
						$author$project$Compiler$FormattableToCanonicalAst$translateAttrsRec,
						env,
						faTail,
						A3($elm$core$Dict$insert, attrName, expr, caAttrsAccum));
				});
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateBinopSepList = F4(
	function (env, pos, leftAccum, opsAndRight) {
		return A2(
			$author$project$Compiler$FormattableToCanonicalAst$do,
			A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, leftAccum),
			function (caLeftAccum) {
				return A4($author$project$Compiler$FormattableToCanonicalAst$translateBinopSepListRec, env, pos, caLeftAccum, opsAndRight);
			});
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateBinopSepListRec = F4(
	function (env, pos, leftAccum, opsAndRight) {
		translateBinopSepListRec:
		while (true) {
			if (!opsAndRight.b) {
				return $elm$core$Result$Ok(leftAccum);
			} else {
				var _v20 = opsAndRight.a;
				var op = _v20.a;
				var faRight = _v20.b;
				var tail = opsAndRight.b;
				var _v21 = A2($author$project$Compiler$FormattableToCanonicalAst$translateArgument, env, faRight);
				if (_v21.$ === 'Err') {
					var e = _v21.a;
					return $elm$core$Result$Err(e);
				} else {
					var caRight = _v21.a;
					var $temp$env = env,
						$temp$pos = pos,
						$temp$leftAccum = A4(
						$author$project$Compiler$FormattableToCanonicalAst$makeBinop,
						A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
						$author$project$Types$CanonicalAst$ArgumentExpression(leftAccum),
						op,
						caRight),
						$temp$opsAndRight = tail;
					env = $temp$env;
					pos = $temp$pos;
					leftAccum = $temp$leftAccum;
					opsAndRight = $temp$opsAndRight;
					continue translateBinopSepListRec;
				}
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateBinops = F4(
	function (env, pos, group, _v11) {
		var firstItem = _v11.a;
		var firstTail = _v11.b;
		if (!firstTail.b) {
			return A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, firstItem);
		} else {
			if (!firstTail.b.b) {
				var _v13 = firstTail.a;
				var firstSep = _v13.a;
				var secondItem = _v13.b;
				if (group.$ === 'Tuple') {
					return A3(
						$elm$core$Result$map2,
						F2(
							function (first, second) {
								return A3(
									$author$project$Types$CanonicalAst$Record,
									A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
									$elm$core$Maybe$Nothing,
									A3(
										$elm$core$Dict$insert,
										'second',
										second,
										A3($elm$core$Dict$insert, 'first', first, $elm$core$Dict$empty)));
							}),
						A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, firstItem),
						A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, secondItem));
				} else {
					return A5($author$project$Compiler$FormattableToCanonicalAst$translateSimpleBinop, env, pos, firstItem, firstSep, secondItem);
				}
			} else {
				var _v15 = firstTail.a;
				var firstSep = _v15.a;
				var secondItem = _v15.b;
				var _v16 = firstTail.b;
				var _v17 = _v16.a;
				var secondSep = _v17.a;
				var thirdItem = _v17.b;
				var thirdTail = _v16.b;
				var secondTail = A2(
					$elm$core$List$cons,
					_Utils_Tuple2(secondSep, thirdItem),
					thirdTail);
				switch (group.$) {
					case 'Comparison':
						return A2(
							$author$project$Compiler$FormattableToCanonicalAst$notAllSeparators,
							$author$project$Compiler$FormattableToCanonicalAst$sameDirectionAs(firstSep),
							secondTail) ? $author$project$Types$Error$errorTodo('can\'t mix comparison ops with different direction') : $author$project$Types$Error$errorTodo('NI compops expansion');
					case 'Logical':
						return A2(
							$author$project$Compiler$FormattableToCanonicalAst$notAllSeparators,
							$elm$core$Basics$eq(firstSep),
							secondTail) ? $author$project$Types$Error$errorTodo('Mixing `and` and `or` is ambiguous. Use parens!') : A4($author$project$Compiler$FormattableToCanonicalAst$translateBinopSepList, env, pos, firstItem, firstTail);
					case 'Tuple':
						return (!_Utils_eq(thirdTail, _List_Nil)) ? $author$project$Types$Error$errorTodo('Tuples can\'t have more than 3 items, use a record instead.') : A4(
							$elm$core$Result$map3,
							F3(
								function (first, second, third) {
									return A3(
										$author$project$Types$CanonicalAst$Record,
										A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
										$elm$core$Maybe$Nothing,
										A3(
											$elm$core$Dict$insert,
											'third',
											third,
											A3(
												$elm$core$Dict$insert,
												'second',
												second,
												A3($elm$core$Dict$insert, 'first', first, $elm$core$Dict$empty))));
								}),
							A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, firstItem),
							A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, secondItem),
							A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, thirdItem));
					case 'Pipe':
						return A2(
							$author$project$Compiler$FormattableToCanonicalAst$notAllSeparators,
							$elm$core$Basics$eq(firstSep),
							secondTail) ? $author$project$Types$Error$errorTodo('Mixing pipes is ambigous. Use parens.') : A4($author$project$Compiler$FormattableToCanonicalAst$translateBinopSepList, env, pos, firstItem, firstTail);
					case 'Mutop':
						return $author$project$Types$Error$errorTodo('mutops can\'t be chained');
					default:
						return A4($author$project$Compiler$FormattableToCanonicalAst$translateBinopSepList, env, pos, firstItem, firstTail);
				}
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateDefinition = F3(
	function (isRoot, env, fa) {
		return A2(
			$author$project$Compiler$FormattableToCanonicalAst$do,
			$author$project$Compiler$FormattableToCanonicalAst$validateFaDefinition(fa),
			function (_v7) {
				return A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A2($author$project$Compiler$FormattableToCanonicalAst$translateMaybeAnnotation, env.ro, fa),
					function (maybeAnnotation) {
						return A2(
							$author$project$Compiler$FormattableToCanonicalAst$do,
							A2($author$project$Compiler$FormattableToCanonicalAst$translatePatternOrFunction, env, fa.pattern),
							function (patternOrFunction) {
								var _v8 = function () {
									if (patternOrFunction.$ === 'Left') {
										var p = patternOrFunction.a;
										return _Utils_Tuple2(p, _List_Nil);
									} else {
										var _v10 = patternOrFunction.a;
										var n = _v10.a;
										var pas = _v10.b;
										return _Utils_Tuple2(
											A2(
												$author$project$Types$CanonicalAst$PatternAny,
												A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, fa.pos),
												n),
											pas);
									}
								}();
								var name = _v8.a;
								var params = _v8.b;
								var additionalNonRootValues = isRoot ? params : A2($elm$core$List$cons, name, params);
								var localEnv = _Utils_update(
									env,
									{
										nonRootValues: A3(
											$elm$core$List$foldl,
											A2($elm$core$Basics$composeR, $author$project$Types$CanonicalAst$patternNames, $elm$core$Set$union),
											env.nonRootValues,
											additionalNonRootValues)
									});
								return A2(
									$author$project$Compiler$FormattableToCanonicalAst$do,
									A2($author$project$Compiler$FormattableToCanonicalAst$translateStatementBlock, localEnv, fa.body),
									function (body) {
										return $elm$core$Result$Ok(
											{
												body: A3(
													$elm$core$List$foldr,
													A2($author$project$Compiler$FormattableToCanonicalAst$wrapLambda, env.ro, fa.pos),
													body,
													params),
												maybeAnnotation: maybeAnnotation,
												mutable: fa.mutable,
												pattern: name
											});
									});
							});
					});
			});
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateExpression = F2(
	function (env, faExpr) {
		switch (faExpr.$) {
			case 'Literal':
				var pos = faExpr.a;
				var v = faExpr.b;
				return $elm$core$Result$Ok(
					A2(
						$author$project$Types$CanonicalAst$Literal,
						A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
						v));
			case 'Variable':
				var pos = faExpr.a;
				var isBinop = faExpr.b.isBinop;
				var faName = faExpr.c;
				return isBinop ? $elm$core$Result$Ok(
					A2(
						$author$project$Types$CanonicalAst$Variable,
						A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
						{attrPath: _List_Nil, isRoot: true, name: faName})) : A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A3($author$project$Compiler$FormattableToCanonicalAst$stringToStructuredName, env, pos, faName),
					function (sname) {
						var _v2 = function () {
							if (sname.$ === 'StructuredName_Value') {
								var a = sname.a;
								return _Utils_Tuple3(a.name, a.mod, a.attrPath);
							} else {
								var a = sname.a;
								return _Utils_Tuple3(a.name, a.mod, _List_Nil);
							}
						}();
						var name = _v2.a;
						var mod = _v2.b;
						var attrPath = _v2.c;
						var declaredInsideFunction = A2($elm$core$Set$member, name, env.nonRootValues);
						return $elm$core$Result$Ok(
							A2(
								$author$project$Types$CanonicalAst$Variable,
								A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
								{
									attrPath: attrPath,
									isRoot: !declaredInsideFunction,
									name: A4($author$project$Compiler$FormattableToCanonicalAst$resolveValueName, env.ro, declaredInsideFunction, mod, name)
								}));
					});
			case 'Lambda':
				var pos = faExpr.a;
				var faParams = faExpr.b;
				var faBody = faExpr.c;
				return A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A2(
						$author$project$Lib$list_mapRes,
						$author$project$Compiler$FormattableToCanonicalAst$translatePattern(env),
						faParams),
					function (caParams) {
						var localEnv = _Utils_update(
							env,
							{
								nonRootValues: A3(
									$elm$core$List$foldl,
									A2($elm$core$Basics$composeR, $author$project$Types$CanonicalAst$patternNames, $elm$core$Set$union),
									env.nonRootValues,
									caParams)
							});
						if (!caParams.b) {
							return _Debug_todo(
								'Compiler.FormattableToCanonicalAst',
								{
									start: {line: 735, column: 21},
									end: {line: 735, column: 31}
								})('TODO should not happen but should be fixable?');
						} else {
							var caHead = caParams.a;
							var caTail = caParams.b;
							return A2(
								$author$project$Compiler$FormattableToCanonicalAst$do,
								A2($author$project$Compiler$FormattableToCanonicalAst$translateStatementBlock, localEnv, faBody),
								function (caBody) {
									return $elm$core$Result$Ok(
										A3(
											$author$project$Types$CanonicalAst$Lambda,
											A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
											caHead,
											A3(
												$elm$core$List$foldr,
												A2($author$project$Compiler$FormattableToCanonicalAst$wrapLambda, env.ro, pos),
												caBody,
												caTail)));
								});
						}
					});
			case 'FunctionCall':
				var pos = faExpr.a;
				var reference = faExpr.b;
				var _arguments = faExpr.c;
				var fold = F2(
					function (argument, refAccum) {
						return A3(
							$author$project$Types$CanonicalAst$Call,
							A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
							refAccum,
							argument);
					});
				return A3(
					$elm$core$Result$map2,
					$elm$core$List$foldl(fold),
					A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, reference),
					A2(
						$author$project$Lib$list_mapRes,
						$author$project$Compiler$FormattableToCanonicalAst$translateArgument(env),
						_arguments));
			case 'If':
				var pos = faExpr.a;
				var condition = faExpr.b.condition;
				var _true = faExpr.b._true;
				var _false = faExpr.b._false;
				return A4(
					$elm$core$Result$map3,
					F3(
						function (c, t, f) {
							return A2(
								$author$project$Types$CanonicalAst$If,
								A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
								{
									condition: _List_fromArray(
										[
											$author$project$Types$CanonicalAst$Evaluation(c)
										]),
									_false: f,
									_true: t
								});
						}),
					A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, condition),
					A2($author$project$Compiler$FormattableToCanonicalAst$translateStatementBlock, env, _true),
					A2($author$project$Compiler$FormattableToCanonicalAst$translateStatementBlock, env, _false));
			case 'Binop':
				var pos = faExpr.a;
				var group = faExpr.b;
				var sepList = faExpr.c;
				return A4($author$project$Compiler$FormattableToCanonicalAst$translateBinops, env, pos, group, sepList);
			case 'Mutable':
				var pos = faExpr.a;
				var name = faExpr.b;
				return $author$project$Types$Error$errorTodo('mutable values can be used only as arguments for function or mutation operators');
			case 'Record':
				var pos = faExpr.a;
				var faArgs = faExpr.b;
				return A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A2($author$project$Compiler$FormattableToCanonicalAst$makeUpdateTarget, env, faArgs._extends),
					function (caUpdateTarget) {
						return A2(
							$author$project$Compiler$FormattableToCanonicalAst$do,
							A3(
								$author$project$Compiler$FormattableToCanonicalAst$translateAttrsRec,
								_Utils_update(
									env,
									{maybeUpdateTarget: caUpdateTarget.maybeName}),
								faArgs.attrs,
								$elm$core$Dict$empty),
							function (caAttrs) {
								return $elm$core$Result$Ok(
									caUpdateTarget.wrapper(
										A3(
											$author$project$Types$CanonicalAst$Record,
											A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
											caUpdateTarget.maybeName,
											caAttrs)));
							});
					});
			case 'List':
				var pos = faExpr.a;
				var faItems = faExpr.b;
				var caPos = A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos);
				var cons = F2(
					function (item, list) {
						return A3(
							$author$project$Types$CanonicalAst$Call,
							caPos,
							A3(
								$author$project$Types$CanonicalAst$Call,
								caPos,
								$author$project$Compiler$CoreModule$cons,
								$author$project$Types$CanonicalAst$ArgumentExpression(item)),
							$author$project$Types$CanonicalAst$ArgumentExpression(list));
					});
				return A2(
					$elm$core$Result$map,
					A2($elm$core$List$foldr, cons, $author$project$Compiler$CoreModule$nil),
					A2(
						$author$project$Lib$list_mapRes,
						$author$project$Compiler$FormattableToCanonicalAst$translateExpression(env),
						faItems));
			case 'Try':
				var pos = faExpr.a;
				var fa = faExpr.b;
				var translatePatternAndStatements = function (_v6) {
					var faPattern = _v6.a;
					var faStatements = _v6.b;
					return A2(
						$author$project$Compiler$FormattableToCanonicalAst$do,
						A2($author$project$Compiler$FormattableToCanonicalAst$translatePattern, env, faPattern),
						function (caPattern) {
							return A2(
								$author$project$Compiler$FormattableToCanonicalAst$do,
								A2(
									$author$project$Compiler$FormattableToCanonicalAst$translateStatementBlock,
									_Utils_update(
										env,
										{
											nonRootValues: A2(
												$elm$core$Set$union,
												$author$project$Types$CanonicalAst$patternNames(caPattern),
												env.nonRootValues)
										}),
									faStatements),
								function (block) {
									return $elm$core$Result$Ok(
										_Utils_Tuple2(caPattern, block));
								});
						});
				};
				return A4(
					$elm$core$Result$map3,
					F3(
						function (caValue, caPatternsAndStatements, caElse) {
							return A3(
								$author$project$Types$CanonicalAst$Try,
								A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
								caValue,
								_Utils_ap(caPatternsAndStatements, caElse));
						}),
					A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, fa.value),
					A2($author$project$Lib$list_mapRes, translatePatternAndStatements, fa.patterns),
					function () {
						var _v5 = fa.maybeElse;
						if (_v5.$ === 'Nothing') {
							return $elm$core$Result$Ok(_List_Nil);
						} else {
							var faBlock = _v5.a;
							return A2(
								$elm$core$Result$map,
								function (caBlock) {
									return _List_fromArray(
										[
											_Utils_Tuple2(
											$author$project$Types$CanonicalAst$PatternDiscard(
												A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos)),
											caBlock)
										]);
								},
								A2($author$project$Compiler$FormattableToCanonicalAst$translateStatementBlock, env, faBlock));
						}
					}());
			default:
				return $author$project$Types$Error$errorTodo(
					'FA expression type not supported for now:' + $elm$core$Debug$toString(faExpr));
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateSimpleBinop = F5(
	function (env, pos, left, op, right) {
		return A3(
			$elm$core$Result$map2,
			F2(
				function (l, r) {
					return A4(
						$author$project$Compiler$FormattableToCanonicalAst$makeBinop,
						A2($author$project$Compiler$FormattableToCanonicalAst$tp, env.ro, pos),
						l,
						op,
						r);
				}),
			A2($author$project$Compiler$FormattableToCanonicalAst$translateArgument, env, left),
			A2($author$project$Compiler$FormattableToCanonicalAst$translateArgument, env, right));
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateStatement = F2(
	function (env, faStat) {
		switch (faStat.$) {
			case 'Evaluation':
				var faExpr = faStat.a;
				return A2(
					$elm$core$Result$map,
					$author$project$Types$CanonicalAst$Evaluation,
					A2($author$project$Compiler$FormattableToCanonicalAst$translateExpression, env, faExpr));
			case 'Definition':
				var fa = faStat.a;
				return A2(
					$elm$core$Result$map,
					$author$project$Types$CanonicalAst$Definition,
					A3($author$project$Compiler$FormattableToCanonicalAst$translateDefinition, false, env, fa));
			case 'TypeAlias':
				var fa = faStat.a;
				return $author$project$Types$Error$errorTodo('Aliases can be declared only in the root scope');
			default:
				var fa = faStat.a;
				return $author$project$Types$Error$errorTodo('Types can be declared only in the root scope');
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateStatementBlock = F2(
	function (env, stats) {
		var localEnv = _Utils_update(
			env,
			{
				nonRootValues: A3(
					$elm$core$List$foldl,
					$author$project$Compiler$FormattableToCanonicalAst$insertDefinedNames(env),
					env.nonRootValues,
					stats)
			});
		return A2(
			$author$project$Lib$list_mapRes,
			$author$project$Compiler$FormattableToCanonicalAst$translateStatement(localEnv),
			stats);
	});
var $author$project$Compiler$FormattableToCanonicalAst$insertRootStatement = F3(
	function (ro, faStatement, caModule) {
		switch (faStatement.$) {
			case 'Evaluation':
				return $author$project$Types$Error$errorTodo('Root Evaluations don\'t really do much =|');
			case 'Definition':
				var fa = faStatement.a;
				return A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A3(
						$author$project$Compiler$FormattableToCanonicalAst$translateDefinition,
						true,
						$author$project$Compiler$FormattableToCanonicalAst$initEnv(ro),
						fa),
					function (def) {
						var _v1 = def.pattern;
						if (_v1.$ === 'PatternAny') {
							var caPos = _v1.a;
							var defName = _v1.b;
							var caName = A2($author$project$Compiler$FormattableToCanonicalAst$makeRootName, ro.currentModule, defName);
							return A2($elm$core$Dict$member, caName, caModule) ? $author$project$Types$Error$errorTodo(defName + ' declared twice!') : $elm$core$Result$Ok(
								A3(
									$elm$core$Dict$insert,
									caName,
									$author$project$Types$CanonicalAst$Value(
										_Utils_update(
											def,
											{
												pattern: A2($author$project$Types$CanonicalAst$PatternAny, caPos, caName)
											})),
									caModule));
						} else {
							return $author$project$Types$Error$errorTodo('patterns can\'t be used in root definitions!');
						}
					});
			case 'TypeAlias':
				var fa = faStatement.a;
				var caName = A2($author$project$Compiler$FormattableToCanonicalAst$makeRootName, ro.currentModule, fa.name);
				return A2($elm$core$Dict$member, caName, caModule) ? $author$project$Types$Error$errorTodo(fa.name + ' declared twice!') : ((!$author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar(fa.name)) ? $author$project$Types$Error$errorTodo('type name should be uppercase') : A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A2($author$project$Compiler$FormattableToCanonicalAst$translateType, ro, fa.ty),
					function (caType) {
						return $elm$core$Result$Ok(
							A3(
								$elm$core$Dict$insert,
								caName,
								$author$project$Types$CanonicalAst$Alias(
									{args: fa.args, name: caName, ty: caType}),
								caModule));
					}));
			default:
				var fa = faStatement.a;
				var caName = A2($author$project$Compiler$FormattableToCanonicalAst$makeRootName, ro.currentModule, fa.name);
				return A2($elm$core$Dict$member, caName, caModule) ? $author$project$Types$Error$errorTodo(fa.name + ' declared twice!') : ((!$author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar(fa.name)) ? $author$project$Types$Error$errorTodo('type name should be uppercase') : A2(
					$author$project$Compiler$FormattableToCanonicalAst$do,
					A3(
						$author$project$Lib$list_foldlRes,
						$author$project$Compiler$FormattableToCanonicalAst$translateConstructor(ro),
						fa.constructors,
						$elm$core$Dict$empty),
					function (constructors) {
						return $elm$core$Result$Ok(
							A3(
								$elm$core$Dict$insert,
								caName,
								$author$project$Types$CanonicalAst$Union(
									{args: fa.args, constructors: constructors, name: caName}),
								caModule));
					}));
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst$translateModule = F3(
	function (ro, faModule, caModule) {
		if (!faModule.b) {
			return $elm$core$Result$Ok(caModule);
		} else {
			var faStat = faModule.a;
			var faStatTail = faModule.b;
			return A2(
				$elm$core$Result$andThen,
				A2($author$project$Compiler$FormattableToCanonicalAst$translateModule, ro, faStatTail),
				A3($author$project$Compiler$FormattableToCanonicalAst$insertRootStatement, ro, faStat, caModule));
		}
	});
var $author$project$Compiler$Pipeline$stringToCanonicalAst = F4(
	function (meta, moduleName, code, accum) {
		var ro = {code: code, currentModule: moduleName, meta: meta};
		return A2(
			$elm$core$Result$andThen,
			function (fa) {
				return A3($author$project$Compiler$FormattableToCanonicalAst$translateModule, ro, fa, accum);
			},
			A2($author$project$Compiler$Pipeline$stringToFormattableAst, moduleName, code));
	});
var $elm$virtual_dom$VirtualDom$style = _VirtualDom_style;
var $elm$html$Html$Attributes$style = $elm$virtual_dom$VirtualDom$style;
var $elm$html$Html$ul = _VirtualDom_node('ul');
var $elm$core$Result$withDefault = F2(
	function (def, result) {
		if (result.$ === 'Ok') {
			var a = result.a;
			return a;
		} else {
			return def;
		}
	});
var $author$project$Main$viewProgram = function (model) {
	var titleAndPreCode = F2(
		function (title, text) {
			return A2(
				$elm$html$Html$li,
				_List_Nil,
				_List_fromArray(
					[
						A2(
						$elm$html$Html$h6,
						_List_Nil,
						_List_fromArray(
							[
								$elm$html$Html$text(title)
							])),
						A2(
						$elm$html$Html$pre,
						_List_Nil,
						_List_fromArray(
							[
								A2(
								$elm$html$Html$code,
								_List_Nil,
								_List_fromArray(
									[
										$elm$html$Html$text(text)
									]))
							]))
					]));
		});
	var emitModule = function (caModule) {
		return $elm$core$Result$Ok(
			A2(
				$elm$core$String$join,
				'\n\n',
				_Utils_ap(
					_List_fromArray(
						[$author$project$Compiler$CanonicalToJs$nativeDefinitions]),
					A2(
						$elm$core$List$map,
						$author$project$Compiler$JsToString$emitStatement(0),
						$author$project$Compiler$CanonicalToJs$translateAll(caModule)))));
	};
	var _do = $author$project$Lib$result_do;
	var compileAndInsert = F4(
		function (meta, fileName, code, acc) {
			return _Utils_eq(fileName, $author$project$Main$metaFileName) ? $elm$core$Result$Ok(acc) : $author$project$Compiler$TestHelpers$resErrorToString(
				function (fa) {
					return A4($author$project$Compiler$Pipeline$stringToCanonicalAst, meta, fileName, fa, acc);
				}(
					$author$project$Compiler$TestHelpers$unindent(code)));
		});
	var programResult = function (meta) {
		return A2(
			_do,
			A3(
				$author$project$Lib$dict_foldRes,
				compileAndInsert(meta),
				model.files,
				$author$project$Prelude$prelude),
			function (allDefs) {
				var withAliases = $author$project$Compiler$TestHelpers$resErrorToString(
					$author$project$Compiler$ApplyAliases$applyAliasesToModule(allDefs));
				return A2(
					_do,
					withAliases,
					function (alsDefs) {
						var blah = $author$project$Compiler$TestHelpers$resErrorToString(
							A2($author$project$Compiler$TypeInference$inspectModule, $elm$core$Dict$empty, alsDefs));
						return A2(
							_do,
							blah,
							function (_v3) {
								var typedProgram = _v3.a;
								return $elm$core$Result$Ok(typedProgram);
							});
					});
			});
	};
	return A2(
		$elm$html$Html$ul,
		_List_fromArray(
			[
				$elm$html$Html$Attributes$class('ml mt border'),
				A2($elm$html$Html$Attributes$style, 'padding-right', '1em')
			]),
		function () {
			var _v0 = $author$project$Main$getMeta(model);
			if (_v0.$ === 'Err') {
				var e = _v0.a;
				return _List_fromArray(
					[
						$elm$html$Html$text(e)
					]);
			} else {
				var meta = _v0.a;
				var _v1 = programResult(meta);
				if (_v1.$ === 'Err') {
					var e = _v1.a;
					return _List_fromArray(
						[
							A2(
							$elm$html$Html$pre,
							_List_Nil,
							_List_fromArray(
								[
									$elm$html$Html$text(e)
								]))
						]);
				} else {
					var program = _v1.a;
					return _List_fromArray(
						[
							A2(
							titleAndPreCode,
							'JavaScript value for Mod.result:',
							function () {
								var _v2 = A2($author$project$Compiler$JsToString_Test$runProgram, 'Main.result', program);
								if (_v2.$ === 'Ok') {
									var res = _v2.a;
									return res;
								} else {
									var message = _v2.a;
									return 'Error: ### ' + (message + ' ###');
								}
							}()),
							A2(
							titleAndPreCode,
							'Evaluated JavaScript code:',
							A2(
								$elm$core$Result$withDefault,
								'error',
								emitModule(program)))
						]);
				}
			}
		}());
};
var $author$project$Main$OnInput = function (a) {
	return {$: 'OnInput', a: a};
};
var $elm$core$String$fromFloat = _String_fromNumber;
var $elm$core$List$maximum = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(
			A3($elm$core$List$foldl, $elm$core$Basics$max, x, xs));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm$html$Html$Events$alwaysStop = function (x) {
	return _Utils_Tuple2(x, true);
};
var $elm$virtual_dom$VirtualDom$MayStopPropagation = function (a) {
	return {$: 'MayStopPropagation', a: a};
};
var $elm$html$Html$Events$stopPropagationOn = F2(
	function (event, decoder) {
		return A2(
			$elm$virtual_dom$VirtualDom$on,
			event,
			$elm$virtual_dom$VirtualDom$MayStopPropagation(decoder));
	});
var $elm$json$Json$Decode$at = F2(
	function (fields, decoder) {
		return A3($elm$core$List$foldr, $elm$json$Json$Decode$field, decoder, fields);
	});
var $elm$html$Html$Events$targetValue = A2(
	$elm$json$Json$Decode$at,
	_List_fromArray(
		['target', 'value']),
	$elm$json$Json$Decode$string);
var $elm$html$Html$Events$onInput = function (tagger) {
	return A2(
		$elm$html$Html$Events$stopPropagationOn,
		'input',
		A2(
			$elm$json$Json$Decode$map,
			$elm$html$Html$Events$alwaysStop,
			A2($elm$json$Json$Decode$map, tagger, $elm$html$Html$Events$targetValue)));
};
var $elm$html$Html$Attributes$spellcheck = $elm$html$Html$Attributes$boolProperty('spellcheck');
var $elm$html$Html$textarea = _VirtualDom_node('textarea');
var $elm$html$Html$Attributes$value = $elm$html$Html$Attributes$stringProperty('value');
var $elm$html$Html$span = _VirtualDom_node('span');
var $author$project$Main$tokenToClass = F2(
	function (meta, token) {
		var _v0 = token.kind;
		switch (_v0.$) {
			case 'Comment':
				return 'comment';
			case 'TextLiteral':
				return 'literal';
			case 'NumberLiteral':
				return 'literal';
			case 'HasType':
				return 'op';
			case 'Fn':
				return 'keyword';
			case 'If':
				return 'keyword';
			case 'Try':
				return 'keyword';
			case 'As':
				return 'keyword';
			case 'Then':
				return 'keyword';
			case 'Else':
				return 'keyword';
			case 'With':
				return 'keyword';
			case 'Defop':
				return 'op';
			case 'Unop':
				return 'op';
			case 'Binop':
				return 'op';
			case 'Arrow':
				return 'op';
			case 'RoundParen':
				return 'paren';
			case 'SquareBracket':
				return 'paren';
			case 'CurlyBrace':
				return 'paren';
			case 'Comma':
				return 'paren';
			case 'Name':
				switch (_v0.b) {
					case 'alias':
						return 'keyword';
					case 'union':
						return 'keyword';
					default:
						var mutable = _v0.a.mutable;
						var name = _v0.b;
						return mutable ? 'mutable' : ((A2($elm$core$Dict$member, name, meta.globalValues) || A2($elm$core$Dict$member, name, meta.globalTypes)) ? ($author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar(name) ? 'globalUp' : 'globalLo') : ($author$project$Compiler$FormattableToCanonicalAst$startsWithUpperChar(name) ? 'valueUp' : 'valueLo'));
				}
			default:
				return '';
		}
	});
var $author$project$Main$viewColorToken = F4(
	function (meta, code, token, _v0) {
		var start = _v0.a;
		var accum = _v0.b;
		var slice = A3($elm$core$String$slice, start, token.end, code);
		var acc = A2($elm$core$String$startsWith, ' ', slice) ? A2(
			$elm$core$List$cons,
			A2(
				$elm$html$Html$span,
				_List_fromArray(
					[
						$elm$html$Html$Attributes$class(
						A2($author$project$Main$tokenToClass, meta, token))
					]),
				_List_fromArray(
					[
						$elm$html$Html$text(
						A2($elm$core$String$dropLeft, 1, slice))
					])),
			A2(
				$elm$core$List$cons,
				A2(
					$elm$html$Html$span,
					_List_Nil,
					_List_fromArray(
						[
							$elm$html$Html$text(' ')
						])),
				accum)) : A2(
			$elm$core$List$cons,
			A2(
				$elm$html$Html$span,
				_List_fromArray(
					[
						$elm$html$Html$Attributes$class(
						A2($author$project$Main$tokenToClass, meta, token))
					]),
				_List_fromArray(
					[
						$elm$html$Html$text(slice)
					])),
			accum);
		return _Utils_Tuple2(token.end, acc);
	});
var $author$project$Main$viewSyntaxHighlight = F2(
	function (meta, code) {
		var _v0 = $author$project$Compiler$StringToTokens$lexer(code);
		if (_v0.$ === 'Err') {
			return _List_fromArray(
				[
					$elm$html$Html$text(code)
				]);
		} else {
			var tokens = _v0.a;
			return $elm$core$List$reverse(
				A3(
					$elm$core$List$foldl,
					A2($author$project$Main$viewColorToken, meta, code),
					_Utils_Tuple2(0, _List_Nil),
					tokens).b);
		}
	});
var $author$project$Main$viewCodeEditor = F2(
	function (model, code) {
		var width = A2(
			$elm$core$Basics$max,
			40,
			A2(
				$elm$core$Maybe$withDefault,
				10,
				$elm$core$List$maximum(
					A2(
						$elm$core$List$map,
						$elm$core$String$length,
						A2($elm$core$String$split, '\n', code)))));
		var widthAttr = A2(
			$elm$html$Html$Attributes$style,
			'width',
			function (s) {
				return s + 'px';
			}(
				$elm$core$String$fromFloat(9 * width)));
		var viewLineNumber = function (n) {
			return $elm$core$String$fromInt(n);
		};
		var meta = A2(
			$elm$core$Result$withDefault,
			$author$project$Types$Meta$init,
			$author$project$Main$getMeta(model));
		var height = A2(
			$elm$core$Basics$max,
			15,
			$elm$core$List$length(
				A2($elm$core$String$split, '\n', code)));
		var heightAttr = A2(
			$elm$html$Html$Attributes$style,
			'height',
			function (s) {
				return s + 'px';
			}(
				$elm$core$String$fromFloat(18 * (1 + height))));
		return A2(
			$elm$html$Html$div,
			_List_fromArray(
				[
					$elm$html$Html$Attributes$class('editor'),
					$elm$html$Html$Attributes$class('row')
				]),
			_List_fromArray(
				[
					A2(
					$elm$html$Html$div,
					_List_fromArray(
						[
							$elm$html$Html$Attributes$class('editor-line-numbers'),
							heightAttr
						]),
					_List_fromArray(
						[
							$elm$html$Html$text(
							A2(
								$elm$core$String$join,
								'\n',
								A2(
									$elm$core$List$map,
									$elm$core$String$fromInt,
									A2($elm$core$List$range, 1, height))))
						])),
					A2(
					$elm$html$Html$div,
					_List_fromArray(
						[
							$elm$html$Html$Attributes$class('editor-content'),
							widthAttr,
							heightAttr
						]),
					_List_fromArray(
						[
							A2(
							$elm$html$Html$textarea,
							_List_fromArray(
								[
									$elm$html$Html$Attributes$class('editor-textarea'),
									$elm$html$Html$Events$onInput($author$project$Main$OnInput),
									$elm$html$Html$Attributes$value(code),
									$elm$html$Html$Attributes$spellcheck(false)
								]),
							_List_fromArray(
								[
									$elm$html$Html$text(code)
								])),
							A2(
							$elm$html$Html$div,
							_List_fromArray(
								[
									$elm$html$Html$Attributes$class('editor-overlay')
								]),
							A2($author$project$Main$viewSyntaxHighlight, meta, code))
						]))
				]));
	});
var $author$project$Main$onJust = F2(
	function (maybeResA, f) {
		if ((maybeResA.$ === 'Just') && (maybeResA.a.$ === 'Ok')) {
			var a = maybeResA.a.a;
			return $elm$core$Maybe$Just(
				f(a));
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Main$indentToStringRec = F3(
	function (cur, ind, acc) {
		indentToStringRec:
		while (true) {
			var shift = function (s) {
				return _Utils_ap(
					A2($elm$core$String$repeat, cur, '  '),
					s);
			};
			switch (ind.$) {
				case 'S':
					var s = ind.a;
					return A2(
						$elm$core$List$cons,
						shift(s),
						acc);
				case 'M':
					if (ind.a.$ === 'Just') {
						var s = ind.a.a;
						return A2(
							$elm$core$List$cons,
							shift(s),
							acc);
					} else {
						var _v1 = ind.a;
						return acc;
					}
				case 'P':
					var i = ind.a;
					var _v2 = A3($author$project$Main$indentToStringRec, cur, i, _List_Nil);
					if (!_v2.b) {
						return acc;
					} else {
						if (!_v2.b.b) {
							var a = _v2.a;
							return A2(
								$elm$core$List$cons,
								shift('(') + (a + ')'),
								acc);
						} else {
							var many = _v2;
							return A2(
								$elm$core$List$cons,
								shift(')'),
								A3(
									$author$project$Main$indentToStringRec,
									cur + 1,
									i,
									A2(
										$elm$core$List$cons,
										shift('('),
										acc)));
						}
					}
				case 'I':
					var i = ind.a;
					var $temp$cur = cur + 1,
						$temp$ind = i,
						$temp$acc = acc;
					cur = $temp$cur;
					ind = $temp$ind;
					acc = $temp$acc;
					continue indentToStringRec;
				default:
					var inds = ind.a;
					return A3(
						$elm$core$List$foldl,
						$author$project$Main$indentToStringRec(cur),
						acc,
						inds);
			}
		}
	});
var $author$project$Main$indentToString = function (indent) {
	return A2(
		$elm$core$String$join,
		'\n',
		$elm$core$List$reverse(
			A3($author$project$Main$indentToStringRec, 0, indent, _List_Nil)));
};
var $author$project$Main$viewCaAlias = function (al) {
	return A2(
		$elm$html$Html$pre,
		_List_Nil,
		_List_fromArray(
			[
				$elm$html$Html$text(
				A2(
					$elm$core$String$join,
					' ',
					_List_fromArray(
						[
							'alias',
							al.name,
							A2($elm$core$String$join, ' ', al.args),
							'=',
							$author$project$Human$CanonicalAst$typeToString(al.ty)
						])))
			]));
};
var $author$project$Main$I = function (a) {
	return {$: 'I', a: a};
};
var $author$project$Main$L = function (a) {
	return {$: 'L', a: a};
};
var $author$project$Main$M = function (a) {
	return {$: 'M', a: a};
};
var $author$project$Main$P = function (a) {
	return {$: 'P', a: a};
};
var $author$project$Main$S = function (a) {
	return {$: 'S', a: a};
};
var $author$project$Main$viewCaPattern = function (p) {
	switch (p.$) {
		case 'PatternDiscard':
			return '_';
		case 'PatternAny':
			var n = p.b;
			return n;
		default:
			return $elm$core$Debug$toString(p);
	}
};
var $author$project$Main$viewCaVariableArgs = function (s) {
	return $author$project$Main$S(
		A2(
			$elm$core$String$join,
			'',
			A2(
				$elm$core$List$cons,
				s.name,
				A2(
					$elm$core$List$map,
					function (a) {
						return '.' + a;
					},
					s.attrPath))));
};
var $author$project$Main$viewCaDefinition = function (def) {
	return $author$project$Main$L(
		_List_fromArray(
			[
				$author$project$Main$M(
				A2(
					$elm$core$Maybe$map,
					function (x) {
						return $author$project$Main$viewCaPattern(def.pattern) + (' : ' + $author$project$Human$CanonicalAst$typeToString(x));
					},
					def.maybeAnnotation)),
				$author$project$Main$S(
				$author$project$Main$viewCaPattern(def.pattern) + ' = '),
				$author$project$Main$I(
				$author$project$Main$L(
					A2($elm$core$List$map, $author$project$Main$viewCaStatement, def.body)))
			]));
};
var $author$project$Main$viewCaExpression = function (expr) {
	switch (expr.$) {
		case 'Literal':
			switch (expr.b.$) {
				case 'Text':
					var s = expr.b.a;
					return $author$project$Main$S(s);
				case 'Number':
					var s = expr.b.a;
					return $author$project$Main$S(s);
				default:
					var s = expr.b.a;
					return $author$project$Main$S(
						$elm$core$Debug$toString(s));
			}
		case 'Variable':
			var s = expr.b;
			return $author$project$Main$viewCaVariableArgs(s);
		case 'Call':
			var reference = expr.b;
			var argument = expr.c;
			return $author$project$Main$L(
				_List_fromArray(
					[
						$author$project$Main$viewCaExpression(reference),
						$author$project$Main$I(
						function () {
							if (argument.$ === 'ArgumentMutable') {
								var args = argument.a;
								return $author$project$Main$S(
									'@' + (args.name + A2($elm$core$String$join, ':', args.attrPath)));
							} else {
								var e = argument.a;
								return $author$project$Main$viewCaExpression(e);
							}
						}())
					]));
		case 'Lambda':
			var param = expr.b;
			var body = expr.c;
			return $author$project$Main$P(
				$author$project$Main$L(
					_List_fromArray(
						[
							$author$project$Main$S(
							'fn ' + ($author$project$Main$viewCaPattern(param) + ' =')),
							$author$project$Main$I(
							$author$project$Main$L(
								A2($elm$core$List$map, $author$project$Main$viewCaStatement, body)))
						])));
		case 'Record':
			var _extends = expr.b;
			var attrs = expr.c;
			return $author$project$Main$L(
				_List_fromArray(
					[
						$author$project$Main$S('{'),
						$author$project$Main$L(
						A2(
							$elm$core$Maybe$withDefault,
							_List_Nil,
							A2(
								$elm$core$Maybe$map,
								function (e) {
									return _List_fromArray(
										[
											$author$project$Main$viewCaVariableArgs(e),
											$author$project$Main$S(' with ')
										]);
								},
								_extends))),
						$author$project$Main$L(
						A2(
							$elm$core$List$map,
							function (_v3) {
								var n = _v3.a;
								var e = _v3.b;
								return $author$project$Main$L(
									_List_fromArray(
										[
											$author$project$Main$S(n + ' = '),
											$author$project$Main$viewCaExpression(e)
										]));
							},
							A2(
								$elm$core$List$sortBy,
								$elm$core$Tuple$first,
								$elm$core$Dict$toList(attrs)))),
						$author$project$Main$S('}')
					]));
		default:
			return $author$project$Main$S(
				$elm$core$Debug$toString(
					A2(
						$author$project$Types$CanonicalAst$extensionFold_expression,
						F2(
							function (_v4, _v5) {
								return _Utils_Tuple2($author$project$Types$CanonicalAst$posDummy, _Utils_Tuple0);
							}),
						_Utils_Tuple2(expr, _Utils_Tuple0)).b));
	}
};
var $author$project$Main$viewCaStatement = function (s) {
	if (s.$ === 'Evaluation') {
		var expr = s.a;
		return $author$project$Main$P(
			$author$project$Main$viewCaExpression(expr));
	} else {
		var def = s.a;
		return $author$project$Main$I(
			$author$project$Main$viewCaDefinition(def));
	}
};
var $author$project$Main$viewCaUnion = function (u) {
	return A2(
		$elm$html$Html$div,
		_List_Nil,
		_List_fromArray(
			[
				$elm$html$Html$text(
				A2(
					$elm$core$String$join,
					' ',
					_List_fromArray(
						[
							'union:',
							u.name,
							A2($elm$core$String$join, ' ', u.args),
							'=',
							$elm$core$Debug$toString(u.constructors)
						])))
			]));
};
var $author$project$Main$viewCanonicalAst = function (mod) {
	var v = function (_v1) {
		var name = _v1.a;
		var rv = _v1.b;
		switch (rv.$) {
			case 'Alias':
				var a = rv.a;
				return $author$project$Main$viewCaAlias(a);
			case 'Union':
				var u = rv.a;
				return $author$project$Main$viewCaUnion(u);
			default:
				var d = rv.a;
				return $elm$html$Html$text(
					$author$project$Main$indentToString(
						$author$project$Main$viewCaDefinition(d)));
		}
	};
	return A2(
		$elm$html$Html$pre,
		_List_Nil,
		A2(
			$elm$core$List$map,
			v,
			A2(
				$elm$core$List$sortBy,
				$elm$core$Tuple$first,
				$elm$core$Dict$toList(mod))));
};
var $author$project$Main$viewFaExpression = function (expr) {
	switch (expr.$) {
		case 'Literal':
			var pos = expr.a;
			var s = expr.b;
			return $elm$html$Html$text(
				$elm$core$Debug$toString(s));
		case 'Variable':
			var pos = expr.a;
			var isBinop = expr.b.isBinop;
			var s = expr.c;
			return $elm$html$Html$text(s);
		case 'FunctionCall':
			var pos = expr.a;
			var reference = expr.b;
			var _arguments = expr.c;
			return A2(
				$elm$html$Html$div,
				_List_fromArray(
					[
						A2($elm$html$Html$Attributes$style, 'border', 'red')
					]),
				_List_fromArray(
					[
						A2(
						$elm$html$Html$div,
						_List_Nil,
						_List_fromArray(
							[
								$elm$html$Html$text('[call] '),
								$author$project$Main$viewFaExpression(reference)
							])),
						A2(
						$elm$html$Html$div,
						_List_fromArray(
							[
								A2($elm$html$Html$Attributes$style, 'padding-left', '2em')
							]),
						A2($elm$core$List$map, $author$project$Main$viewFaExpression, _arguments))
					]));
		case 'Binop':
			var pos = expr.a;
			var group = expr.b;
			var sepList = expr.c;
			return A2(
				$elm$html$Html$div,
				_List_fromArray(
					[
						A2($elm$html$Html$Attributes$style, 'border', 'red')
					]),
				_List_fromArray(
					[
						A2(
						$elm$html$Html$div,
						_List_Nil,
						_List_fromArray(
							[
								$elm$html$Html$text('[op] ')
							])),
						A2(
						$elm$html$Html$div,
						_List_fromArray(
							[
								A2($elm$html$Html$Attributes$style, 'padding-left', '2em')
							]),
						_List_Nil),
						A2(
						$elm$html$Html$div,
						_List_Nil,
						_List_fromArray(
							[
								$elm$html$Html$text('---')
							])),
						A2(
						$elm$html$Html$div,
						_List_fromArray(
							[
								A2($elm$html$Html$Attributes$style, 'padding-left', '2em')
							]),
						_List_Nil)
					]));
		default:
			return A2(
				$elm$html$Html$code,
				_List_Nil,
				_List_fromArray(
					[
						$elm$html$Html$text(
						$elm$core$Debug$toString(expr))
					]));
	}
};
var $author$project$Main$viewFaPattern = function (p) {
	if (p.$ === 'PatternAny') {
		var n = p.b;
		return n;
	} else {
		return $elm$core$Debug$toString(p);
	}
};
var $author$project$Main$viewFaStatement = function (s) {
	switch (s.$) {
		case 'UnionDef':
			var td = s.a;
			return A2(
				$elm$html$Html$div,
				_List_Nil,
				_List_fromArray(
					[
						$elm$html$Html$text(
						'type definition: ' + $elm$core$Debug$toString(td))
					]));
		case 'TypeAlias':
			var td = s.a;
			return A2(
				$elm$html$Html$div,
				_List_Nil,
				_List_fromArray(
					[
						$elm$html$Html$text(
						'type alias: ' + $elm$core$Debug$toString(td))
					]));
		case 'Evaluation':
			var expr = s.a;
			return A2(
				$elm$html$Html$div,
				_List_Nil,
				_List_fromArray(
					[
						$elm$html$Html$text('Evaluation: '),
						$author$project$Main$viewFaExpression(expr)
					]));
		default:
			var pattern = s.a.pattern;
			var maybeAnnotation = s.a.maybeAnnotation;
			var body = s.a.body;
			return A2(
				$elm$html$Html$div,
				_List_Nil,
				_List_fromArray(
					[
						A2(
						$elm$html$Html$span,
						_List_Nil,
						_List_fromArray(
							[
								$elm$html$Html$text(
								$author$project$Main$viewFaPattern(pattern))
							])),
						$elm$html$Html$text(
						A2(
							$elm$core$Maybe$withDefault,
							'',
							A2(
								$elm$core$Maybe$map,
								function (x) {
									return ' : ' + $elm$core$Debug$toString(x);
								},
								maybeAnnotation))),
						A2(
						$elm$html$Html$div,
						_List_Nil,
						A2($elm$core$List$map, $author$project$Main$viewFaStatement, body))
					]));
	}
};
var $author$project$Main$viewFormattableAst = function (statements) {
	return A2(
		$elm$html$Html$div,
		_List_Nil,
		A2($elm$core$List$map, $author$project$Main$viewFaStatement, statements));
};
var $author$project$Main$viewMaybeRes = F3(
	function (code, f, maybeRes) {
		if (maybeRes.$ === 'Nothing') {
			return $elm$html$Html$text('');
		} else {
			var res = maybeRes.a;
			var _v1 = $author$project$Compiler$TestHelpers$resErrorToString(res);
			if (_v1.$ === 'Err') {
				var e = _v1.a;
				return A2(
					$elm$html$Html$code,
					_List_Nil,
					_List_fromArray(
						[
							$elm$html$Html$text(e)
						]));
			} else {
				var a = _v1.a;
				return f(a);
			}
		}
	});
var $author$project$Main$viewTokens = function (tokens) {
	return A2(
		$elm$html$Html$div,
		_List_Nil,
		A2(
			$elm$core$List$map,
			function (t) {
				return A2(
					$elm$html$Html$div,
					_List_Nil,
					_List_fromArray(
						[
							$elm$html$Html$text(
							$elm$core$Debug$toString(t.kind))
						]));
			},
			tokens));
};
var $author$project$Main$viewFileStages = F2(
	function (model, rawCode) {
		var code = $author$project$Compiler$TestHelpers$unindent(rawCode);
		var tokens = A2(
			$author$project$Main$onJust,
			$elm$core$Maybe$Just(
				$elm$core$Result$Ok(code)),
			$author$project$Compiler$StringToTokens$lexer);
		var faModule = A2(
			$author$project$Main$onJust,
			tokens,
			A2($author$project$Compiler$TokensToFormattableAst$parse, code, model.selectedFile));
		var caModule = function () {
			var _v0 = $author$project$Main$getMeta(model);
			if (_v0.$ === 'Ok') {
				var meta = _v0.a;
				var ro = {code: code, currentModule: model.selectedFile, meta: meta};
				return A2(
					$author$project$Main$onJust,
					faModule,
					function (fa) {
						return A3($author$project$Compiler$FormattableToCanonicalAst$translateModule, ro, fa, $elm$core$Dict$empty);
					});
			} else {
				var e = _v0.a;
				return $elm$core$Maybe$Just(
					$author$project$Types$Error$errorTodo(e));
			}
		}();
		return A2(
			$elm$html$Html$ul,
			_List_Nil,
			_List_fromArray(
				[
					A2(
					$elm$html$Html$li,
					_List_Nil,
					_List_fromArray(
						[
							A2(
							$elm$html$Html$h6,
							_List_Nil,
							_List_fromArray(
								[
									$elm$html$Html$text('Canonical AST')
								])),
							A3($author$project$Main$viewMaybeRes, code, $author$project$Main$viewCanonicalAst, caModule)
						])),
					A2(
					$elm$html$Html$li,
					_List_Nil,
					_List_fromArray(
						[
							A2(
							$elm$html$Html$h6,
							_List_Nil,
							_List_fromArray(
								[
									$elm$html$Html$text('Formattable AST')
								])),
							A3($author$project$Main$viewMaybeRes, code, $author$project$Main$viewFormattableAst, faModule)
						])),
					A2(
					$elm$html$Html$li,
					_List_Nil,
					_List_fromArray(
						[
							A2(
							$elm$html$Html$h6,
							_List_Nil,
							_List_fromArray(
								[
									$elm$html$Html$text('Tokens')
								])),
							A3($author$project$Main$viewMaybeRes, code, $author$project$Main$viewTokens, tokens)
						]))
				]));
	});
var $author$project$Main$viewMeta = F2(
	function (model, code) {
		var _v0 = $author$project$Main$getMeta(model);
		if (_v0.$ === 'Err') {
			var s = _v0.a;
			return $elm$html$Html$text(s);
		} else {
			var meta = _v0.a;
			return $elm$html$Html$text(
				$elm$core$Debug$toString(meta));
		}
	});
var $author$project$Main$viewSelectedFile = function (model) {
	var code = A2(
		$elm$core$Maybe$withDefault,
		'',
		A2($elm$core$Dict$get, model.selectedFile, model.files));
	return A2(
		$elm$html$Html$div,
		_List_fromArray(
			[
				$elm$html$Html$Attributes$class('col mt ml')
			]),
		_List_fromArray(
			[
				A2($author$project$Main$viewCodeEditor, model, code),
				_Utils_eq(model.selectedFile, $author$project$Main$metaFileName) ? A2($author$project$Main$viewMeta, model, code) : A2($author$project$Main$viewFileStages, model, code)
			]));
};
var $author$project$Main$runTests = false || true;
var $author$project$Test$Group = F2(
	function (a, b) {
		return {$: 'Group', a: a, b: b};
	});
var $elm$core$Result$fromMaybe = F2(
	function (err, maybe) {
		if (maybe.$ === 'Just') {
			var v = maybe.a;
			return $elm$core$Result$Ok(v);
		} else {
			return $elm$core$Result$Err(err);
		}
	});
var $author$project$Types$CanonicalAst$extensionFold_aliasDef = F2(
	function (f, _v0) {
		var def = _v0.a;
		var acc = _v0.b;
		return A2(
			$elm$core$Tuple$mapFirst,
			function (b_ty) {
				return {args: def.args, name: def.name, ty: b_ty};
			},
			A2(
				$author$project$Types$CanonicalAst$extensionFold_type,
				f,
				_Utils_Tuple2(def.ty, acc)));
	});
var $author$project$Types$CanonicalAst$extensionFold_unionDef = F2(
	function (f, _v0) {
		var def = _v0.a;
		var acc = _v0.b;
		var foldArgument = F2(
			function (a_arg, _v2) {
				var b_args = _v2.a;
				var accX = _v2.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_arg) {
						return A2($elm$core$List$cons, b_arg, b_args);
					},
					A2(
						$author$project$Types$CanonicalAst$extensionFold_type,
						f,
						_Utils_Tuple2(a_arg, accX)));
			});
		var foldConstructor = F3(
			function (constructorName, a_constructorArgs, _v1) {
				var b_constructors = _v1.a;
				var accX = _v1.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					function (b_constructorArgs) {
						return A3($elm$core$Dict$insert, constructorName, b_constructorArgs, b_constructors);
					},
					A3(
						$elm$core$List$foldr,
						foldArgument,
						_Utils_Tuple2(_List_Nil, accX),
						a_constructorArgs));
			});
		return A2(
			$elm$core$Tuple$mapFirst,
			function (b_constructors) {
				return {args: def.args, constructors: b_constructors, name: def.name};
			},
			A3(
				$elm$core$Dict$foldl,
				foldConstructor,
				_Utils_Tuple2($elm$core$Dict$empty, acc),
				def.constructors));
	});
var $author$project$Types$CanonicalAst$extensionFold_module = F2(
	function (f, _v0) {
		var a_defs = _v0.a;
		var acc0 = _v0.b;
		var fold = F3(
			function (name, a_rootDef, _v2) {
				var b_defs = _v2.a;
				var accX = _v2.b;
				switch (a_rootDef.$) {
					case 'Alias':
						var a_aliasDef = a_rootDef.a;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (b_rootDef) {
								return A3(
									$elm$core$Dict$insert,
									name,
									$author$project$Types$CanonicalAst$Alias(b_rootDef),
									b_defs);
							},
							A2(
								$author$project$Types$CanonicalAst$extensionFold_aliasDef,
								f,
								_Utils_Tuple2(a_aliasDef, accX)));
					case 'Union':
						var a_unionDef = a_rootDef.a;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (b_rootDef) {
								return A3(
									$elm$core$Dict$insert,
									name,
									$author$project$Types$CanonicalAst$Union(b_rootDef),
									b_defs);
							},
							A2(
								$author$project$Types$CanonicalAst$extensionFold_unionDef,
								f,
								_Utils_Tuple2(a_unionDef, accX)));
					default:
						var a_valueDef = a_rootDef.a;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (b_rootDef) {
								return A3(
									$elm$core$Dict$insert,
									name,
									$author$project$Types$CanonicalAst$Value(b_rootDef),
									b_defs);
							},
							A2(
								$author$project$Types$CanonicalAst$extensionFold_valueDef,
								f,
								_Utils_Tuple2(a_valueDef, accX)));
				}
			});
		return A3(
			$elm$core$Dict$foldl,
			fold,
			_Utils_Tuple2($elm$core$Dict$empty, acc0),
			a_defs);
	});
var $author$project$Compiler$TestHelpers$p = {c: '', e: 0, n: 'th', s: 0};
var $author$project$Compiler$TestHelpers$removePos = F2(
	function (fold_helper, target) {
		return A2(
			fold_helper,
			F2(
				function (_v0, _v1) {
					return _Utils_Tuple2($author$project$Compiler$TestHelpers$p, _Utils_Tuple0);
				}),
			_Utils_Tuple2(target, _Utils_Tuple0)).a;
	});
var $author$project$Prelude$metaFile = function () {
	var _v0 = $author$project$MetaFile$stringToMetaFile($author$project$Prelude$metaString);
	if (_v0.$ === 'Ok') {
		var f = _v0.a;
		return f;
	} else {
		var error = _v0.a;
		return _Debug_todo(
			'Prelude',
			{
				start: {line: 123, column: 13},
				end: {line: 123, column: 23}
			})('Prelude MetaFile error: ' + error);
	}
}();
var $author$project$Prelude$meta = $author$project$MetaFile$toMeta($author$project$Prelude$metaFile);
var $author$project$Compiler$TestHelpers$moduleName = 'Test';
var $author$project$Compiler$TestHelpers$stringToCanonicalModuleWithPos = function (code) {
	return A2(
		$elm$core$Result$andThen,
		$author$project$Compiler$ApplyAliases$applyAliasesToModule,
		function (c) {
			return A4($author$project$Compiler$Pipeline$stringToCanonicalAst, $author$project$Prelude$meta, $author$project$Compiler$TestHelpers$moduleName, c, $author$project$Prelude$prelude);
		}(
			$author$project$Compiler$TestHelpers$unindent(code)));
};
var $author$project$Compiler$TestHelpers$stringToCanonicalModule = function (code) {
	return A2(
		$elm$core$Result$map,
		$author$project$Compiler$TestHelpers$removePos($author$project$Types$CanonicalAst$extensionFold_module),
		$author$project$Compiler$TestHelpers$stringToCanonicalModuleWithPos(code));
};
var $author$project$Compiler$ApplyAliases_Test$applyAndGet = F3(
	function (getAs, name, code) {
		return A2(
			$elm$core$Result$andThen,
			A2(
				$elm$core$Basics$composeR,
				getAs,
				$elm$core$Result$fromMaybe('wrong variant')),
			A2(
				$elm$core$Result$andThen,
				A2(
					$elm$core$Basics$composeR,
					$elm$core$Dict$get('Test.' + name),
					$elm$core$Result$fromMaybe('dict error!')),
				$author$project$Compiler$TestHelpers$resErrorToString(
					$author$project$Compiler$TestHelpers$stringToCanonicalModule(code))));
	});
var $author$project$Types$CanonicalAst$findValue = F2(
	function (name, mod) {
		var _v0 = A2($elm$core$Dict$get, name, mod);
		if ((_v0.$ === 'Just') && (_v0.a.$ === 'Value')) {
			var valueDef = _v0.a.a;
			return $elm$core$Maybe$Just(valueDef);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Compiler$ApplyAliases_Test$applyAndGetValue = F2(
	function (name, code) {
		return A2(
			$elm$core$Result$andThen,
			A2(
				$elm$core$Basics$composeR,
				$author$project$Types$CanonicalAst$findValue('Test.' + name),
				$elm$core$Result$fromMaybe('findValue error!')),
			$author$project$Compiler$TestHelpers$resErrorToString(
				$author$project$Compiler$TestHelpers$stringToCanonicalModule(code)));
	});
var $author$project$Types$CanonicalAst$asUnion = function (r) {
	if (r.$ === 'Union') {
		var u = r.a;
		return $elm$core$Maybe$Just(u);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Test$errorShouldContain = F2(
	function (s, error) {
		return A2($elm$core$String$contains, s, error) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just('\nThe error... \n\n' + (error + ('\n\n...should contain \"' + (s + '\"'))));
	});
var $author$project$Test$Error = function (a) {
	return {$: 'Error', a: a};
};
var $author$project$Test$Single = F2(
	function (a, b) {
		return {$: 'Single', a: a, b: b};
	});
var $author$project$Test$Success = {$: 'Success'};
var $author$project$Test$maybeToOutcome = function (m) {
	if (m.$ === 'Just') {
		var e = m.a;
		return $author$project$Test$Error(e);
	} else {
		return $author$project$Test$Success;
	}
};
var $author$project$Test$hasError = F2(
	function (toString, _v0) {
		var name = _v0.name;
		var run = _v0.run;
		var test = _v0.test;
		return A2(
			$author$project$Test$Single,
			name,
			function (_v1) {
				var _v2 = run(name);
				if (_v2.$ === 'Ok') {
					var outcome = _v2.a;
					return $author$project$Test$Error(
						'Ok: ' + toString(outcome));
				} else {
					var e = _v2.a;
					return $author$project$Test$maybeToOutcome(
						test(e));
				}
			});
	});
var $author$project$Compiler$ApplyAliases_Test$hasError = $author$project$Test$hasError($elm$core$Debug$toString);
var $author$project$Test$simple = F2(
	function (toString, _v0) {
		var name = _v0.name;
		var run = _v0.run;
		var expected = _v0.expected;
		return A2(
			$author$project$Test$Single,
			name,
			function (_v1) {
				var actual = run(name);
				return _Utils_eq(actual, expected) ? $author$project$Test$Success : $author$project$Test$Error(
					A2(
						$elm$core$String$join,
						'',
						_List_fromArray(
							[
								'Expected: ',
								toString(expected),
								'\n',
								'Actual  : ',
								toString(actual)
							])));
			});
	});
var $author$project$Compiler$ApplyAliases_Test$simpleTest = $author$project$Test$simple($elm$core$Debug$toString);
var $author$project$Compiler$ApplyAliases_Test$tests = A2(
	$author$project$Test$Group,
	'ApplyAliases',
	_List_fromArray(
		[
			A2(
			$author$project$Test$Group,
			'annotations',
			_List_fromArray(
				[
					$author$project$Compiler$ApplyAliases_Test$simpleTest(
					{
						expected: $elm$core$Result$Ok(
							$elm$core$Maybe$Just(
								A3(
									$author$project$Types$CanonicalAst$TypeAlias,
									$author$project$Compiler$TestHelpers$p,
									'Test.A',
									A3(
										$author$project$Types$CanonicalAst$TypeConstant,
										$author$project$Compiler$TestHelpers$p,
										'SPCore.List',
										_List_fromArray(
											[
												A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, 'SPCore.Number', _List_Nil)
											]))))),
						name: 'simple',
						run: function (_v0) {
							return A2(
								$elm$core$Result$map,
								function ($) {
									return $.maybeAnnotation;
								},
								A2($author$project$Compiler$ApplyAliases_Test$applyAndGetValue, 'a', '\n                        alias A b c = List b\n                        a : A Number Bool\n                        a = a\n                        '));
						}
					}),
					$author$project$Compiler$ApplyAliases_Test$hasError(
					{
						name: 'Reject wrong number of args',
						run: function (_v1) {
							return A2($author$project$Compiler$ApplyAliases_Test$applyAndGetValue, 'a', '\n                        alias A b c = List b\n                        a : A Bool\n                        a = a\n                        ');
						},
						test: $author$project$Test$errorShouldContain('alias Test.A needs 2 args, but was used with 1')
					}),
					$author$project$Compiler$ApplyAliases_Test$simpleTest(
					{
						expected: $elm$core$Result$Ok(
							$elm$core$Maybe$Just(
								A3(
									$author$project$Types$CanonicalAst$TypeAlias,
									$author$project$Compiler$TestHelpers$p,
									'Test.A',
									A3(
										$author$project$Types$CanonicalAst$TypeRecord,
										$author$project$Compiler$TestHelpers$p,
										$elm$core$Maybe$Nothing,
										A3(
											$elm$core$Dict$insert,
											'y',
											A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, 'SPCore.Bool', _List_Nil),
											A3(
												$elm$core$Dict$insert,
												'x',
												A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, 'SPCore.Bool', _List_Nil),
												$elm$core$Dict$empty)))))),
						name: 'record',
						run: function (_v2) {
							return A2(
								$elm$core$Result$map,
								function ($) {
									return $.maybeAnnotation;
								},
								A2($author$project$Compiler$ApplyAliases_Test$applyAndGetValue, 'a', '\n                        alias A b = { x : b, y : b }\n                        a : A Bool\n                        a = a\n                        '));
						}
					})
				])),
			A2(
			$author$project$Test$Group,
			'unions',
			_List_fromArray(
				[
					$author$project$Compiler$ApplyAliases_Test$simpleTest(
					{
						expected: $elm$core$Result$Ok(
							A2(
								$elm$core$Dict$singleton,
								'Test.B1',
								_List_fromArray(
									[
										A3(
										$author$project$Types$CanonicalAst$TypeAlias,
										$author$project$Compiler$TestHelpers$p,
										'Test.A',
										A3(
											$author$project$Types$CanonicalAst$TypeConstant,
											$author$project$Compiler$TestHelpers$p,
											'SPCore.List',
											_List_fromArray(
												[
													A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, 'SPCore.Bool', _List_Nil)
												])))
									]))),
						name: 'simple',
						run: function (_v3) {
							return A2(
								$elm$core$Result$map,
								function ($) {
									return $.constructors;
								},
								A3($author$project$Compiler$ApplyAliases_Test$applyAndGet, $author$project$Types$CanonicalAst$asUnion, 'B', '\n                        alias A b c = List b\n                        union B x = B1 (A Bool x)\n                        '));
						}
					})
				]))
		]));
var $author$project$Test$codeTest = F5(
	function (toString, title, code, functionToTest, _v0) {
		var toMaybeError = _v0.a;
		return A2(
			$author$project$Test$Single,
			title + ('\n\n' + code),
			function (_v1) {
				return $author$project$Test$maybeToOutcome(
					A2(
						toMaybeError,
						toString,
						functionToTest(code)));
			});
	});
var $author$project$Compiler$CanonicalToJs_Test$codeTest = $author$project$Test$codeTest($elm$core$Debug$toString);
var $author$project$Compiler$JsToString_Test$eval = F2(
	function (variable, code) {
		return A2(
			$elm$core$Result$andThen,
			function (_v0) {
				var mod = _v0.a;
				var env = _v0.b;
				var sub = _v0.c;
				return A2($author$project$Compiler$JsToString_Test$runProgram, variable, mod);
			},
			$author$project$Compiler$TestHelpers$resErrorToString(
				A2(
					$elm$core$Result$andThen,
					$author$project$Compiler$TypeInference$inspectModule($elm$core$Dict$empty),
					$author$project$Compiler$TestHelpers$stringToCanonicalModuleWithPos(code))));
	});
var $author$project$Test$CodeExpectation = function (a) {
	return {$: 'CodeExpectation', a: a};
};
var $author$project$Test$okEqual = function (expectedOk) {
	return $author$project$Test$CodeExpectation(
		F2(
			function (toString, result) {
				if (result.$ === 'Err') {
					var e = result.a;
					return $elm$core$Maybe$Just(e);
				} else {
					var actualOk = result.a;
					return _Utils_eq(expectedOk, actualOk) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
						A2(
							$elm$core$String$join,
							'\n',
							_List_fromArray(
								[
									'expected = ',
									toString(expectedOk),
									'',
									'actual = ',
									toString(actualOk)
								])));
				}
			}));
};
var $author$project$Compiler$CanonicalToJs_Test$ifs = A2(
	$author$project$Test$Group,
	'ifs',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'basic sanity',
			'\n            a =\n              if True then\n                1\n              else\n                2\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.a'),
			$author$project$Test$okEqual('1'))
		]));
var $author$project$Compiler$CanonicalToJs_Test$misc = A2(
	$author$project$Test$Group,
	'misc',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'definitions and mutations return None',
			'\n            x =\n              m @= 0\n\n            y =\n              m @= 0\n              @m += 1\n\n            a =\n              { x, y }\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.a'),
			$author$project$Test$okEqual('{"x":null,"y":null}'))
		]));
var $author$project$Compiler$CanonicalToJs_Test$mutation = A2(
	$author$project$Test$Group,
	'mutation',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'basic sanity',
			'\n            a =\n              m @= 0\n              @m += 1\n              x = m\n              @m := 10\n              y = m\n              @m += 1\n              z = m\n              { x, y, z, m }\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.a'),
			$author$project$Test$okEqual('{"m":11,"x":1,"y":10,"z":11}')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'nested record',
			'\n            record = { x = { y = { z = 4 } } }\n\n            result =\n               m @= record\n               @m.x.y :=  { z = 1 }\n               @m.x.y.z += 1\n               m\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('{"x":{"y":{"z":2}}}')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'pass mutable to function',
			'\n            fun m =\n              @m += 55\n\n            result =\n               m @= 2\n               fun @m\n               m\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('57')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'pass nested mutable value to function',
			'\n            fun m =\n              @m += 55\n\n            record = { x = { y = { z = 4 } } }\n\n            result =\n               m @= record\n               fun @m.x.y.z\n               m\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('{"x":{"y":{"z":59}}}'))
		]));
var $author$project$Test$errContain = function (subString) {
	return $author$project$Test$CodeExpectation(
		F2(
			function (toString, result) {
				if (result.$ === 'Err') {
					var error = result.a;
					return A2($elm$core$String$contains, subString, error) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
						A2(
							$elm$core$String$join,
							'\n',
							_List_fromArray(
								['error should contain \"' + (subString + '\"'), 'but instead is:', '', error])));
				} else {
					var ok = result.a;
					return $elm$core$Maybe$Just(
						A2(
							$elm$core$String$join,
							'\n',
							_List_fromArray(
								[
									'expecting an error containing \"' + (subString + '\" but instead got Ok!'),
									'',
									toString(ok)
								])));
				}
			}));
};
var $author$project$Compiler$CanonicalToJs_Test$natives = A2(
	$author$project$Test$Group,
	'natives',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'SPCore/Debug.log',
			'\n            result = log "this is produced by a test" True\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('true')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'SPCore/Debug.log, partially applied',
			'\n            result = log "if this gets actually logged, we have a problem"\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('undefined')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'SPCore/Debug.todo',
			'\n            a = todo "blah"\n            result = 1\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$errContain('blah')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'Text concat (..)',
			'\n            result = "a" .. "b" .. "c"\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('\"abc\"')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'add',
			'\n            result = 1 + 2\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('3')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'subtract',
			'\n            result = 5 - 3\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('2')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'multiply',
			'\n            result = 3 * 2\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('6')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'divide',
			'\n            result = 3 / 2\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('1.5')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'divide by zero',
			'\n            result = 3 / 0\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('0')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'lesser than (<)',
			'\n            result = 3 < 2 & 2 < 3\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('{"first":false,"second":true}')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'greater than (>)',
			'\n            result = 3 > 2 & 2 > 3\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('{"first":true,"second":false}')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'partial application',
			'\n            result = (-) 2\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('undefined')),
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'mutable partial application',
			'\n            f = (+=) 3\n\n            result =\n               m @= 1\n               f @m\n               m\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('4'))
		]));
var $author$project$Compiler$CanonicalToJs_Test$try = A2(
	$author$project$Test$Group,
	'try',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$CanonicalToJs_Test$codeTest,
			'basic sanity',
			'\n            union A = A Number, B, C Bool\n\n            a x =\n              try x as\n                A 1 then 11\n                A n then n\n                B then 3\n                C False then 5\n                C _ then 6\n\n            result =\n             { x = a (A 2)\n             , y = a (A 1)\n             , z = a B\n             , w = a (C False)\n             , k = a (C True)\n             }\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.result'),
			$author$project$Test$okEqual('{"k":6,"w":6,"x":2,"y":11,"z":3}'))
		]));
var $author$project$Compiler$CanonicalToJs_Test$tests = A2(
	$author$project$Test$Group,
	'CanonicalToJS',
	_List_fromArray(
		[$author$project$Compiler$CanonicalToJs_Test$misc, $author$project$Compiler$CanonicalToJs_Test$mutation, $author$project$Compiler$CanonicalToJs_Test$ifs, $author$project$Compiler$CanonicalToJs_Test$try, $author$project$Compiler$CanonicalToJs_Test$natives]));
var $author$project$Compiler$FormattableToCanonicalAst_Test$asEvaluation = function (s) {
	if (s.$ === 'Evaluation') {
		var expr = s.a;
		return $elm$core$Maybe$Just(expr);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation = F2(
	function (name, code) {
		return A2(
			$elm$core$Result$andThen,
			A2(
				$elm$core$Basics$composeR,
				$author$project$Compiler$FormattableToCanonicalAst_Test$asEvaluation,
				$elm$core$Result$fromMaybe('asEval fail')),
			A2(
				$elm$core$Result$andThen,
				function (def) {
					return A2(
						$elm$core$Result$fromMaybe,
						'head fail',
						$elm$core$List$head(def.body));
				},
				A2(
					$elm$core$Result$andThen,
					A2(
						$elm$core$Basics$composeR,
						$author$project$Types$CanonicalAst$findValue('Test.' + name),
						$elm$core$Result$fromMaybe('findValue fail')),
					$author$project$Compiler$TestHelpers$resErrorToString(
						$author$project$Compiler$TestHelpers$stringToCanonicalModule(code)))));
	});
var $author$project$Compiler$FormattableToCanonicalAst_Test$hasError = $author$project$Test$hasError($elm$core$Debug$toString);
var $author$project$Compiler$FormattableToCanonicalAst_Test$annotations = A2(
	$author$project$Test$Group,
	'Annotations',
	_List_fromArray(
		[
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'annotation mutability must match definition\'s',
				run: function (_v0) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'a', '\n                    a : Number\n                    a @= 3\n                    ');
				},
				test: $author$project$Test$errorShouldContain('mutability')
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'annotation mutability must match definition\'s',
				run: function (_v1) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'b', '\n                    a : Number\n                    b = 3\n                    ');
				},
				test: $author$project$Test$errorShouldContain('name')
			})
		]));
var $author$project$Compiler$FormattableToCanonicalAst_Test$codeTest = $author$project$Test$codeTest($elm$core$Debug$toString);
var $author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest = $author$project$Test$simple($elm$core$Debug$toString);
var $author$project$Compiler$FormattableToCanonicalAst_Test$binops = A2(
	$author$project$Test$Group,
	'Binops',
	_List_fromArray(
		[
			$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A3(
						$author$project$Types$CanonicalAst$Call,
						$author$project$Compiler$TestHelpers$p,
						A3(
							$author$project$Types$CanonicalAst$Call,
							$author$project$Compiler$TestHelpers$p,
							A2(
								$author$project$Types$CanonicalAst$Variable,
								$author$project$Compiler$TestHelpers$p,
								{attrPath: _List_Nil, isRoot: true, name: '+'}),
							$author$project$Types$CanonicalAst$ArgumentExpression(
								A2(
									$author$project$Types$CanonicalAst$Literal,
									$author$project$Compiler$TestHelpers$p,
									$author$project$Types$Literal$Number('3')))),
						$author$project$Types$CanonicalAst$ArgumentExpression(
							A3(
								$author$project$Types$CanonicalAst$Call,
								$author$project$Compiler$TestHelpers$p,
								A3(
									$author$project$Types$CanonicalAst$Call,
									$author$project$Compiler$TestHelpers$p,
									A2(
										$author$project$Types$CanonicalAst$Variable,
										$author$project$Compiler$TestHelpers$p,
										{attrPath: _List_Nil, isRoot: true, name: '+'}),
									$author$project$Types$CanonicalAst$ArgumentExpression(
										A2(
											$author$project$Types$CanonicalAst$Literal,
											$author$project$Compiler$TestHelpers$p,
											$author$project$Types$Literal$Number('2')))),
								$author$project$Types$CanonicalAst$ArgumentExpression(
									A2(
										$author$project$Types$CanonicalAst$Literal,
										$author$project$Compiler$TestHelpers$p,
										$author$project$Types$Literal$Number('1'))))))),
				name: 'left-association',
				run: function (_v0) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'a', 'a = 1 + 2 + 3');
				}
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A3(
						$author$project$Types$CanonicalAst$Call,
						$author$project$Compiler$TestHelpers$p,
						A3(
							$author$project$Types$CanonicalAst$Call,
							$author$project$Compiler$TestHelpers$p,
							A2(
								$author$project$Types$CanonicalAst$Variable,
								$author$project$Compiler$TestHelpers$p,
								{attrPath: _List_Nil, isRoot: true, name: '+'}),
							$author$project$Types$CanonicalAst$ArgumentExpression(
								A3(
									$author$project$Types$CanonicalAst$Call,
									$author$project$Compiler$TestHelpers$p,
									A3(
										$author$project$Types$CanonicalAst$Call,
										$author$project$Compiler$TestHelpers$p,
										A2(
											$author$project$Types$CanonicalAst$Variable,
											$author$project$Compiler$TestHelpers$p,
											{attrPath: _List_Nil, isRoot: true, name: '*'}),
										$author$project$Types$CanonicalAst$ArgumentExpression(
											A2(
												$author$project$Types$CanonicalAst$Literal,
												$author$project$Compiler$TestHelpers$p,
												$author$project$Types$Literal$Number('3')))),
									$author$project$Types$CanonicalAst$ArgumentExpression(
										A2(
											$author$project$Types$CanonicalAst$Literal,
											$author$project$Compiler$TestHelpers$p,
											$author$project$Types$Literal$Number('2')))))),
						$author$project$Types$CanonicalAst$ArgumentExpression(
							A2(
								$author$project$Types$CanonicalAst$Literal,
								$author$project$Compiler$TestHelpers$p,
								$author$project$Types$Literal$Number('1'))))),
				name: 'precedence',
				run: function (_v1) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'a', 'a = 1 + 2 * 3');
				}
			}),
			A4(
			$author$project$Compiler$FormattableToCanonicalAst_Test$codeTest,
			'functional notation',
			'\n            a = (-)\n            ',
			$author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation('a'),
			$author$project$Test$okEqual(
				A2(
					$author$project$Types$CanonicalAst$Variable,
					$author$project$Compiler$TestHelpers$p,
					{attrPath: _List_Nil, isRoot: true, name: '-'})))
		]));
var $author$project$Test$freeform = function (test) {
	return $author$project$Test$CodeExpectation(
		F2(
			function (toString, result) {
				if (result.$ === 'Err') {
					var e = result.a;
					return $elm$core$Maybe$Just(e);
				} else {
					var actualOk = result.a;
					return test(actualOk);
				}
			}));
};
var $author$project$Test$justOk = $author$project$Test$CodeExpectation(
	F2(
		function (toString, result) {
			if (result.$ === 'Err') {
				var e = result.a;
				return $elm$core$Maybe$Just(e);
			} else {
				var actualOk = result.a;
				return $elm$core$Maybe$Nothing;
			}
		}));
var $elm$core$Maybe$map3 = F4(
	function (func, ma, mb, mc) {
		if (ma.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var a = ma.a;
			if (mb.$ === 'Nothing') {
				return $elm$core$Maybe$Nothing;
			} else {
				var b = mb.a;
				if (mc.$ === 'Nothing') {
					return $elm$core$Maybe$Nothing;
				} else {
					var c = mc.a;
					return $elm$core$Maybe$Just(
						A3(func, a, b, c));
				}
			}
		}
	});
var $author$project$Compiler$FormattableToCanonicalAst_Test$functions = A2(
	$author$project$Test$Group,
	'Functions',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$FormattableToCanonicalAst_Test$codeTest,
			'[rec] lambda with two arguments',
			'\n            f =\n              fn a b = 1\n            ',
			$author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation('f'),
			$author$project$Test$justOk),
			function () {
			var findABC = function (mod) {
				return A4(
					$elm$core$Maybe$map3,
					F3(
						function (a, b, c) {
							return _Utils_Tuple3(a, b, c);
						}),
					A2($author$project$Types$CanonicalAst$findValue, 'Test.a', mod),
					A2($author$project$Types$CanonicalAst$findValue, 'Test.b', mod),
					A2($author$project$Types$CanonicalAst$findValue, 'Test.c', mod));
			};
			var transform = function (code) {
				return A2(
					$elm$core$Result$andThen,
					A2(
						$elm$core$Basics$composeR,
						findABC,
						$elm$core$Result$fromMaybe('findABC fail')),
					$author$project$Compiler$TestHelpers$resErrorToString(
						$author$project$Compiler$TestHelpers$stringToCanonicalModule(code)));
			};
			return A4(
				$author$project$Compiler$FormattableToCanonicalAst_Test$codeTest,
				'short function notation',
				'\n            a x y z = x + y + z\n            b = fn x y z = x + y + z\n            c = fn x = fn y = fn z = x + y + z\n            ',
				transform,
				$author$project$Test$freeform(
					function (_v0) {
						var a = _v0.a;
						var b = _v0.b;
						var c = _v0.c;
						return (_Utils_eq(a.body, b.body) && _Utils_eq(b.body, c.body)) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
							A2(
								$elm$core$String$join,
								'\n',
								_List_fromArray(
									[
										'The three don\'t match:',
										$elm$core$Debug$toString(a),
										$elm$core$Debug$toString(b),
										$elm$core$Debug$toString(c)
									])));
					}));
		}()
		]));
var $author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition = F2(
	function (name, code) {
		return A2(
			$elm$core$Result$andThen,
			A2(
				$elm$core$Basics$composeR,
				$author$project$Types$CanonicalAst$findValue('Test.' + name),
				$elm$core$Result$fromMaybe('Dict fail')),
			$author$project$Compiler$TestHelpers$resErrorToString(
				$author$project$Compiler$TestHelpers$stringToCanonicalModule(code)));
	});
var $author$project$Compiler$FormattableToCanonicalAst_Test$lists = A2(
	$author$project$Test$Group,
	'Lists',
	_List_fromArray(
		[
			$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						body: _List_fromArray(
							[
								$author$project$Types$CanonicalAst$Evaluation(
								A2(
									$author$project$Types$CanonicalAst$Variable,
									$author$project$Compiler$TestHelpers$p,
									{attrPath: _List_Nil, isRoot: true, name: 'Test.l'}))
							]),
						maybeAnnotation: $elm$core$Maybe$Just(
							A3(
								$author$project$Types$CanonicalAst$TypeConstant,
								$author$project$Compiler$TestHelpers$p,
								'SPCore.List',
								_List_fromArray(
									[
										A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, 'SPCore.Bool', _List_Nil)
									]))),
						mutable: false,
						pattern: A2($author$project$Types$CanonicalAst$PatternAny, $author$project$Compiler$TestHelpers$p, 'Test.l')
					}),
				name: 'list type sugar',
				run: function (_v0) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition, 'l', '\n                        l : [ SPCore.Bool ]\n                        l = l\n                        ');
				}
			})
		]));
var $author$project$Test$isOk = F2(
	function (toString, _v0) {
		var name = _v0.name;
		var run = _v0.run;
		return A2(
			$author$project$Test$Single,
			name,
			function (_v1) {
				var _v2 = run(name);
				if (_v2.$ === 'Ok') {
					return $author$project$Test$Success;
				} else {
					var e = _v2.a;
					return $author$project$Test$Error(
						toString(e));
				}
			});
	});
var $author$project$Compiler$FormattableToCanonicalAst_Test$isOk = $author$project$Test$isOk($elm$core$Debug$toString);
var $author$project$Compiler$FormattableToCanonicalAst_Test$moduleAndAttributePaths = function () {
	var reject = F2(
		function (s, m) {
			return $author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
				{
					name: s,
					run: function (_v1) {
						return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition, 'a', 'a = ' + s);
					},
					test: $author$project$Test$errorShouldContain(m)
				});
		});
	var accept = function (s) {
		return $author$project$Compiler$FormattableToCanonicalAst_Test$isOk(
			{
				name: s,
				run: function (_v0) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition, 'a', 'a = ' + s);
				}
			});
	};
	return A2(
		$author$project$Test$Group,
		'Module and Attribute Paths',
		_List_fromArray(
			[
				accept('blah.blah.blah'),
				A2(reject, 'Blah.Blah.blah', 'Constructor'),
				A2(reject, 'blah.Blah.blah', 'lower'),
				A2(reject, 'Blah.blah.Blah', 'lower'),
				A2(reject, 'Blah..blah', 'dot'),
				A2(reject, '.Blah', 'shorthand'),
				A2(reject, '.blah.blah', 'shorthand'),
				A2(reject, '.blah', 'shorthand'),
				A2(reject, '...', ''),
				accept('x .. y')
			]));
}();
var $author$project$Compiler$FormattableToCanonicalAst_Test$patterns = A2(
	$author$project$Test$Group,
	'Patterns',
	_List_fromArray(
		[
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'can\'t declare functions inside patterns ',
				run: function (_v0) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'x', '\n                    x =\n                      c (a b) = 2\n                    ');
				},
				test: $author$project$Test$errorShouldContain('function')
			}),
			A4(
			$author$project$Compiler$FormattableToCanonicalAst_Test$codeTest,
			'[reg] record patterns are NOT extensible',
			'\n            a =\n              { b with c } = d\n            ',
			$author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation('a'),
			$author$project$Test$errContain('with'))
		]));
var $author$project$Compiler$FormattableToCanonicalAst_Test$pipes = A2(
	$author$project$Test$Group,
	'Pipes',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$FormattableToCanonicalAst_Test$codeTest,
			'sendLeft is inlined',
			'\n            a = thing >> function\n            ',
			$author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation('a'),
			$author$project$Test$okEqual(
				A3(
					$author$project$Types$CanonicalAst$Call,
					$author$project$Compiler$TestHelpers$p,
					A2(
						$author$project$Types$CanonicalAst$Variable,
						$author$project$Compiler$TestHelpers$p,
						{attrPath: _List_Nil, isRoot: true, name: 'Test.function'}),
					$author$project$Types$CanonicalAst$ArgumentExpression(
						A2(
							$author$project$Types$CanonicalAst$Variable,
							$author$project$Compiler$TestHelpers$p,
							{attrPath: _List_Nil, isRoot: true, name: 'Test.thing'}))))),
			A4(
			$author$project$Compiler$FormattableToCanonicalAst_Test$codeTest,
			'sendRight is inlined',
			'\n            a = function << thing\n            ',
			$author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation('a'),
			$author$project$Test$okEqual(
				A3(
					$author$project$Types$CanonicalAst$Call,
					$author$project$Compiler$TestHelpers$p,
					A2(
						$author$project$Types$CanonicalAst$Variable,
						$author$project$Compiler$TestHelpers$p,
						{attrPath: _List_Nil, isRoot: true, name: 'Test.function'}),
					$author$project$Types$CanonicalAst$ArgumentExpression(
						A2(
							$author$project$Types$CanonicalAst$Variable,
							$author$project$Compiler$TestHelpers$p,
							{attrPath: _List_Nil, isRoot: true, name: 'Test.thing'})))))
		]));
var $author$project$Compiler$FormattableToCanonicalAst_Test$records = function () {
	var reject = F2(
		function (s, m) {
			return $author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
				{
					name: s,
					run: function (_v3) {
						return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition, 'a', 'a = ' + s);
					},
					test: $author$project$Test$errorShouldContain(m)
				});
		});
	var accept = function (s) {
		return $author$project$Compiler$FormattableToCanonicalAst_Test$isOk(
			{
				name: s,
				run: function (_v2) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition, 'a', 'a = ' + s);
				}
			});
	};
	return A2(
		$author$project$Test$Group,
		'Records',
		_List_fromArray(
			[
				$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
				{
					expected: $elm$core$Result$Ok(
						A3(
							$author$project$Types$CanonicalAst$Record,
							$author$project$Compiler$TestHelpers$p,
							$elm$core$Maybe$Just(
								{attrPath: _List_Nil, isRoot: true, name: 'Test.m'}),
							$elm$core$Dict$fromList(
								_List_fromArray(
									[
										_Utils_Tuple2(
										'c',
										A2(
											$author$project$Types$CanonicalAst$Literal,
											$author$project$Compiler$TestHelpers$p,
											$author$project$Types$Literal$Number('1'))),
										_Utils_Tuple2(
										'b',
										A2(
											$author$project$Types$CanonicalAst$Variable,
											$author$project$Compiler$TestHelpers$p,
											{attrPath: _List_Nil, isRoot: true, name: 'Test.b'}))
									])))),
					name: 'functional update',
					run: function (_v0) {
						return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'a', 'a = { m with b, c = 1 }');
					}
				}),
				$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
				{
					expected: $elm$core$Result$Ok(
						A3(
							$author$project$Types$CanonicalAst$Record,
							$author$project$Compiler$TestHelpers$p,
							$elm$core$Maybe$Just(
								{
									attrPath: _List_fromArray(
										['k']),
									isRoot: true,
									name: 'Test.a'
								}),
							A2(
								$elm$core$Dict$singleton,
								'y',
								A2(
									$author$project$Types$CanonicalAst$Variable,
									$author$project$Compiler$TestHelpers$p,
									{
										attrPath: _List_fromArray(
											['k', 'x']),
										isRoot: true,
										name: 'Test.a'
									})))),
					name: 'update shorthand',
					run: function (_v1) {
						return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'b', 'b = { a.k with y = .x }');
					}
				}),
				A4(
				$author$project$Compiler$FormattableToCanonicalAst_Test$codeTest,
				'annotation, extensible',
				'\n            a : { b with x : Bool }\n            a = a\n            ',
				$author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation('a'),
				$author$project$Test$errContain('disabled'))
			]));
}();
var $author$project$Compiler$FormattableToCanonicalAst_Test$tuples = A2(
	$author$project$Test$Group,
	'Tuples',
	_List_fromArray(
		[
			$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A3(
						$author$project$Types$CanonicalAst$Record,
						$author$project$Compiler$TestHelpers$p,
						$elm$core$Maybe$Nothing,
						$elm$core$Dict$fromList(
							_List_fromArray(
								[
									_Utils_Tuple2(
									'first',
									A2(
										$author$project$Types$CanonicalAst$Literal,
										$author$project$Compiler$TestHelpers$p,
										$author$project$Types$Literal$Number('1'))),
									_Utils_Tuple2(
									'second',
									A2(
										$author$project$Types$CanonicalAst$Literal,
										$author$project$Compiler$TestHelpers$p,
										$author$project$Types$Literal$Number('2')))
								])))),
				name: 'tuple2',
				run: function (_v0) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'a', 'a = 1 & 2');
				}
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A3(
						$author$project$Types$CanonicalAst$Record,
						$author$project$Compiler$TestHelpers$p,
						$elm$core$Maybe$Nothing,
						$elm$core$Dict$fromList(
							_List_fromArray(
								[
									_Utils_Tuple2(
									'first',
									A2(
										$author$project$Types$CanonicalAst$Literal,
										$author$project$Compiler$TestHelpers$p,
										$author$project$Types$Literal$Number('1'))),
									_Utils_Tuple2(
									'second',
									A2(
										$author$project$Types$CanonicalAst$Literal,
										$author$project$Compiler$TestHelpers$p,
										$author$project$Types$Literal$Number('2'))),
									_Utils_Tuple2(
									'third',
									A2(
										$author$project$Types$CanonicalAst$Literal,
										$author$project$Compiler$TestHelpers$p,
										$author$project$Types$Literal$Number('3')))
								])))),
				name: 'tuple3',
				run: function (_v1) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'a', 'a = 1 & 2 & 3');
				}
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'tuple4',
				run: function (_v2) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstEvaluation, 'a', 'a = 1 & 2 & 3 & 4');
				},
				test: $author$project$Test$errorShouldContain('use a record')
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						body: _List_fromArray(
							[
								$author$project$Types$CanonicalAst$Evaluation(
								A2(
									$author$project$Types$CanonicalAst$Variable,
									$author$project$Compiler$TestHelpers$p,
									{attrPath: _List_Nil, isRoot: true, name: 'Test.a'}))
							]),
						maybeAnnotation: $elm$core$Maybe$Just(
							A3(
								$author$project$Types$CanonicalAst$TypeRecord,
								$author$project$Compiler$TestHelpers$p,
								$elm$core$Maybe$Nothing,
								$elm$core$Dict$fromList(
									_List_fromArray(
										[
											_Utils_Tuple2(
											'first',
											A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, 'Test.Blah', _List_Nil)),
											_Utils_Tuple2(
											'second',
											A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, 'Test.Blah', _List_Nil))
										])))),
						mutable: false,
						pattern: A2($author$project$Types$CanonicalAst$PatternAny, $author$project$Compiler$TestHelpers$p, 'Test.a')
					}),
				name: 'tuple2 type',
				run: function (_v3) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition, 'a', '\n                        a : Blah & Blah\n                        a = a\n                        ');
				}
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'tuple4, type',
				run: function (_v4) {
					return A2($author$project$Compiler$FormattableToCanonicalAst_Test$firstDefinition, 'a', '\n                        a : Blah & Blah & Blah & Blah\n                        a = a\n                        ');
				},
				test: $author$project$Test$errorShouldContain('Use a record')
			})
		]));
var $author$project$Compiler$FormattableToCanonicalAst_Test$stringToCanonicalModule = function (code) {
	return $author$project$Compiler$TestHelpers$resErrorToString(
		$author$project$Compiler$TestHelpers$stringToCanonicalModule(code));
};
var $author$project$Compiler$FormattableToCanonicalAst_Test$unionTypes = A2(
	$author$project$Test$Group,
	'unionTypes',
	_List_fromArray(
		[
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'name starts with uppercase',
				run: function (_v0) {
					return $author$project$Compiler$FormattableToCanonicalAst_Test$stringToCanonicalModule('union a = A');
				},
				test: $author$project$Test$errorShouldContain('uppercase')
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'constructor names start with uppercase',
				run: function (_v1) {
					return $author$project$Compiler$FormattableToCanonicalAst_Test$stringToCanonicalModule('union A = a');
				},
				test: $author$project$Test$errorShouldContain('constructor')
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$hasError(
			{
				name: 'tuples op precedence',
				run: function (_v2) {
					return $author$project$Compiler$FormattableToCanonicalAst_Test$stringToCanonicalModule('union A = X Bool & Bool');
				},
				test: $author$project$Test$errorShouldContain('operators')
			}),
			$author$project$Compiler$FormattableToCanonicalAst_Test$isOk(
			{
				name: 'tuples op precedence works with parens',
				run: function (_v3) {
					return $author$project$Compiler$FormattableToCanonicalAst_Test$stringToCanonicalModule('union A = X (Bool & Bool)');
				}
			})
		]));
var $author$project$Compiler$FormattableToCanonicalAst_Test$tests = A2(
	$author$project$Test$Group,
	'FormattableToCanonicalAst',
	_List_fromArray(
		[$author$project$Compiler$FormattableToCanonicalAst_Test$unionTypes, $author$project$Compiler$FormattableToCanonicalAst_Test$binops, $author$project$Compiler$FormattableToCanonicalAst_Test$tuples, $author$project$Compiler$FormattableToCanonicalAst_Test$lists, $author$project$Compiler$FormattableToCanonicalAst_Test$moduleAndAttributePaths, $author$project$Compiler$FormattableToCanonicalAst_Test$records, $author$project$Compiler$FormattableToCanonicalAst_Test$patterns, $author$project$Compiler$FormattableToCanonicalAst_Test$annotations, $author$project$Compiler$FormattableToCanonicalAst_Test$pipes, $author$project$Compiler$FormattableToCanonicalAst_Test$functions]));
var $author$project$Compiler$JsToString_Test$codeTest = $author$project$Test$codeTest($elm$core$Debug$toString);
var $author$project$Compiler$JsToString_Test$self = A2(
	$author$project$Test$Group,
	'Markdown.eval workaround itself works',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$JsToString_Test$codeTest,
			'base',
			'\n            x = 1 + 1\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.x'),
			$author$project$Test$okEqual('2')),
			A4(
			$author$project$Compiler$JsToString_Test$codeTest,
			'None is null',
			'\n            x = None\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.x'),
			$author$project$Test$okEqual('null')),
			A4(
			$author$project$Compiler$JsToString_Test$codeTest,
			'undefined reference',
			'\n            x = None\n            ',
			$author$project$Compiler$JsToString_Test$eval('Test.y'),
			$author$project$Test$errContain('not defined'))
		]));
var $author$project$Compiler$JsToString_Test$tests = A2(
	$author$project$Test$Group,
	'JsToString',
	_List_fromArray(
		[$author$project$Compiler$JsToString_Test$self]));
var $author$project$Compiler$StringToTokens_Test$lexTokens = F2(
	function (s, _v0) {
		return $author$project$Compiler$StringToTokens$lexer(s);
	});
var $author$project$Compiler$StringToTokens_Test$non_mut_name = $author$project$Types$Token$Name(
	{mutable: false});
var $author$project$Compiler$StringToTokens_Test$simpleTest = $author$project$Test$simple($elm$core$Debug$toString);
var $author$project$Compiler$StringToTokens_Test$comments = A2(
	$author$project$Test$Group,
	'Comments',
	_List_fromArray(
		[
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 2, kind: $author$project$Types$Token$Comment, start: 1},
							{end: 3, kind: $author$project$Types$Token$NewSiblingLine, start: 3},
							{
							end: 4,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 3
						},
							{
							end: 6,
							kind: $author$project$Types$Token$Defop(
								{mutable: false}),
							start: 5
						},
							{
							end: 8,
							kind: $author$project$Types$Token$NumberLiteral('1'),
							start: 7
						}
						])),
				name: '[reg] statement after comment',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('\n#\na = 1\n                ')
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 7, kind: $author$project$Types$Token$Comment, start: 0}
						])),
				name: 'Single line',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('# hello')
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 18, kind: $author$project$Types$Token$Comment, start: 1},
							{end: 20, kind: $author$project$Types$Token$NewSiblingLine, start: 20},
							{
							end: 21,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 20
						},
							{end: 34, kind: $author$project$Types$Token$Comment, start: 22},
							{
							end: 36,
							kind: $author$project$Types$Token$Defop(
								{mutable: false}),
							start: 35
						},
							{
							end: 38,
							kind: $author$project$Types$Token$NumberLiteral('1'),
							start: 37
						},
							{end: 60, kind: $author$project$Types$Token$Comment, start: 40},
							{end: 79, kind: $author$project$Types$Token$Comment, start: 62}
						])),
				name: 'Multi line',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('\n[# single line #]\n\na [# inline #] = 1\n\n[#\n    multi line\n#]\n\n[# [# nested #] #]\n')
			})
		]));
var $author$project$Compiler$StringToTokens_Test$indentation = A2(
	$author$project$Test$Group,
	'Blocks, sibling lines, indentation',
	_List_fromArray(
		[
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 1, kind: $author$project$Types$Token$NewSiblingLine, start: 1},
							{
							end: 2,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 1
						},
							{
							end: 4,
							kind: $author$project$Types$Token$Defop(
								{mutable: false}),
							start: 3
						},
							{end: 6, kind: $author$project$Types$Token$BlockStart, start: 5},
							{
							end: 7,
							kind: $author$project$Types$Token$NumberLiteral('1'),
							start: 6
						},
							{end: 8, kind: $author$project$Types$Token$BlockEnd, start: 8},
							{end: 8, kind: $author$project$Types$Token$NewSiblingLine, start: 8},
							{
							end: 9,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('b'),
							start: 8
						},
							{
							end: 11,
							kind: $author$project$Types$Token$Defop(
								{mutable: false}),
							start: 10
						},
							{
							end: 13,
							kind: $author$project$Types$Token$NumberLiteral('1'),
							start: 12
						}
						])),
				name: '1',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('\na =\n 1\nb = 1\n')
			})
		]));
var $author$project$Compiler$StringToTokens_Test$keywords = A2(
	$author$project$Test$Group,
	'keywords',
	_List_fromArray(
		[
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 0, kind: $author$project$Types$Token$NewSiblingLine, start: 0},
							{end: 2, kind: $author$project$Types$Token$Fn, start: 0},
							{
							end: 4,
							kind: $author$project$Types$Token$Defop(
								{mutable: false}),
							start: 3
						},
							{
							end: 6,
							kind: $author$project$Types$Token$NumberLiteral('1'),
							start: 5
						}
						])),
				name: '[reg] `fn` is a keyword',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('fn = 1')
			})
		]));
var $author$project$Compiler$StringToTokens_Test$unaryAddittiveOps = A2(
	$author$project$Test$Group,
	'Unary addittive ops',
	_List_fromArray(
		[
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 1, kind: $author$project$Types$Token$BlockStart, start: 0},
							{
							end: 2,
							kind: $author$project$Types$Token$Unop('-'),
							start: 1
						},
							{
							end: 3,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 2
						},
							{end: 3, kind: $author$project$Types$Token$BlockEnd, start: 3}
						])),
				name: 'Unary +/-: -a',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens(' -a')
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 0, kind: $author$project$Types$Token$NewSiblingLine, start: 0},
							{
							end: 1,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 0
						},
							{
							end: 3,
							kind: A2($author$project$Types$Token$Binop, $author$project$Types$Token$Addittive, '-'),
							start: 2
						},
							{
							end: 5,
							kind: $author$project$Types$Token$Unop('-'),
							start: 4
						},
							{
							end: 6,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 5
						}
						])),
				name: 'Unary +/-: a - -a',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('a - -a')
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 0, kind: $author$project$Types$Token$NewSiblingLine, start: 0},
							{
							end: 1,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 0
						},
							{
							end: 2,
							kind: A2($author$project$Types$Token$Binop, $author$project$Types$Token$Addittive, '-'),
							start: 1
						},
							{
							end: 3,
							kind: $author$project$Compiler$StringToTokens_Test$non_mut_name('a'),
							start: 2
						}
						])),
				name: 'Unary +/-: a-a',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('a-a')
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 0, kind: $author$project$Types$Token$NewSiblingLine, start: 0},
							{
							end: 2,
							kind: $author$project$Types$Token$Arrow(
								{mutable: false}),
							start: 0
						}
						])),
				name: 'Arrow ->',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('->')
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{end: 0, kind: $author$project$Types$Token$NewSiblingLine, start: 0},
							{
							end: 2,
							kind: A2($author$project$Types$Token$Binop, $author$project$Types$Token$Mutop, '-='),
							start: 0
						}
						])),
				name: '-=',
				run: $author$project$Compiler$StringToTokens_Test$lexTokens('-=')
			})
		]));
var $author$project$Compiler$StringToTokens_Test$underscores = A2(
	$author$project$Test$Group,
	'Underscores',
	_List_fromArray(
		[
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{
							end: 1,
							kind: A2(
								$author$project$Types$Token$Name,
								{mutable: false},
								'_'),
							start: 0
						}
						])),
				name: '\'_\' is a Name',
				run: A2(
					$elm$core$Basics$composeR,
					$author$project$Compiler$StringToTokens_Test$lexTokens('_'),
					$elm$core$Result$map(
						$elm$core$List$drop(1)))
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{
							end: 6,
							kind: A2(
								$author$project$Types$Token$Name,
								{mutable: false},
								'_10_20'),
							start: 0
						}
						])),
				name: '\'_10_20\' is a Name',
				run: A2(
					$elm$core$Basics$composeR,
					$author$project$Compiler$StringToTokens_Test$lexTokens('_10_20'),
					$elm$core$Result$map(
						$elm$core$List$drop(1)))
			}),
			$author$project$Compiler$StringToTokens_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					_List_fromArray(
						[
							{
							end: 5,
							kind: $author$project$Types$Token$NumberLiteral('10_20'),
							start: 0
						}
						])),
				name: '\'10_20\' is a Number',
				run: A2(
					$elm$core$Basics$composeR,
					$author$project$Compiler$StringToTokens_Test$lexTokens('10_20'),
					$elm$core$Result$map(
						$elm$core$List$drop(1)))
			})
		]));
var $author$project$Compiler$StringToTokens_Test$tests = A2(
	$author$project$Test$Group,
	'StringToTokens',
	_List_fromArray(
		[$author$project$Compiler$StringToTokens_Test$keywords, $author$project$Compiler$StringToTokens_Test$unaryAddittiveOps, $author$project$Compiler$StringToTokens_Test$indentation, $author$project$Compiler$StringToTokens_Test$comments, $author$project$Compiler$StringToTokens_Test$underscores]));
var $author$project$Compiler$TokensToFormattableAst_Test$asDefinition = function (s) {
	if (s.$ === 'Definition') {
		var a = s.a;
		return $elm$core$Result$Ok(a);
	} else {
		return $elm$core$Result$Err('no def');
	}
};
var $author$project$Compiler$TokensToFormattableAst_Test$p = _Utils_Tuple2(-1, -1);
var $author$project$Compiler$TokensToFormattableAst_Test$applyDummyPos = $elm$core$Basics$always($author$project$Compiler$TokensToFormattableAst_Test$p);
var $elm$core$Tuple$mapBoth = F3(
	function (funcA, funcB, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			funcA(x),
			funcB(y));
	});
var $author$project$SepList$mapItem = F2(
	function (f, _v0) {
		var a = _v0.a;
		var la = _v0.b;
		return _Utils_Tuple2(
			f(a),
			A2(
				$elm$core$List$map,
				$elm$core$Tuple$mapSecond(f),
				la));
	});
var $author$project$Types$FormattableAst$PatternCons = F3(
	function (a, b, c) {
		return {$: 'PatternCons', a: a, b: b, c: c};
	});
var $author$project$Types$FormattableAst$PatternTuple = F2(
	function (a, b) {
		return {$: 'PatternTuple', a: a, b: b};
	});
var $author$project$Types$FormattableAst$recordArgs_map = F2(
	function (f, ar) {
		return {
			attrs: A2(
				$elm$core$List$map,
				$elm$core$Tuple$mapSecond(
					$elm$core$Maybe$map(f)),
				ar.attrs),
			_extends: A2($elm$core$Maybe$map, f, ar._extends)
		};
	});
var $author$project$Types$FormattableAst$posMap_pattern = F2(
	function (f, pa) {
		switch (pa.$) {
			case 'PatternAny':
				var pos = pa.a;
				var name = pa.b;
				return A2(
					$author$project$Types$FormattableAst$PatternAny,
					f(pos),
					name);
			case 'PatternLiteral':
				var pos = pa.a;
				var val = pa.b;
				return A2(
					$author$project$Types$FormattableAst$PatternLiteral,
					f(pos),
					val);
			case 'PatternApplication':
				var pos = pa.a;
				var cons = pa.b;
				var pas = pa.c;
				return A3(
					$author$project$Types$FormattableAst$PatternApplication,
					f(pos),
					cons,
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_pattern(f),
						pas));
			case 'PatternList':
				var pos = pa.a;
				var pas = pa.b;
				return A2(
					$author$project$Types$FormattableAst$PatternList,
					f(pos),
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_pattern(f),
						pas));
			case 'PatternRecord':
				var pos = pa.a;
				var ar = pa.b;
				return A2(
					$author$project$Types$FormattableAst$PatternRecord,
					f(pos),
					A2(
						$author$project$Types$FormattableAst$recordArgs_map,
						$author$project$Types$FormattableAst$posMap_pattern(f),
						ar));
			case 'PatternCons':
				var pos = pa.a;
				var left = pa.b;
				var right = pa.c;
				return A3(
					$author$project$Types$FormattableAst$PatternCons,
					f(pos),
					A2($author$project$Types$FormattableAst$posMap_pattern, f, left),
					A2($author$project$Types$FormattableAst$posMap_pattern, f, right));
			default:
				var pos = pa.a;
				var pas = pa.b;
				return A2(
					$author$project$Types$FormattableAst$PatternTuple,
					f(pos),
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_pattern(f),
						pas));
		}
	});
var $author$project$Types$FormattableAst$posMap_type = F2(
	function (f, ty) {
		switch (ty.$) {
			case 'TypeName':
				var pos = ty.a;
				var name = ty.b;
				return A2(
					$author$project$Types$FormattableAst$TypeName,
					f(pos),
					name);
			case 'TypePolymorphic':
				var pos = ty.a;
				var name = ty.b;
				var args = ty.c;
				return A3(
					$author$project$Types$FormattableAst$TypePolymorphic,
					f(pos),
					name,
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_type(f),
						args));
			case 'TypeFunction':
				var pos = ty.a;
				var from = ty.b;
				var mut = ty.c;
				var to = ty.d;
				return A4(
					$author$project$Types$FormattableAst$TypeFunction,
					f(pos),
					A2($author$project$Types$FormattableAst$posMap_type, f, from),
					mut,
					A2($author$project$Types$FormattableAst$posMap_type, f, to));
			case 'TypeTuple':
				var pos = ty.a;
				var tys = ty.b;
				return A2(
					$author$project$Types$FormattableAst$TypeTuple,
					f(pos),
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_type(f),
						tys));
			default:
				var pos = ty.a;
				var ar = ty.b;
				return A2(
					$author$project$Types$FormattableAst$TypeRecord,
					f(pos),
					A2(
						$author$project$Types$FormattableAst$recordArgs_map,
						$author$project$Types$FormattableAst$posMap_type(f),
						ar));
		}
	});
var $author$project$Types$FormattableAst$posMap_expression = F2(
	function (f, expr) {
		switch (expr.$) {
			case 'Literal':
				var pos = expr.a;
				var value = expr.b;
				return A2(
					$author$project$Types$FormattableAst$Literal,
					f(pos),
					value);
			case 'Variable':
				var pos = expr.a;
				var isbin = expr.b;
				var name = expr.c;
				return A3(
					$author$project$Types$FormattableAst$Variable,
					f(pos),
					isbin,
					name);
			case 'Mutable':
				var pos = expr.a;
				var name = expr.b;
				return A2(
					$author$project$Types$FormattableAst$Mutable,
					f(pos),
					name);
			case 'Lambda':
				var pos = expr.a;
				var pas = expr.b;
				var stats = expr.c;
				return A3(
					$author$project$Types$FormattableAst$Lambda,
					f(pos),
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_pattern(f),
						pas),
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_statement(f),
						stats));
			case 'FunctionCall':
				var pos = expr.a;
				var ref = expr.b;
				var args = expr.c;
				return A3(
					$author$project$Types$FormattableAst$FunctionCall,
					f(pos),
					A2($author$project$Types$FormattableAst$posMap_expression, f, ref),
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_expression(f),
						args));
			case 'Binop':
				var pos = expr.a;
				var group = expr.b;
				var sepList = expr.c;
				return A3(
					$author$project$Types$FormattableAst$Binop,
					f(pos),
					group,
					A2(
						$author$project$SepList$mapItem,
						$author$project$Types$FormattableAst$posMap_expression(f),
						sepList));
			case 'Unop':
				var pos = expr.a;
				var name = expr.b;
				var right = expr.c;
				return A3(
					$author$project$Types$FormattableAst$Unop,
					f(pos),
					name,
					A2($author$project$Types$FormattableAst$posMap_expression, f, right));
			case 'If':
				var pos = expr.a;
				var ar = expr.b;
				return A2(
					$author$project$Types$FormattableAst$If,
					f(pos),
					{
						condition: A2($author$project$Types$FormattableAst$posMap_expression, f, ar.condition),
						_false: A2(
							$elm$core$List$map,
							$author$project$Types$FormattableAst$posMap_statement(f),
							ar._false),
						isOneLine: ar.isOneLine,
						_true: A2(
							$elm$core$List$map,
							$author$project$Types$FormattableAst$posMap_statement(f),
							ar._true)
					});
			case 'Try':
				var pos = expr.a;
				var ar = expr.b;
				return A2(
					$author$project$Types$FormattableAst$Try,
					f(pos),
					{
						isOneLine: ar.isOneLine,
						maybeElse: A2(
							$elm$core$Maybe$map,
							$elm$core$List$map(
								$author$project$Types$FormattableAst$posMap_statement(f)),
							ar.maybeElse),
						patterns: A2(
							$elm$core$List$map,
							A2(
								$elm$core$Tuple$mapBoth,
								$author$project$Types$FormattableAst$posMap_pattern(f),
								$elm$core$List$map(
									$author$project$Types$FormattableAst$posMap_statement(f))),
							ar.patterns),
						value: A2($author$project$Types$FormattableAst$posMap_expression, f, ar.value)
					});
			case 'Record':
				var pos = expr.a;
				var ar = expr.b;
				return A2(
					$author$project$Types$FormattableAst$Record,
					f(pos),
					A2(
						$author$project$Types$FormattableAst$recordArgs_map,
						$author$project$Types$FormattableAst$posMap_expression(f),
						ar));
			default:
				var pos = expr.a;
				var exs = expr.b;
				return A2(
					$author$project$Types$FormattableAst$List,
					f(pos),
					A2(
						$elm$core$List$map,
						$author$project$Types$FormattableAst$posMap_expression(f),
						exs));
		}
	});
var $author$project$Types$FormattableAst$posMap_statement = F2(
	function (f, stat) {
		switch (stat.$) {
			case 'Evaluation':
				var e = stat.a;
				return $author$project$Types$FormattableAst$Evaluation(
					A2($author$project$Types$FormattableAst$posMap_expression, f, e));
			case 'Definition':
				var def = stat.a;
				return $author$project$Types$FormattableAst$Definition(
					{
						body: A2(
							$elm$core$List$map,
							$author$project$Types$FormattableAst$posMap_statement(f),
							def.body),
						maybeAnnotation: A2(
							$elm$core$Maybe$map,
							function (ann) {
								return _Utils_update(
									ann,
									{
										ty: A2($author$project$Types$FormattableAst$posMap_type, f, ann.ty)
									});
							},
							def.maybeAnnotation),
						mutable: def.mutable,
						pattern: A2($author$project$Types$FormattableAst$posMap_pattern, f, def.pattern),
						pos: f(def.pos)
					});
			case 'TypeAlias':
				var ar = stat.a;
				return $author$project$Types$FormattableAst$TypeAlias(
					{
						args: ar.args,
						name: ar.name,
						ty: A2($author$project$Types$FormattableAst$posMap_type, f, ar.ty)
					});
			default:
				var ar = stat.a;
				return $author$project$Types$FormattableAst$UnionDef(
					{
						args: ar.args,
						constructors: A2(
							$elm$core$List$map,
							$author$project$Types$FormattableAst$posMap_type(f),
							ar.constructors),
						name: ar.name
					});
		}
	});
var $author$project$Compiler$TestHelpers$stringToFormattableModule = function (code) {
	return A2(
		$author$project$Compiler$Pipeline$stringToFormattableAst,
		$author$project$Compiler$TestHelpers$moduleName,
		$author$project$Compiler$TestHelpers$unindent(code));
};
var $author$project$Compiler$TokensToFormattableAst_Test$firstStatement = function (code) {
	return A2(
		$elm$core$Result$andThen,
		A2(
			$elm$core$Basics$composeR,
			$elm$core$List$head,
			$elm$core$Result$fromMaybe('no head')),
		$author$project$Compiler$TestHelpers$resErrorToString(
			A2(
				$elm$core$Result$map,
				$elm$core$List$map(
					$author$project$Types$FormattableAst$posMap_statement($author$project$Compiler$TokensToFormattableAst_Test$applyDummyPos)),
				$author$project$Compiler$TestHelpers$stringToFormattableModule(code))));
};
var $author$project$Compiler$TokensToFormattableAst_Test$firstAnnotation = function (code) {
	return A2(
		$elm$core$Result$andThen,
		A2(
			$elm$core$Basics$composeR,
			function ($) {
				return $.maybeAnnotation;
			},
			$elm$core$Result$fromMaybe('no annotation')),
		A2(
			$elm$core$Result$andThen,
			$author$project$Compiler$TokensToFormattableAst_Test$asDefinition,
			$author$project$Compiler$TokensToFormattableAst_Test$firstStatement(code)));
};
var $author$project$Compiler$TokensToFormattableAst_Test$simpleTest = $author$project$Test$simple($elm$core$Debug$toString);
var $author$project$Compiler$TokensToFormattableAst_Test$annotations = A2(
	$author$project$Test$Group,
	'Annotations',
	_List_fromArray(
		[
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						mutable: false,
						name: 'a',
						ty: A4(
							$author$project$Types$FormattableAst$TypeFunction,
							$author$project$Compiler$TokensToFormattableAst_Test$p,
							A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Number'),
							true,
							A4(
								$author$project$Types$FormattableAst$TypeFunction,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Int'),
								false,
								A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'None')))
					}),
				name: 'Mutability 1',
				run: function (_v0) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstAnnotation('\n                        a : Number @> Int -> None\n                        a = 1\n                        ');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						mutable: false,
						name: 'a',
						ty: A4(
							$author$project$Types$FormattableAst$TypeFunction,
							$author$project$Compiler$TokensToFormattableAst_Test$p,
							A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Number'),
							false,
							A4(
								$author$project$Types$FormattableAst$TypeFunction,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Int'),
								true,
								A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'None')))
					}),
				name: 'Mutability 2',
				run: function (_v1) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstAnnotation('\n                        a : Number -> Int @> None\n                        a = 1\n                        ');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						mutable: false,
						name: 'a',
						ty: A4(
							$author$project$Types$FormattableAst$TypeFunction,
							$author$project$Compiler$TokensToFormattableAst_Test$p,
							A2(
								$author$project$Types$FormattableAst$TypeTuple,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								_List_fromArray(
									[
										A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Int'),
										A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Int')
									])),
							false,
							A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Bool'))
					}),
				name: 'Tuple precedence',
				run: function (_v2) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstAnnotation('\n                        a : Int & Int -> Bool\n                        a = a\n                        ');
				}
			})
		]));
var $author$project$Compiler$TokensToFormattableAst_Test$codeTest = $author$project$Test$codeTest($elm$core$Debug$toString);
var $author$project$Compiler$TokensToFormattableAst_Test$asEvaluation = function (s) {
	if (s.$ === 'Evaluation') {
		var a = s.a;
		return $elm$core$Result$Ok(a);
	} else {
		return $elm$core$Result$Err('no eval');
	}
};
var $author$project$Compiler$TokensToFormattableAst_Test$firstDefinition = A2(
	$elm$core$Basics$composeR,
	$author$project$Compiler$TokensToFormattableAst_Test$firstStatement,
	$elm$core$Result$andThen($author$project$Compiler$TokensToFormattableAst_Test$asDefinition));
var $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation = function (code) {
	return A2(
		$elm$core$Result$andThen,
		$author$project$Compiler$TokensToFormattableAst_Test$asEvaluation,
		A2(
			$elm$core$Result$andThen,
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.body;
				},
				A2(
					$elm$core$Basics$composeR,
					$elm$core$List$head,
					$elm$core$Result$fromMaybe('empty body'))),
			$author$project$Compiler$TokensToFormattableAst_Test$firstDefinition(code)));
};
var $author$project$Compiler$TokensToFormattableAst_Test$binops = function () {
	var sendBtoCtoD = F3(
		function (b, c, d) {
			return A3(
				$author$project$Types$FormattableAst$Binop,
				$author$project$Compiler$TokensToFormattableAst_Test$p,
				$author$project$Types$Token$Pipe,
				_Utils_Tuple2(
					A3(
						$author$project$Types$FormattableAst$Variable,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						{isBinop: false},
						'b'),
					_List_fromArray(
						[
							_Utils_Tuple2(
							'>>',
							A3(
								$author$project$Types$FormattableAst$Variable,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								{isBinop: false},
								'c')),
							_Utils_Tuple2(
							'>>',
							A3(
								$author$project$Types$FormattableAst$Variable,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								{isBinop: false},
								'd'))
						])));
		});
	var sendBtoC = F2(
		function (b, c) {
			return A3(
				$author$project$Types$FormattableAst$Binop,
				$author$project$Compiler$TokensToFormattableAst_Test$p,
				$author$project$Types$Token$Pipe,
				_Utils_Tuple2(
					A3(
						$author$project$Types$FormattableAst$Variable,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						{isBinop: false},
						'b'),
					_List_fromArray(
						[
							_Utils_Tuple2(
							'>>',
							A3(
								$author$project$Types$FormattableAst$Variable,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								{isBinop: false},
								'c'))
						])));
		});
	return A2(
		$author$project$Test$Group,
		'Binops',
		_List_fromArray(
			[
				A4(
				$author$project$Compiler$TokensToFormattableAst_Test$codeTest,
				'no indent',
				'\n            a = b >> c\n            ',
				$author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation,
				$author$project$Test$okEqual(
					A2(sendBtoC, 5, 10))),
				A4(
				$author$project$Compiler$TokensToFormattableAst_Test$codeTest,
				'assignment indent',
				'\n            a =\n                b >> c\n            ',
				$author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation,
				$author$project$Test$okEqual(
					A2(sendBtoC, 9, 14))),
				A4(
				$author$project$Compiler$TokensToFormattableAst_Test$codeTest,
				'pipe indent',
				'\n            a =\n                b\n                  >> c\n            ',
				$author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation,
				$author$project$Test$okEqual(
					A2(sendBtoC, 9, 20))),
				A4(
				$author$project$Compiler$TokensToFormattableAst_Test$codeTest,
				'pipe indent',
				'\n            a =\n                b\n                  >> c\n                  >> d\n            ',
				$author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation,
				$author$project$Test$okEqual(
					A3(sendBtoCtoD, 9, 20, 31))),
				A4(
				$author$project$Compiler$TokensToFormattableAst_Test$codeTest,
				'pyramid indent',
				'\n            a =\n                b\n                  >> c\n                    >> d\n            ',
				$author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation,
				$author$project$Test$okEqual(
					A3(sendBtoCtoD, 9, 20, 33)))
			]));
}();
var $author$project$Compiler$TokensToFormattableAst_Test$isOk = $author$project$Test$isOk($elm$core$Debug$toString);
var $author$project$Compiler$TokensToFormattableAst_Test$ifs = A2(
	$author$project$Test$Group,
	'Ifs',
	_List_fromArray(
		[
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'inline',
				run: function (_v0) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('a = if a then b else c');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'multiline, formatted',
				run: function (_v1) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('\n                    x =\n                      if a then\n                        b\n                      else\n                        c\n                    ');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'multiline, compact',
				run: function (_v2) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('\n                    x =\n                      if a then b\n                      else c\n                    ');
				}
			})
		]));
var $author$project$Compiler$TokensToFormattableAst_Test$kindToToken = F2(
	function (index, kind) {
		return {end: index + 1, kind: kind, start: index};
	});
var $author$project$Compiler$TokensToFormattableAst_Test$runParser = F2(
	function (parser, ts) {
		return $author$project$Compiler$TestHelpers$resErrorToString(
			A4(
				$author$project$Compiler$TokensToFormattableAst$outcomeToResult,
				'Test',
				'',
				ts,
				A3(
					$author$project$Parser$parse,
					A2($author$project$Compiler$TokensToFormattableAst$discardSecond, parser, $author$project$Parser$end),
					$author$project$Compiler$TokensToFormattableAst$unconsIgnoreComments,
					ts)));
	});
var $author$project$Compiler$TokensToFormattableAst_Test$lambdas = A2(
	$author$project$Test$Group,
	'lambdas',
	_List_fromArray(
		[
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A3(
						$author$project$Types$FormattableAst$Lambda,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						_List_fromArray(
							[
								A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'a')
							]),
						_List_fromArray(
							[
								$author$project$Types$FormattableAst$Evaluation(
								A3(
									$author$project$Types$FormattableAst$Lambda,
									$author$project$Compiler$TokensToFormattableAst_Test$p,
									_List_fromArray(
										[
											A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'b')
										]),
									_List_fromArray(
										[
											$author$project$Types$FormattableAst$Evaluation(
											A2(
												$author$project$Types$FormattableAst$Literal,
												$author$project$Compiler$TokensToFormattableAst_Test$p,
												$author$project$Types$Literal$Number('3')))
										])))
							]))),
				name: 'inline nesting',
				run: function (_v0) {
					return A2(
						$elm$core$Result$map,
						$author$project$Types$FormattableAst$posMap_expression($author$project$Compiler$TokensToFormattableAst_Test$applyDummyPos),
						A2(
							$author$project$Compiler$TokensToFormattableAst_Test$runParser,
							$author$project$Compiler$TokensToFormattableAst$expr,
							A2(
								$elm$core$List$indexedMap,
								$author$project$Compiler$TokensToFormattableAst_Test$kindToToken,
								_List_fromArray(
									[
										$author$project$Types$Token$Fn,
										A2(
										$author$project$Types$Token$Name,
										{mutable: false},
										'a'),
										$author$project$Types$Token$Defop(
										{mutable: false}),
										$author$project$Types$Token$Fn,
										A2(
										$author$project$Types$Token$Name,
										{mutable: false},
										'b'),
										$author$project$Types$Token$Defop(
										{mutable: false}),
										$author$project$Types$Token$NumberLiteral('3')
									]))));
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A3(
						$author$project$Types$FormattableAst$Lambda,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						_List_fromArray(
							[
								A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'a')
							]),
						_List_fromArray(
							[
								$author$project$Types$FormattableAst$Evaluation(
								A3(
									$author$project$Types$FormattableAst$Lambda,
									$author$project$Compiler$TokensToFormattableAst_Test$p,
									_List_fromArray(
										[
											A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'b')
										]),
									_List_fromArray(
										[
											$author$project$Types$FormattableAst$Evaluation(
											A2(
												$author$project$Types$FormattableAst$Literal,
												$author$project$Compiler$TokensToFormattableAst_Test$p,
												$author$project$Types$Literal$Number('3')))
										])))
							]))),
				name: 'block nesting',
				run: function (_v1) {
					return A2(
						$elm$core$Result$map,
						$author$project$Types$FormattableAst$posMap_expression($author$project$Compiler$TokensToFormattableAst_Test$applyDummyPos),
						A2(
							$author$project$Compiler$TokensToFormattableAst_Test$runParser,
							$author$project$Compiler$TokensToFormattableAst$expr,
							A2(
								$elm$core$List$indexedMap,
								$author$project$Compiler$TokensToFormattableAst_Test$kindToToken,
								_List_fromArray(
									[
										$author$project$Types$Token$Fn,
										A2(
										$author$project$Types$Token$Name,
										{mutable: false},
										'a'),
										$author$project$Types$Token$Defop(
										{mutable: false}),
										$author$project$Types$Token$BlockStart,
										$author$project$Types$Token$Fn,
										A2(
										$author$project$Types$Token$Name,
										{mutable: false},
										'b'),
										$author$project$Types$Token$Defop(
										{mutable: false}),
										$author$project$Types$Token$BlockStart,
										$author$project$Types$Token$NumberLiteral('3'),
										$author$project$Types$Token$BlockEnd,
										$author$project$Types$Token$BlockEnd
									]))));
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A3(
						$author$project$Types$FormattableAst$Lambda,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						_List_fromArray(
							[
								A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'a')
							]),
						_List_fromArray(
							[
								$author$project$Types$FormattableAst$Evaluation(
								A3(
									$author$project$Types$FormattableAst$Lambda,
									$author$project$Compiler$TokensToFormattableAst_Test$p,
									_List_fromArray(
										[
											A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'b')
										]),
									_List_fromArray(
										[
											$author$project$Types$FormattableAst$Evaluation(
											A2(
												$author$project$Types$FormattableAst$Literal,
												$author$project$Compiler$TokensToFormattableAst_Test$p,
												$author$project$Types$Literal$Number('3')))
										])))
							]))),
				name: 'sibling nesting',
				run: function (_v2) {
					return A2(
						$elm$core$Result$map,
						$author$project$Types$FormattableAst$posMap_expression($author$project$Compiler$TokensToFormattableAst_Test$applyDummyPos),
						A2(
							$author$project$Compiler$TokensToFormattableAst_Test$runParser,
							$author$project$Compiler$TokensToFormattableAst$expr,
							A2(
								$elm$core$List$indexedMap,
								$author$project$Compiler$TokensToFormattableAst_Test$kindToToken,
								_List_fromArray(
									[
										$author$project$Types$Token$Fn,
										A2(
										$author$project$Types$Token$Name,
										{mutable: false},
										'a'),
										$author$project$Types$Token$Defop(
										{mutable: false}),
										$author$project$Types$Token$NewSiblingLine,
										$author$project$Types$Token$Fn,
										A2(
										$author$project$Types$Token$Name,
										{mutable: false},
										'b'),
										$author$project$Types$Token$Defop(
										{mutable: false}),
										$author$project$Types$Token$NewSiblingLine,
										$author$project$Types$Token$NumberLiteral('3')
									]))));
				}
			})
		]));
var $author$project$Compiler$TokensToFormattableAst_Test$lists = A2(
	$author$project$Test$Group,
	'Lists',
	_List_fromArray(
		[
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$List,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						_List_fromArray(
							[
								A2(
								$author$project$Types$FormattableAst$Literal,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								$author$project$Types$Literal$Number('1')),
								A2(
								$author$project$Types$FormattableAst$Literal,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								$author$project$Types$Literal$Number('2'))
							]))),
				name: 'inline',
				run: function (_v0) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('a = [1, 2]');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$List,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						_List_fromArray(
							[
								A2(
								$author$project$Types$FormattableAst$Literal,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								$author$project$Types$Literal$Number('1')),
								A2(
								$author$project$Types$FormattableAst$Literal,
								$author$project$Compiler$TokensToFormattableAst_Test$p,
								$author$project$Types$Literal$Number('2'))
							]))),
				name: 'multiline',
				run: function (_v1) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('\n                 a = [\n                   , 1\n                   , 2\n                   ]\n                 ');
				}
			})
		]));
var $author$project$Compiler$TokensToFormattableAst_Test$patterns = A2(
	$author$project$Test$Group,
	'Patterns',
	_List_fromArray(
		[
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$PatternList,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						_List_fromArray(
							[
								A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'a'),
								A2($author$project$Types$FormattableAst$PatternAny, $author$project$Compiler$TokensToFormattableAst_Test$p, 'b')
							]))),
				name: 'list unpacking',
				run: function (_v0) {
					return A2(
						$elm$core$Result$map,
						function ($) {
							return $.pattern;
						},
						$author$project$Compiler$TokensToFormattableAst_Test$firstDefinition('[a, b] = x'));
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'list unpacking, inner block',
				run: function (_v1) {
					return A2(
						$elm$core$Result$map,
						function ($) {
							return $.pattern;
						},
						$author$project$Compiler$TokensToFormattableAst_Test$firstDefinition('\nx =\n   [ a, b ] = c\n                    '));
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$PatternRecord,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						{
							attrs: _List_fromArray(
								[
									_Utils_Tuple2('a', $elm$core$Maybe$Nothing),
									_Utils_Tuple2('b', $elm$core$Maybe$Nothing)
								]),
							_extends: $elm$core$Maybe$Nothing
						})),
				name: 'record unpacking',
				run: function (_v2) {
					return A2(
						$elm$core$Result$map,
						function ($) {
							return $.pattern;
						},
						$author$project$Compiler$TokensToFormattableAst_Test$firstDefinition('{ a, b } = x'));
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'record unpacking, inner block',
				run: function (_v3) {
					return A2(
						$elm$core$Result$map,
						function ($) {
							return $.pattern;
						},
						$author$project$Compiler$TokensToFormattableAst_Test$firstDefinition('\nx =\n  { a, b } = c\n                    '));
				}
			})
		]));
var $author$project$Compiler$TokensToFormattableAst_Test$records = A2(
	$author$project$Test$Group,
	'Records',
	_List_fromArray(
		[
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$Record,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						{
							attrs: _List_fromArray(
								[
									_Utils_Tuple2(
									'x',
									$elm$core$Maybe$Just(
										A2(
											$author$project$Types$FormattableAst$Literal,
											$author$project$Compiler$TokensToFormattableAst_Test$p,
											$author$project$Types$Literal$Number('1'))))
								]),
							_extends: $elm$core$Maybe$Nothing
						})),
				name: 'inline',
				run: function (_v0) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('a = { x = 1 }');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$Record,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						{
							attrs: _List_fromArray(
								[
									_Utils_Tuple2(
									'x',
									$elm$core$Maybe$Just(
										A2(
											$author$project$Types$FormattableAst$Literal,
											$author$project$Compiler$TokensToFormattableAst_Test$p,
											$author$project$Types$Literal$Number('1')))),
									_Utils_Tuple2(
									'y',
									$elm$core$Maybe$Just(
										A2(
											$author$project$Types$FormattableAst$Literal,
											$author$project$Compiler$TokensToFormattableAst_Test$p,
											$author$project$Types$Literal$Number('2'))))
								]),
							_extends: $elm$core$Maybe$Nothing
						})),
				name: 'multiline',
				run: function (_v1) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('\n                    a = {\n                      , x = 1\n                      , y = 2\n                      }\n                    ');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$TypeRecord,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						{
							attrs: _List_fromArray(
								[
									_Utils_Tuple2(
									'x',
									$elm$core$Maybe$Just(
										A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Bool')))
								]),
							_extends: $elm$core$Maybe$Nothing
						})),
				name: 'annotation, inline',
				run: function (_v2) {
					return A2(
						$elm$core$Result$map,
						function ($) {
							return $.ty;
						},
						$author$project$Compiler$TokensToFormattableAst_Test$firstAnnotation('\n                    a : { x : Bool }\n                    a = a\n                    '));
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					A2(
						$author$project$Types$FormattableAst$TypeRecord,
						$author$project$Compiler$TokensToFormattableAst_Test$p,
						{
							attrs: _List_fromArray(
								[
									_Utils_Tuple2(
									'x',
									$elm$core$Maybe$Just(
										A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Bool')))
								]),
							_extends: $elm$core$Maybe$Nothing
						})),
				name: 'annotation, multiline',
				run: function (_v3) {
					return A2(
						$elm$core$Result$map,
						function ($) {
							return $.ty;
						},
						$author$project$Compiler$TokensToFormattableAst_Test$firstAnnotation('\n                    a : {\n                       , x : Bool\n                       }\n                    a = a\n                    '));
				}
			}),
			A4($author$project$Compiler$TokensToFormattableAst_Test$codeTest, '[reg] simple assignment, inline', '\n            a = { b with c }\n            ', $author$project$Compiler$TokensToFormattableAst_Test$firstDefinition, $author$project$Test$justOk),
			A4($author$project$Compiler$TokensToFormattableAst_Test$codeTest, '[reg] simple assignment, as block', '\n            a =\n              { b with c }\n            ', $author$project$Compiler$TokensToFormattableAst_Test$firstDefinition, $author$project$Test$justOk),
			A4($author$project$Compiler$TokensToFormattableAst_Test$codeTest, '[reg] simple assignment, as block', '\n            a =\n              { b with c = 1 }\n            ', $author$project$Compiler$TokensToFormattableAst_Test$firstDefinition, $author$project$Test$justOk)
		]));
var $author$project$Compiler$TokensToFormattableAst_Test$tries = A2(
	$author$project$Test$Group,
	'Try',
	_List_fromArray(
		[
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'inline',
				run: function (_v0) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('x = try a as b then c else d');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'multiline, formatted',
				run: function (_v1) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('\n                    x =\n                      try a as\n                        b then\n                          c\n                        d then\n                          e\n                        else\n                          f\n                    ');
				}
			}),
			$author$project$Compiler$TokensToFormattableAst_Test$isOk(
			{
				name: 'multiline, compact',
				run: function (_v2) {
					return $author$project$Compiler$TokensToFormattableAst_Test$firstEvaluation('\n                    x =\n                      try a as\n                        b then c\n                        d then e\n                        else f\n                    ');
				}
			})
		]));
var $author$project$Compiler$TokensToFormattableAst_Test$unionDefs = function () {
	var asTypeDef = function (s) {
		if (s.$ === 'UnionDef') {
			var a = s.a;
			return $elm$core$Result$Ok(a);
		} else {
			return $elm$core$Result$Err('no type def');
		}
	};
	var firstTypeDef = A2(
		$elm$core$Basics$composeR,
		$author$project$Compiler$TokensToFormattableAst_Test$firstStatement,
		$elm$core$Result$andThen(asTypeDef));
	return A2(
		$author$project$Test$Group,
		'Type Definitions',
		_List_fromArray(
			[
				$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
				{
					expected: $elm$core$Result$Ok(
						{
							args: _List_fromArray(
								['b', 'c']),
							constructors: _List_fromArray(
								[
									A3(
									$author$project$Types$FormattableAst$TypePolymorphic,
									$author$project$Compiler$TokensToFormattableAst_Test$p,
									'V1',
									_List_fromArray(
										[
											A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'b')
										])),
									A3(
									$author$project$Types$FormattableAst$TypePolymorphic,
									$author$project$Compiler$TokensToFormattableAst_Test$p,
									'V2',
									_List_fromArray(
										[
											A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'c')
										])),
									A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'V3'),
									A3(
									$author$project$Types$FormattableAst$TypePolymorphic,
									$author$project$Compiler$TokensToFormattableAst_Test$p,
									'V4',
									_List_fromArray(
										[
											A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'b'),
											A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'c')
										]))
								]),
							name: 'A'
						}),
					name: 'Parse inline def',
					run: function (_v0) {
						return firstTypeDef('union A b c = V1 b, V2 c, V3, V4 b c');
					}
				}),
				$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
				{
					expected: $elm$core$Result$Ok(
						{
							args: _List_Nil,
							constructors: _List_fromArray(
								[
									A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'V1'),
									A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'V2')
								]),
							name: 'A'
						}),
					name: 'Parse multiline def',
					run: function (_v1) {
						return firstTypeDef('\n                        union A =\n                           , V1\n                           , V2\n                        ');
					}
				}),
				$author$project$Compiler$TokensToFormattableAst_Test$simpleTest(
				{
					expected: $elm$core$Result$Ok(
						{
							args: _List_Nil,
							constructors: _List_fromArray(
								[
									A3(
									$author$project$Types$FormattableAst$TypePolymorphic,
									$author$project$Compiler$TokensToFormattableAst_Test$p,
									'A',
									_List_fromArray(
										[
											A3(
											$author$project$Types$FormattableAst$TypePolymorphic,
											$author$project$Compiler$TokensToFormattableAst_Test$p,
											'List',
											_List_fromArray(
												[
													A2($author$project$Types$FormattableAst$TypeName, $author$project$Compiler$TokensToFormattableAst_Test$p, 'Int')
												]))
										]))
								]),
							name: 'A'
						}),
					name: 'list argument',
					run: function (_v2) {
						return firstTypeDef('union A = A [Int]');
					}
				})
			]));
}();
var $author$project$Compiler$TokensToFormattableAst_Test$tests = A2(
	$author$project$Test$Group,
	'TokensToFormattableAst',
	_List_fromArray(
		[$author$project$Compiler$TokensToFormattableAst_Test$lambdas, $author$project$Compiler$TokensToFormattableAst_Test$annotations, $author$project$Compiler$TokensToFormattableAst_Test$unionDefs, $author$project$Compiler$TokensToFormattableAst_Test$lists, $author$project$Compiler$TokensToFormattableAst_Test$records, $author$project$Compiler$TokensToFormattableAst_Test$ifs, $author$project$Compiler$TokensToFormattableAst_Test$tries, $author$project$Compiler$TokensToFormattableAst_Test$patterns, $author$project$Compiler$TokensToFormattableAst_Test$binops]));
var $author$project$Test$NotNow = function (a) {
	return {$: 'NotNow', a: a};
};
var $author$project$Compiler$TypeInference_Test$codeTest = $author$project$Test$codeTest($elm$core$Debug$toString);
var $author$project$Compiler$TypeInference_Test$function = F2(
	function (from, to) {
		return A4($author$project$Types$CanonicalAst$TypeFunction, $author$project$Compiler$TestHelpers$p, from, $elm$core$Maybe$Nothing, to);
	});
var $author$project$Compiler$TypeInference_Test$hasError = $author$project$Test$hasError($elm$core$Debug$toString);
var $elm$core$Set$map = F2(
	function (func, set) {
		return $elm$core$Set$fromList(
			A3(
				$elm$core$Set$foldl,
				F2(
					function (x, xs) {
						return A2(
							$elm$core$List$cons,
							func(x),
							xs);
					}),
				_List_Nil,
				set));
	});
var $author$project$Compiler$TypeInference_Test$normalizeName = F2(
	function (dict, name) {
		var _v0 = A2($elm$core$Dict$get, name, dict);
		if (_v0.$ === 'Just') {
			var _new = _v0.a;
			return _Utils_Tuple2(_new, dict);
		} else {
			if (_Utils_eq(
				$elm$core$String$toInt(name),
				$elm$core$Maybe$Nothing)) {
				return _Utils_Tuple2(name, dict);
			} else {
				var n = $elm$core$String$fromInt(
					$elm$core$Dict$size(dict) + 1);
				return _Utils_Tuple2(
					n,
					A3($elm$core$Dict$insert, name, n, dict));
			}
		}
	});
var $author$project$Compiler$TypeInference_Test$normalizeType = F2(
	function (dict, ty) {
		switch (ty.$) {
			case 'TypeConstant':
				var pos = ty.a;
				var name = ty.b;
				var args = ty.c;
				var fold = F2(
					function (arg, _v2) {
						var ars = _v2.a;
						var d = _v2.b;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (na) {
								return A2($elm$core$List$cons, na, ars);
							},
							A2($author$project$Compiler$TypeInference_Test$normalizeType, d, arg));
					});
				var _v1 = A3(
					$elm$core$List$foldl,
					fold,
					_Utils_Tuple2(_List_Nil, dict),
					args);
				var reversedArgs = _v1.a;
				var dict1 = _v1.b;
				return _Utils_Tuple2(
					A3(
						$author$project$Types$CanonicalAst$TypeConstant,
						pos,
						name,
						$elm$core$List$reverse(reversedArgs)),
					dict1);
			case 'TypeVariable':
				var pos = ty.a;
				var name = ty.b;
				return A2(
					$elm$core$Tuple$mapFirst,
					$author$project$Types$CanonicalAst$TypeVariable(pos),
					A2($author$project$Compiler$TypeInference_Test$normalizeName, dict, name));
			case 'TypeFunction':
				var pos = ty.a;
				var from0 = ty.b;
				var fromIsMut = ty.c;
				var to0 = ty.d;
				var _v3 = A2($author$project$Compiler$TypeInference_Test$normalizeType, dict, from0);
				var from = _v3.a;
				var d1 = _v3.b;
				var _v4 = A2($author$project$Compiler$TypeInference_Test$normalizeType, d1, to0);
				var to = _v4.a;
				var d2 = _v4.b;
				return _Utils_Tuple2(
					A4($author$project$Types$CanonicalAst$TypeFunction, pos, from, fromIsMut, to),
					d2);
			case 'TypeRecord':
				var pos = ty.a;
				var ext0 = ty.b;
				var attrs0 = ty.c;
				var fold = F3(
					function (name, attr, _v8) {
						var accum = _v8.a;
						var d = _v8.b;
						return A2(
							$elm$core$Tuple$mapFirst,
							function (na) {
								return A3($elm$core$Dict$insert, name, na, accum);
							},
							A2($author$project$Compiler$TypeInference_Test$normalizeType, d, attr));
					});
				var _v5 = function () {
					if (ext0.$ === 'Nothing') {
						return _Utils_Tuple2($elm$core$Maybe$Nothing, dict);
					} else {
						var e = ext0.a;
						return A2(
							$elm$core$Tuple$mapFirst,
							$elm$core$Maybe$Just,
							A2($author$project$Compiler$TypeInference_Test$normalizeName, dict, e));
					}
				}();
				var et = _v5.a;
				var d1 = _v5.b;
				var _v7 = A3(
					$elm$core$Dict$foldl,
					fold,
					_Utils_Tuple2($elm$core$Dict$empty, d1),
					attrs0);
				var attrs = _v7.a;
				var d2 = _v7.b;
				return _Utils_Tuple2(
					A3($author$project$Types$CanonicalAst$TypeRecord, pos, et, attrs),
					d2);
			default:
				var pos = ty.a;
				var path = ty.b;
				var t = ty.c;
				return A2(
					$elm$core$Tuple$mapFirst,
					A2($author$project$Types$CanonicalAst$TypeAlias, pos, path),
					A2($author$project$Compiler$TypeInference_Test$normalizeType, dict, t));
		}
	});
var $author$project$Compiler$TypeInference_Test$normalizeSchema = function (schema) {
	var _v0 = A2($author$project$Compiler$TypeInference_Test$normalizeType, $elm$core$Dict$empty, schema.type_);
	var ty = _v0.a;
	var dict = _v0.b;
	var replaceName = function (name) {
		return A2(
			$elm$core$Maybe$withDefault,
			name,
			A2($elm$core$Dict$get, name, dict));
	};
	return _Utils_update(
		schema,
		{
			forall: A2($elm$core$Set$map, replaceName, schema.forall),
			type_: ty
		});
};
var $author$project$Compiler$TypeInference_Test$constant = function (n) {
	return A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, n, _List_Nil);
};
var $author$project$Compiler$TypeInference_Test$tyNone = $author$project$Compiler$TypeInference_Test$constant('SPCore.None');
var $author$project$Compiler$TypeInference_Test$tyNumber = $author$project$Compiler$TypeInference_Test$constant('SPCore.Number');
var $author$project$Compiler$TypeInference_Test$typeFunction = function (_v0) {
	var from = _v0.from;
	var fromIsMutable = _v0.fromIsMutable;
	var to = _v0.to;
	return A4($author$project$Types$CanonicalAst$TypeFunction, $author$project$Compiler$TestHelpers$p, from, fromIsMutable, to);
};
var $author$project$Compiler$TypeInference_Test$preamble = function () {
	var em = function (x) {
		return {
			forall: $elm$core$Set$empty,
			mutable: $elm$core$Maybe$Just(false),
			type_: x
		};
	};
	return $elm$core$Dict$fromList(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'Test.add',
				em(
					A2(
						$author$project$Compiler$TypeInference_Test$function,
						$author$project$Compiler$TypeInference_Test$tyNumber,
						A2($author$project$Compiler$TypeInference_Test$function, $author$project$Compiler$TypeInference_Test$tyNumber, $author$project$Compiler$TypeInference_Test$tyNumber)))),
				_Utils_Tuple2(
				'Test.reset',
				em(
					$author$project$Compiler$TypeInference_Test$typeFunction(
						{
							from: $author$project$Compiler$TypeInference_Test$tyNumber,
							fromIsMutable: $elm$core$Maybe$Just(true),
							to: $author$project$Compiler$TypeInference_Test$tyNone
						})))
			]));
}();
var $author$project$Compiler$TypeInference_Test$infer = F2(
	function (name, code) {
		return A2(
			$elm$core$Result$andThen,
			function (_v0) {
				var mod = _v0.a;
				var env = _v0.b;
				var subs = _v0.c;
				return A2(
					$elm$core$Result$map,
					function (schema) {
						return _Utils_update(
							schema,
							{
								type_: A2($author$project$Compiler$TestHelpers$removePos, $author$project$Types$CanonicalAst$extensionFold_type, schema.type_)
							});
					},
					A2(
						$elm$core$Result$fromMaybe,
						'Dict fail',
						A2(
							$elm$core$Maybe$map,
							$author$project$Compiler$TypeInference_Test$normalizeSchema,
							A2($elm$core$Dict$get, 'Test.' + name, env))));
			},
			$author$project$Compiler$TestHelpers$resErrorToString(
				A2(
					$elm$core$Result$andThen,
					$author$project$Compiler$TypeInference$inspectModule($author$project$Compiler$TypeInference_Test$preamble),
					$author$project$Compiler$TestHelpers$stringToCanonicalModuleWithPos(code))));
	});
var $author$project$Compiler$TypeInference_Test$simpleTest = $author$project$Test$simple($elm$core$Debug$toString);
var $author$project$Compiler$TypeInference_Test$typeConstant = function (_v0) {
	var ref = _v0.ref;
	var args = _v0.args;
	return A3($author$project$Types$CanonicalAst$TypeConstant, $author$project$Compiler$TestHelpers$p, ref, args);
};
var $author$project$Compiler$TypeInference_Test$typeVariable = function (_v0) {
	var name = _v0.name;
	return A2($author$project$Types$CanonicalAst$TypeVariable, $author$project$Compiler$TestHelpers$p, name);
};
var $author$project$Compiler$TypeInference_Test$functions = A2(
	$author$project$Test$Group,
	'functions',
	_List_fromArray(
		[
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$tyNumber
					}),
				name: 'Known function with correct params',
				run: function (_v0) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a = add 3 1');
				}
			}),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'Known function with wrong params',
				run: function (_v1) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a = add False');
				},
				test: $author$project$Test$errorShouldContain('SPCore.Bool')
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: A2($author$project$Compiler$TypeInference_Test$function, $author$project$Compiler$TypeInference_Test$tyNumber, $author$project$Compiler$TypeInference_Test$tyNumber)
					}),
				name: 'Function inference 1',
				run: function (_v2) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a x = add x 1');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: A2($author$project$Compiler$TypeInference_Test$function, $author$project$Compiler$TypeInference_Test$tyNumber, $author$project$Compiler$TypeInference_Test$tyNumber)
					}),
				name: 'Function inference 2: same as 1, but with swapped args',
				run: function (_v3) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a x = add 1 x');
				}
			}),
			$author$project$Test$NotNow(
			$author$project$Compiler$TypeInference_Test$hasError(
				{
					name: 'Function args can\'t shadow other names',
					run: function (_v4) {
						return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a = fn a = 1');
					},
					test: $author$project$Test$errorShouldContain('function parameter `a` shadows env variable')
				})),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$fromList(
							_List_fromArray(
								['1'])),
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$typeVariable(
									{name: '1'}),
								fromIsMutable: $elm$core$Maybe$Nothing,
								to: $author$project$Compiler$TypeInference_Test$typeConstant(
									{args: _List_Nil, ref: 'SPCore.Number'})
							})
					}),
				name: '[reg] fn has type None',
				run: function (_v5) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a = fn x = 1');
				}
			}),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'[reg] function with multiple arguments are correctly inferred',
			'\n            a x y z = x + y + z\n            ',
			$author$project$Compiler$TypeInference_Test$infer('a'),
			$author$project$Test$justOk)
		]));
var $author$project$Compiler$TypeInference_Test$higherOrderTypes = A2(
	$author$project$Test$Group,
	'higher order types',
	_List_fromArray(
		[
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$singleton('a'),
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$typeConstant(
									{
										args: _List_fromArray(
											[
												$author$project$Compiler$TypeInference_Test$typeVariable(
												{name: 'a'})
											]),
										ref: 'SPCore.List'
									}),
								fromIsMutable: $elm$core$Maybe$Just(false),
								to: $author$project$Compiler$TypeInference_Test$typeConstant(
									{
										args: _List_fromArray(
											[
												$author$project$Compiler$TypeInference_Test$typeVariable(
												{name: 'a'})
											]),
										ref: 'SPCore.List'
									})
							})
					}),
				name: 'Parse precedence',
				run: function (_v0) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a : List a -> List a\n                        a l = l\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$singleton('a'),
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeConstant(
							{
								args: _List_fromArray(
									[
										$author$project$Compiler$TypeInference_Test$typeVariable(
										{name: 'a'})
									]),
								ref: 'Test.X'
							})
					}),
				name: 'Union type constructors',
				run: function (_v1) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'L', 'union X a = L');
				}
			})
		]));
var $author$project$Compiler$TypeInference_Test$if_then = A2(
	$author$project$Test$Group,
	'if..then',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'basic functionality',
			'\n            x q =\n              if q then 1\n              else 2\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$okEqual(
				{
					forall: $elm$core$Set$fromList(_List_Nil),
					mutable: $elm$core$Maybe$Just(false),
					type_: $author$project$Compiler$TypeInference_Test$typeFunction(
						{
							from: $author$project$Compiler$TypeInference_Test$typeConstant(
								{args: _List_Nil, ref: 'SPCore.Bool'}),
							fromIsMutable: $elm$core$Maybe$Nothing,
							to: $author$project$Compiler$TypeInference_Test$typeConstant(
								{args: _List_Nil, ref: 'SPCore.Number'})
						})
				})),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'rejects non-bool conditions',
			'\n            x q =\n              if 1 then 1\n              else 2\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$errContain('SPCore.Bool')),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'rejects non-matching blocks',
			'\n            x q =\n              if q then 2\n              else False\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$errContain('SPCore.Number'))
		]));
var $author$project$Compiler$TypeInference_Test$mutability = A2(
	$author$project$Test$Group,
	'mutability',
	_List_fromArray(
		[
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'Statement blocks that define mutables can\'t return functions',
				run: function (_v0) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a =\n                          x @= 1\n                          fn y = y\n                        ');
				},
				test: $author$project$Test$errorShouldContain('statement blocks that define mutables can\'t return functions')
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$tyNumber,
								fromIsMutable: $elm$core$Maybe$Just(true),
								to: $author$project$Compiler$TypeInference_Test$tyNone
							})
					}),
				name: 'Infer lambda arg mutability',
				run: function (_v1) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a =\n                          q x =\n                            reset @x\n                          q\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'Detect mismatching annotations',
				run: function (_v2) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a : Number -> None\n                        a =\n                          reset\n                        ');
				},
				test: $author$project$Test$errorShouldContain('mutability clash')
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$tyNumber,
								fromIsMutable: $elm$core$Maybe$Just(true),
								to: $author$project$Compiler$TypeInference_Test$tyNone
							})
					}),
				name: 'Correctly unify annotation\'s mutability',
				run: function (_v3) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a : Number @> None\n                        a =\n                          reset\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'Functions can\'t be mutable 1',
				run: function (_v4) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a @= fn x = x');
				},
				test: $author$project$Test$errorShouldContain('these mutable values contain functions: Test.a')
			}),
			$author$project$Test$NotNow(
			$author$project$Compiler$TypeInference_Test$simpleTest(
				{
					expected: $elm$core$Result$Err('these mutable values contain functions: f'),
					name: 'Functions can\'t be mutable 2',
					run: function (_v5) {
						return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a f = @f := (fn x = x)');
					}
				})),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'Lambda argument mutability is correctly inferred',
				run: function (_v6) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a = fn x = reset x');
				},
				test: $author$project$Test$errorShouldContain('mutability clash')
			}),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: '*Nested* lambda argument mutability is correctly inferred',
				run: function (_v7) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a = fn x = (fn y = reset y) x');
				},
				test: $author$project$Test$errorShouldContain('mutability clash')
			}),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'Functions can\'t be mutable (annotation)',
				run: function (_v8) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        f @: Int -> Int\n                        f @= add 1\n                        ');
				},
				test: $author$project$Test$errorShouldContain('mutable')
			}),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'args that are functions can\'t be mutable (annotation)',
				run: function (_v9) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a : (Int -> Int) @> Int\n                        a = a\n                        ');
				},
				test: $author$project$Test$errorShouldContain('mutable')
			})
		]));
var $author$project$Compiler$TypeInference_Test$typeRecord = function (_v0) {
	var extensible = _v0.extensible;
	var attrs = _v0.attrs;
	return A3($author$project$Types$CanonicalAst$TypeRecord, $author$project$Compiler$TestHelpers$p, extensible, attrs);
};
var $author$project$Compiler$TypeInference_Test$patterns = A2(
	$author$project$Test$Group,
	'Patterns',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'List unpacking',
			'\n            x q =\n                   [ first, second ] = q\n                   first\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$okEqual(
				{
					forall: $elm$core$Set$fromList(
						_List_fromArray(
							['1'])),
					mutable: $elm$core$Maybe$Just(false),
					type_: $author$project$Compiler$TypeInference_Test$typeFunction(
						{
							from: $author$project$Compiler$TypeInference_Test$typeConstant(
								{
									args: _List_fromArray(
										[
											$author$project$Compiler$TypeInference_Test$typeVariable(
											{name: '1'})
										]),
									ref: 'SPCore.List'
								}),
							fromIsMutable: $elm$core$Maybe$Nothing,
							to: $author$project$Compiler$TypeInference_Test$typeVariable(
								{name: '1'})
						})
				})),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'Records are correctly unpacked',
			'\n            x q =\n                { first } = q\n                first\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$okEqual(
				{
					forall: $elm$core$Set$fromList(
						_List_fromArray(
							['2', '1'])),
					mutable: $elm$core$Maybe$Just(false),
					type_: $author$project$Compiler$TypeInference_Test$typeFunction(
						{
							from: $author$project$Compiler$TypeInference_Test$typeRecord(
								{
									attrs: $elm$core$Dict$fromList(
										_List_fromArray(
											[
												_Utils_Tuple2(
												'first',
												$author$project$Compiler$TypeInference_Test$typeVariable(
													{name: '2'}))
											])),
									extensible: $elm$core$Maybe$Just('1')
								}),
							fromIsMutable: $elm$core$Maybe$Nothing,
							to: $author$project$Compiler$TypeInference_Test$typeVariable(
								{name: '2'})
						})
				}))
		]));
var $author$project$Compiler$TypeInference_Test$isOk = $author$project$Test$isOk($elm$core$Debug$toString);
var $author$project$Compiler$TypeInference_Test$records = A2(
	$author$project$Test$Group,
	'Records',
	_List_fromArray(
		[
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$fromList(
							_List_fromArray(
								['1', '2', '3'])),
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$typeRecord(
									{
										attrs: A2(
											$elm$core$Dict$singleton,
											'meh',
											$author$project$Compiler$TypeInference_Test$typeRecord(
												{
													attrs: A2(
														$elm$core$Dict$singleton,
														'blah',
														$author$project$Compiler$TypeInference_Test$typeVariable(
															{name: '3'})),
													extensible: $elm$core$Maybe$Just('2')
												})),
										extensible: $elm$core$Maybe$Just('1')
									}),
								fromIsMutable: $elm$core$Maybe$Nothing,
								to: $author$project$Compiler$TypeInference_Test$typeVariable(
									{name: '3'})
							})
					}),
				name: 'Attribute access',
				run: function (_v0) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a b = b.meh.blah\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$fromList(
							_List_fromArray(
								['1', '2'])),
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$typeRecord(
									{
										attrs: A2(
											$elm$core$Dict$singleton,
											'meh',
											$author$project$Compiler$TypeInference_Test$typeRecord(
												{
													attrs: A2(
														$elm$core$Dict$singleton,
														'blah',
														$author$project$Compiler$TypeInference_Test$typeConstant(
															{args: _List_Nil, ref: 'SPCore.Number'})),
													extensible: $elm$core$Maybe$Just('2')
												})),
										extensible: $elm$core$Maybe$Just('1')
									}),
								fromIsMutable: $elm$core$Maybe$Just(true),
								to: $author$project$Compiler$TypeInference_Test$typeConstant(
									{args: _List_Nil, ref: 'SPCore.None'})
							})
					}),
				name: 'Attribute mutation',
				run: function (_v1) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a b = @b.meh.blah += 1\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$isOk(
			{
				name: 'Tuple3 direct item mutability',
				run: function (_v2) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'x', '\n                        x =\n                          a @= 3 & False & 2\n\n                          @a.third += 1\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$isOk(
			{
				name: 'Tuple2 direct item mutability, annotated',
				run: function (_v3) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'x', '\n                        x =\n                           a @: Number & Number\n                           a @= 1 & 2\n\n                           @a.first += 1\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: function () {
					var re = $author$project$Compiler$TypeInference_Test$typeRecord(
						{
							attrs: A2(
								$elm$core$Dict$singleton,
								'x',
								$author$project$Compiler$TypeInference_Test$typeConstant(
									{args: _List_Nil, ref: 'SPCore.Number'})),
							extensible: $elm$core$Maybe$Just('1')
						});
					return $elm$core$Result$Ok(
						{
							forall: $elm$core$Set$fromList(
								_List_fromArray(
									['1'])),
							mutable: $elm$core$Maybe$Just(false),
							type_: $author$project$Compiler$TypeInference_Test$typeFunction(
								{from: re, fromIsMutable: $elm$core$Maybe$Nothing, to: re})
						});
				}(),
				name: 'functional update',
				run: function (_v4) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', 'a b = { b with x = 1 }');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: function () {
					var re = $author$project$Compiler$TypeInference_Test$typeRecord(
						{
							attrs: A2(
								$elm$core$Dict$singleton,
								'x',
								$author$project$Compiler$TypeInference_Test$typeConstant(
									{args: _List_Nil, ref: 'SPCore.Number'})),
							extensible: $elm$core$Maybe$Just('1')
						});
					return $elm$core$Result$Ok(
						{
							forall: $elm$core$Set$fromList(
								_List_fromArray(
									['1'])),
							mutable: $elm$core$Maybe$Just(false),
							type_: $author$project$Compiler$TypeInference_Test$typeFunction(
								{from: re, fromIsMutable: $elm$core$Maybe$Nothing, to: re})
						});
				}(),
				name: 'instantiate and refine inferred records',
				run: function (_v5) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'c', '\n                        a t = { t with x = 1 }\n                        c = a\n                        ');
				}
			}),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'[reg] excessive forallness in records',
			'\n            x q =\n             a = q.first\n             a\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$okEqual(
				{
					forall: $elm$core$Set$fromList(
						_List_fromArray(
							['2', '1'])),
					mutable: $elm$core$Maybe$Just(false),
					type_: $author$project$Compiler$TypeInference_Test$typeFunction(
						{
							from: $author$project$Compiler$TypeInference_Test$typeRecord(
								{
									attrs: $elm$core$Dict$fromList(
										_List_fromArray(
											[
												_Utils_Tuple2(
												'first',
												$author$project$Compiler$TypeInference_Test$typeVariable(
													{name: '2'}))
											])),
									extensible: $elm$core$Maybe$Just('1')
								}),
							fromIsMutable: $elm$core$Maybe$Nothing,
							to: $author$project$Compiler$TypeInference_Test$typeVariable(
								{name: '2'})
						})
				})),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'[reg] refineType when the record has a non-extensible alias',
			'\n            alias A = { c : Number, d : Number }\n\n            upd : A -> A\n            upd a =\n              { a with c = .c + 1 }\n            ',
			$author$project$Compiler$TypeInference_Test$infer('upd'),
			$author$project$Test$justOk)
		]));
var $author$project$Compiler$TypeInference_Test$statements = A2(
	$author$project$Test$Group,
	'statements',
	_List_fromArray(
		[
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$constant('SPCore.Bool')
					}),
				name: 'Statement blocks should return the last statement\'s type',
				run: function (_v0) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                a =\n                  3\n                  False\n                ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$tyNone
					}),
				name: 'Definition statement return type None',
				run: function (_v1) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                a =\n                  f x = 3\n                ');
				}
			})
		]));
var $author$project$Compiler$TypeInference_Test$try_as = A2(
	$author$project$Test$Group,
	'try..as',
	_List_fromArray(
		[
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'basic functionality',
			'\n            x q =\n             try q as\n               True then 2\n               else 3\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$okEqual(
				{
					forall: $elm$core$Set$fromList(_List_Nil),
					mutable: $elm$core$Maybe$Just(false),
					type_: $author$project$Compiler$TypeInference_Test$typeFunction(
						{
							from: $author$project$Compiler$TypeInference_Test$typeConstant(
								{args: _List_Nil, ref: 'SPCore.Bool'}),
							fromIsMutable: $elm$core$Maybe$Nothing,
							to: $author$project$Compiler$TypeInference_Test$typeConstant(
								{args: _List_Nil, ref: 'SPCore.Number'})
						})
				})),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'rejects non-matching patterns',
			'\n            x q =\n             try q as\n               True then 2\n               [] then 3\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$errContain('SPCore.List')),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'rejects non-matching blocks',
			'\n            x q =\n             try q as\n               True then 2\n               False then False\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$errContain('SPCore.Number'))
		]));
var $author$project$Compiler$TypeInference_Test$variableTypes = A2(
	$author$project$Test$Group,
	'variable types',
	_List_fromArray(
		[
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$singleton('a'),
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$typeVariable(
									{name: 'a'}),
								fromIsMutable: $elm$core$Maybe$Just(false),
								to: $author$project$Compiler$TypeInference_Test$typeVariable(
									{name: 'a'})
							})
					}),
				name: 'Identity',
				run: function (_v0) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'id', '\n                        id : a -> a\n                        id a = a\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$singleton('1'),
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$typeFunction(
							{
								from: $author$project$Compiler$TypeInference_Test$typeVariable(
									{name: '1'}),
								fromIsMutable: $elm$core$Maybe$Nothing,
								to: $author$project$Compiler$TypeInference_Test$typeVariable(
									{name: '1'})
							})
					}),
				name: 'Identity, no annotation',
				run: function (_v1) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'id', '\n                        id a = a\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$hasError(
			{
				name: 'Reject disconnected forall var types?',
				run: function (_v2) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'id', '\n                        id : a -> b\n                        id l = l\n                        ');
				},
				test: $author$project$Test$errorShouldContain('too general')
			}),
			$author$project$Compiler$TypeInference_Test$isOk(
			{
				name: 'TyVar definitions: lambda scope',
				run: function (_v3) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                a b =\n                  f x = x\n                  f 3\n                  f False\n                ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$isOk(
			{
				name: 'TyVar definitions: non-lambda scope',
				run: function (_v4) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                a =\n                  f x = x\n                  f 3\n                  f False\n                ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$isOk(
			{
				name: 'TyVar definitions: root scope',
				run: function (_v5) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        a x = x\n                        g =\n                          a 3\n                          a False\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$tyNumber
					}),
				name: '[reg] `a` was variable type instead than number',
				run: function (_v6) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'a', '\n                        b x = x\n                        a = b 1\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$tyNumber
					}),
				name: '[reg] make sure that `c` works',
				run: function (_v7) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'c', '\n                        b x = x\n                        c = b 1\n                        ');
				}
			}),
			$author$project$Compiler$TypeInference_Test$simpleTest(
			{
				expected: $elm$core$Result$Ok(
					{
						forall: $elm$core$Set$empty,
						mutable: $elm$core$Maybe$Just(false),
						type_: $author$project$Compiler$TypeInference_Test$tyNumber
					}),
				name: '[reg] it\'s in the declaration order!',
				run: function (_v8) {
					return A2($author$project$Compiler$TypeInference_Test$infer, 'q', '\n                        q =\n                          a = b 1\n                          b x = x\n                          a\n                        ');
				}
			}),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'[reg] statements, assignments, free vars',
			'\n            id a = a\n\n            x q =\n                  s = id q\n                  s\n            ',
			$author$project$Compiler$TypeInference_Test$infer('x'),
			$author$project$Test$okEqual(
				{
					forall: $elm$core$Set$fromList(
						_List_fromArray(
							['1'])),
					mutable: $elm$core$Maybe$Just(false),
					type_: $author$project$Compiler$TypeInference_Test$typeFunction(
						{
							from: $author$project$Compiler$TypeInference_Test$typeVariable(
								{name: '1'}),
							fromIsMutable: $elm$core$Maybe$Nothing,
							to: $author$project$Compiler$TypeInference_Test$typeVariable(
								{name: '1'})
						})
				})),
			A4(
			$author$project$Compiler$TypeInference_Test$codeTest,
			'[reg] ???',
			'\n            reverse : List a -> List a\n            reverse aList =\n                rec ls acc =\n                    try ls as\n                        SPCore.Nil then\n                            acc\n\n                        SPCore.Cons head tail then\n                            rec tail SPCore.Cons head acc\n\n                rec aList []\n            ',
			$author$project$Compiler$TypeInference_Test$infer('reverse'),
			$author$project$Test$errContain(''))
		]));
var $author$project$Compiler$TypeInference_Test$tests = A2(
	$author$project$Test$Group,
	'TypeInference',
	_List_fromArray(
		[$author$project$Compiler$TypeInference_Test$functions, $author$project$Compiler$TypeInference_Test$statements, $author$project$Compiler$TypeInference_Test$variableTypes, $author$project$Compiler$TypeInference_Test$mutability, $author$project$Compiler$TypeInference_Test$higherOrderTypes, $author$project$Compiler$TypeInference_Test$records, $author$project$Compiler$TypeInference_Test$patterns, $author$project$Compiler$TypeInference_Test$try_as, $author$project$Compiler$TypeInference_Test$if_then]));
var $author$project$Test$Skipped = {$: 'Skipped'};
var $author$project$Test$getName = function (test) {
	getName:
	while (true) {
		switch (test.$) {
			case 'Single':
				var n = test.a;
				var f = test.b;
				return n;
			case 'Group':
				var n = test.a;
				var ls = test.b;
				return n;
			default:
				var t = test.a;
				var $temp$test = t;
				test = $temp$test;
				continue getName;
		}
	}
};
var $author$project$Test$outcomesRec = F3(
	function (path, t, accum) {
		switch (t.$) {
			case 'Single':
				var name = t.a;
				var f = t.b;
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(
						_Utils_ap(path, name),
						f(_Utils_Tuple0)),
					accum);
			case 'NotNow':
				var test = t.a;
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(
						_Utils_ap(
							path,
							$author$project$Test$getName(test)),
						$author$project$Test$Skipped),
					accum);
			default:
				var pathSegment = t.a;
				var ts = t.b;
				return A3(
					$elm$core$List$foldl,
					$author$project$Test$outcomesRec(path + (pathSegment + ' / ')),
					accum,
					ts);
		}
	});
var $author$project$Test$style = A3(
	$elm$html$Html$node,
	'style',
	_List_Nil,
	_List_fromArray(
		[
			$elm$html$Html$text('\n.test-item {\n  padding: 1em;\n  margin-bottom: 2px;\n  color: #222;\n}\n\n.test-name {\n  margin-bottom: 0.5em;\n}\n\n.test-ok {\n  background-color: #6f6;\n}\n\n.test-skipped {\n  background-color: #fe3;\n}\n\n.test-error {\n  background-color: #f66;\n}\n\n.test-error-line {\n  margin-bottom: 0.5em;\n}\n  ')
		]));
var $author$project$Test$view = function (_v0) {
	var name = _v0.a;
	var outcome = _v0.b;
	return A2(
		$elm$html$Html$div,
		_List_fromArray(
			[
				$elm$html$Html$Attributes$class('test-item'),
				function () {
				switch (outcome.$) {
					case 'Success':
						return $elm$html$Html$Attributes$class('test-ok');
					case 'Skipped':
						return $elm$html$Html$Attributes$class('test-skipped');
					default:
						var e = outcome.a;
						return $elm$html$Html$Attributes$class('test-error');
				}
			}()
			]),
		_List_fromArray(
			[
				A2(
				$elm$html$Html$pre,
				_List_fromArray(
					[
						$elm$html$Html$Attributes$class('test-name')
					]),
				_List_fromArray(
					[
						$elm$html$Html$text(name)
					])),
				A2(
				$elm$html$Html$code,
				_List_Nil,
				_List_fromArray(
					[
						function () {
						switch (outcome.$) {
							case 'Success':
								return $elm$html$Html$text('Ok!');
							case 'Skipped':
								return $elm$html$Html$text('Skipped!');
							default:
								var error = outcome.a;
								return A2(
									$elm$html$Html$code,
									_List_Nil,
									_List_fromArray(
										[
											A2(
											$elm$html$Html$pre,
											_List_Nil,
											_List_fromArray(
												[
													$elm$html$Html$text(error)
												]))
										]));
						}
					}()
					]))
			]));
};
var $author$project$Test$viewList = function (tests) {
	return A2(
		$elm$html$Html$div,
		_List_Nil,
		A2(
			$elm$core$List$cons,
			$author$project$Test$style,
			A2(
				$elm$core$List$map,
				$author$project$Test$view,
				A2(
					$elm$core$List$sortBy,
					function (_v0) {
						var name = _v0.a;
						var outcome = _v0.b;
						switch (outcome.$) {
							case 'Error':
								var e = outcome.a;
								return -1;
							case 'Skipped':
								return 0;
							default:
								return 1;
						}
					},
					A3(
						$elm$core$List$foldl,
						$author$project$Test$outcomesRec(''),
						_List_Nil,
						tests)))));
};
var $author$project$Main$tests = (!$author$project$Main$runTests) ? $elm$html$Html$text('') : $author$project$Test$viewList(
	_List_fromArray(
		[$author$project$Compiler$StringToTokens_Test$tests, $author$project$Compiler$TokensToFormattableAst_Test$tests, $author$project$Compiler$TypeInference_Test$tests, $author$project$Compiler$ApplyAliases_Test$tests, $author$project$Compiler$JsToString_Test$tests, $author$project$Compiler$CanonicalToJs_Test$tests, $author$project$Compiler$FormattableToCanonicalAst_Test$tests]));
var $author$project$Main$viewTests = (!$author$project$Main$runTests) ? A2(
	$elm$html$Html$div,
	_List_Nil,
	_List_fromArray(
		[
			A2(
			$elm$html$Html$h6,
			_List_fromArray(
				[
					A2($elm$html$Html$Attributes$style, 'color', 'red')
				]),
			_List_fromArray(
				[
					$elm$html$Html$text('TESTS DISABLED')
				]))
		])) : A2(
	$elm$html$Html$div,
	_List_fromArray(
		[
			$elm$html$Html$Attributes$class('mt ml')
		]),
	_List_fromArray(
		[$author$project$Main$tests]));
var $author$project$Main$view = function (model) {
	return A2(
		$elm$html$Html$div,
		_List_fromArray(
			[
				$elm$html$Html$Attributes$class('col')
			]),
		_List_fromArray(
			[
				$author$project$Main$viewFilesSelector(model),
				A2(
				$elm$html$Html$div,
				_List_fromArray(
					[
						$elm$html$Html$Attributes$class('row thirds')
					]),
				_List_fromArray(
					[
						$author$project$Main$viewSelectedFile(model),
						$author$project$Main$viewProgram(model),
						$author$project$Main$viewTests
					])),
				A3(
				$elm$html$Html$node,
				'style',
				_List_Nil,
				_List_fromArray(
					[
						$elm$html$Html$text($author$project$Css$css)
					]))
			]));
};
var $author$project$Main$main = $elm$browser$Browser$sandbox(
	{init: $author$project$Main$init, update: $author$project$Main$update, view: $author$project$Main$view});
_Platform_export({'Main':{'init':$author$project$Main$main(
	$elm$json$Json$Decode$succeed(_Utils_Tuple0))(0)}});}(this));

  var app = Elm.Main.init({ node: document.getElementById("elm") });
}
catch (e)
{
  // display initialization errors (e.g. bad flags, infinite recursion)
  var header = document.createElement("h1");
  header.style.fontFamily = "monospace";
  header.innerText = "Initialization Error";
  var pre = document.getElementById("elm");
  document.body.insertBefore(header, pre);
  pre.innerText = e;
  throw e;
}
</script>

</body>
</html>